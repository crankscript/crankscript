/// <reference types="lua-types/5.4" />
// noinspection JSUnusedGlobalSymbols,JSDuplicatedDeclaration,ReservedWordAsName

/**
 * Text output from `print()` will be displayed in the simulator’s console, in black if generated by a game running in the simulator or in blue if it’s coming from a plugged-in Playdate device. Printed text is also copied to stdout, which is helpful if you run the simulator from the command line.
 *
 * Tip
 *
 * You should ideally remove debugging print statements from your final games to improve performance.
 *
 * [Read more](https://sdk.play.date/2.5.0#f-print)
 *
 * @noSelf
 */
function print(...arg: unknown[]): void;

/**
 * Identical to `print()`, but instead of a string `printTable()` prints the contents of a table formatted for legibility.
 *
 * Important
 *
 * You must import _CoreLibs/object_ to use `printTable`.
 *
 * Tip
 *
 * You should ideally remove debugging print statements from your final games to improve performance.
 *
 * [Read more](https://sdk.play.date/2.5.0#f-printTable)
 *
 * @noSelf
 */
function printTable(table: AnyTable): void;

/**
 * Returns a single-line stack trace as a string. For example:
 *
 *     main.lua:10 foo() < main.lua:18 (from C)
 *
 * Use `print(where())` to see this trace written to the console.
 *
 * Important
 *
 * You must import _CoreLibs/utilities/where_ to use this function.
 *
 * [Read more](https://sdk.play.date/2.5.0#f-where)
 *
 * @noSelf
 */
function where(): string;

namespace playdate {
    import {
        PlaydateColor,
        PlaydateButton,
        PlaydateLanguage,
        PlaydateFlip,
        PlaydatePolygonFill,
        PlaydateDitherType,
        PlaydateLineCapStyle,
        PlaydateDrawMode,
        PlaydateStrokeLocation,
        PlaydateFontVariant,
        PlaydateTextAlignment,
        PlaydateCollisionResponse,
        PlaydateCapitalizationBehavior,
        PlaydateSoundFormat,
        PlaydateSoundWave,
        PlaydateSoundLfoType,
        PlaydateSoundTwoPoleFilterType,
        PlaydateFileOpenMode,
    } from '@crankscript/core';
    type PlaydateInputHandler = {
        AButtonDown: typeof AButtonDown;
        AButtonHeld: typeof AButtonHeld;
        AButtonUp: typeof AButtonUp;
        BButtonDown: typeof BButtonDown;
        BButtonHeld: typeof BButtonHeld;
        BButtonUp: typeof BButtonUp;
        downButtonDown: typeof downButtonDown;
        downButtonUp: typeof downButtonUp;
        leftButtonDown: typeof leftButtonDown;
        leftButtonUp: typeof leftButtonUp;
        rightButtonDown: typeof rightButtonDown;
        rightButtonUp: typeof rightButtonUp;
        upButtonDown: typeof upButtonDown;
        upButtonUp: typeof upButtonUp;
        cranked: typeof cranked;
        crankDocked: typeof crankDocked;
        crankUndocked: typeof crankUndocked;
    };
    type PlaydateFontFamily = {
        [PlaydateFontVariant.Normal]: playdate.graphics.font;
        [PlaydateFontVariant.Bold]: playdate.graphics.font;
        [PlaydateFontVariant.Italic]: playdate.graphics.font;
    };
    type PlaydateFontFamilyPaths = {
        [PlaydateFontVariant.Normal]: string;
        [PlaydateFontVariant.Bold]: string;
        [PlaydateFontVariant.Italic]: string;
    };
    type PlaydateGenericCollision<
        TType extends PlaydateCollisionResponse,
        TExtra = {}
    > = {
        sprite: playdate.graphics.sprite;
        other: playdate.graphics.sprite;
        type: TType;
        overlaps: boolean;
        ti: number;
        move: playdate.geometry.vector2D;
        normal: playdate.geometry.vector2D;
        touch: playdate.geometry.point;
        spriteRect: playdate.geometry.rect;
        otherRect: playdate.geometry.rect;
    } & TExtra;
    type PlaydateCollision =
        | PlaydateGenericCollision<PlaydateCollisionResponse.Overlap>
        | PlaydateGenericCollision<PlaydateCollisionResponse.Freeze>
        | PlaydateGenericCollision<
              PlaydateCollisionResponse.Bounce,
              { bounce: playdate.geometry.point }
          >
        | PlaydateGenericCollision<
              PlaydateCollisionResponse.Slide,
              { slide: playdate.geometry.point }
          >;
    type PlaydateEasingFunction =
        | typeof easingFunctions.linear
        | typeof easingFunctions.inQuad
        | typeof easingFunctions.outQuad
        | typeof easingFunctions.inOutQuad
        | typeof easingFunctions.outInQuad
        | typeof easingFunctions.inCubic
        | typeof easingFunctions.outCubic
        | typeof easingFunctions.inOutCubic
        | typeof easingFunctions.outInCubic
        | typeof easingFunctions.inQuart
        | typeof easingFunctions.outQuart
        | typeof easingFunctions.inOutQuart
        | typeof easingFunctions.outInQuart
        | typeof easingFunctions.inQuint
        | typeof easingFunctions.outQuint
        | typeof easingFunctions.inOutQuint
        | typeof easingFunctions.outInQuint
        | typeof easingFunctions.inSine
        | typeof easingFunctions.outSine
        | typeof easingFunctions.inOutSine
        | typeof easingFunctions.outInSine
        | typeof easingFunctions.inExpo
        | typeof easingFunctions.outExpo
        | typeof easingFunctions.inOutExpo
        | typeof easingFunctions.outInExpo
        | typeof easingFunctions.inCirc
        | typeof easingFunctions.outCirc
        | typeof easingFunctions.inOutCirc
        | typeof easingFunctions.outInCirc
        | typeof easingFunctions.inElastic
        | typeof easingFunctions.outElastic
        | typeof easingFunctions.inOutElastic
        | typeof easingFunctions.outInElastic
        | typeof easingFunctions.inBack
        | typeof easingFunctions.outBack
        | typeof easingFunctions.inOutBack
        | typeof easingFunctions.outInBack
        | typeof easingFunctions.outBounce
        | typeof easingFunctions.inBounce
        | typeof easingFunctions.inOutBounce
        | typeof easingFunctions.outInBounce;
    type PlaydateCollisionInfo = {
        sprite: playdate.graphics.sprite;
        entryPoint: playdate.geometry.point;
        exitPoint: playdate.geometry.point;
        ti1: number;
        ti2: number;
    };
    type PlaydateAudioSource =
        | playdate.sound.fileplayer
        | playdate.sound.sampleplayer
        | playdate.sound.synth
        | playdate.sound.instrument;
    type PlaydateSoundEffect =
        | playdate.sound.bitcrusher
        | playdate.sound.twopolefilter
        | playdate.sound.onepolefilter
        | playdate.sound.ringmod
        | playdate.sound.overdrive
        | playdate.sound.delayline;

    /**
     * Returns two values, the current API version of the Playdate runtime and the minimum API version supported by the runtime.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-apiVersion)
     *
     * @noSelf
     */
    export function apiVersion(): LuaMultiReturn<[number, number]>;

    /**
     * The `playdate.metadata` table contains the values in the current game’s [pdxinfo](https://sdk.play.date/2.5.0#pdxinfo) file, keyed by variable name. To retrieve the version number of the game, for example, you would use `playdate.metadata.version`.
     *
     * Changing values in this table at run time has no effect.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-metadata)
     *
     * @noSelf
     */
    export function metadata(): AnyTable;

    /**
     * Implement this callback and Playdate OS will call it once per frame. This is the place to put the main update-and-draw code for your game. Playdate will attempt to call this function by default 30 times per second; that value can be changed by calling [playdate.display.setRefreshRate()](https://sdk.play.date/2.5.0#f-display.setRefreshRate).
     *
     * Note
     *
     * If your `update()` function takes too long to execute, Playdate OS may not be able to call it as often as specified by the current refresh rate. In this case, Playdate OS will simply try and call it as often as it can, with a not-to-exceed rate of [playdate.display.getRefreshRate()](https://sdk.play.date/2.5.0#f-display.getRefreshRate) frames per second.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-update)
     *
     * @noSelf
     */
    export function update(): void;

    /**
     * Suspends callbacks to [`playdate.update()`](https://sdk.play.date/2.5.0#c-update) for the specified number of milliseconds.
     *
     * Tip
     *
     * `playdate.wait()` is ideal for pausing game execution to, for example, show a message to the player. Because `.update()` will not be called, the screen will freeze during `.wait()`. Audio will continue to play. Animation during this wait period is possible, but you will need to explicitly call [`playdate.display.flush()`](https://sdk.play.date/2.5.0#f-display.flush) once per frame.
     *
     * Caution
     *
     * While timers should pause during `playdate.wait()` (assuming [`playdate.timer.updateTimers()`](https://sdk.play.date/2.5.0#f-timer.updateTimers) and [`playdate.frameTimer.updateTimers()`](https://sdk.play.date/2.5.0#f-frameTimer.updateTimers) are invoked during `playdate.update()`), [animators](https://sdk.play.date/2.5.0#C-graphics.animator) will _not_ pause during `playdate.wait()`. Be sure to account for this in your code.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-wait)
     *
     * @noSelf
     */
    export function wait(milliseconds: number): void;

    /**
     * Stops per-frame callbacks to [playdate.update()](https://sdk.play.date/2.5.0#c-update). Useful in conjunction with [playdate.display.flush()](https://sdk.play.date/2.5.0#f-display.flush) if your program only does things in response to button presses.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-stop)
     *
     * @noSelf
     */
    export function stop(): void;

    /**
     * Resumes per-frame callbacks to [playdate.update()](https://sdk.play.date/2.5.0#c-update).
     *
     * [Read more](https://sdk.play.date/2.5.0#f-start)
     *
     * @noSelf
     */
    export function start(): void;

    /**
     * Reinitializes the Playdate runtime and restarts the currently running game. The optional string `arg` passed in is available after restart in [playdate.argv](https://sdk.play.date/2.5.0#v-argv) as if it had been passed in on the command line when launching the simulator.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-restart)
     *
     * @noSelf
     */
    export function restart(arg?: unknown): void;

    /**
     * Called when the player chooses to exit the game via the System Menu or Menu button.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-gameWillTerminate)
     *
     * @noSelf
     */
    export function gameWillTerminate(): void;

    /**
     * Called before the device goes to low-power sleep mode because of a low battery.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-deviceWillSleep)
     *
     * @noSelf
     */
    export function deviceWillSleep(): void;

    /**
     * If your game is running on the Playdate when the device is locked, this function will be called. Implementing this function allows your game to take special action when the Playdate is locked, e.g., saving state.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-deviceWillLock)
     *
     * @noSelf
     */
    export function deviceWillLock(): void;

    /**
     * If your game is running on the Playdate when the device is unlocked, this function will be called.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-deviceDidUnlock)
     *
     * @noSelf
     */
    export function deviceDidUnlock(): void;

    /**
     * Called before the system pauses the game. (In the current version of Playdate OS, this only happens when the device’s Menu button is pushed.) Implementing these functions allows your game to take special action when it is paused, e.g., updating the [menu image](https://sdk.play.date/2.5.0#f-setMenuImage).
     *
     * [Read more](https://sdk.play.date/2.5.0#c-gameWillPause)
     *
     * @noSelf
     */
    export function gameWillPause(): void;

    /**
     * Called before the system resumes the game.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-gameWillResume)
     *
     * @noSelf
     */
    export function gameWillResume(): void;

    /**
     * Returns a `playdate.menu` object. Use this to add your custom menu items.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-menu.getSystemMenu)
     *
     * @noSelf
     */
    export function getSystemMenu(): playdate.menu;

    /**
     * While the game is paused it can optionally provide an image to be displayed alongside the System Menu. Use this function to set that image.
     *
     * _image_ should be a 400 x 240 pixel [playdate.graphics.image](https://sdk.play.date/2.5.0#C-graphics.image). All important content should be in the left half of the image in an area 200 pixels wide, as the menu will obscure the rest. The right side of the image will be visible briefly as the menu animates in and out.
     *
     * Optionally, _xOffset_ can be provided which must be a number between 0 and 200 and will cause the menu image to animate to a position offset left by _xOffset_ pixels as the menu is animated in.
     *
     * To remove a previously-set menu image, pass `nil` for the _image_ argument.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-setMenuImage)
     *
     * @noSelf
     */
    export function setMenuImage(
        image: playdate.graphics.image | null,
        xOffset?: number
    ): void;

    /**
     * Returns the current language of the system, which will be one of the constants _playdate.graphics.font.kLanguageEnglish_ or _playdate.graphics.font.kLanguageJapanese_.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-getSystemLanguage)
     *
     * @noSelf
     */
    export function getSystemLanguage(): PlaydateLanguage;

    /**
     * Returns _true_ if the user has checked the "Reduce Flashing" option in Playdate Settings; _false_ otherwise. Games should read this value and, if _true_, avoid visuals that could be problematic for people with sensitivities to flashing lights or patterns.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-getReduceFlashing)
     *
     * @noSelf
     */
    export function getReduceFlashing(): boolean;

    /**
     * Returns _true_ if the user has checked the "Upside Down" option in Playdate Settings; _false_ otherwise. (Upside Down mode can be convenient for players wanting to hold Playdate upside-down so they can use their left hand to operate the crank.)
     *
     * Typically your game doesn’t need to anything in regards to this setting. But it is available in case your game wants to take some special actions, display special instructions, etc.
     *
     * Important
     *
     * Reported d-pad directions are flipped when in Upside Down mode — RIGHT will be reported as LEFT, UP as DOWN, etc. — so that the d-pad will make sense to a user holding Playdate upside-down. However, the A and B buttons — since they are still labeled as "A" and "B" — retain their normal meanings and will be reported as usual.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-getFlipped)
     *
     * @noSelf
     */
    export function getFlipped(): boolean;

    /**
     * The accelerometer is off by default, to save a bit of power. If you will be using the accelerometer in your game, you’ll first need to call `playdate.startAccelerometer()` then wait for the next update cycle before reading its values. If you won’t be using the accelerometer again for a while, calling `playdate.stopAccelerometer()` will put it back into a low-power idle state.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-startAccelerometer)
     *
     * @noSelf
     */
    export function startAccelerometer(): void;

    /**
     * Puts the accelerometer into a low-power idle state. (Though, to be honest, the accelerometer draws so little power when it’s running you’d never notice the difference.)
     *
     * [Read more](https://sdk.play.date/2.5.0#f-stopAccelerometer)
     *
     * @noSelf
     */
    export function stopAccelerometer(): void;

    /**
     * If the accelerometer has been turned on with [playdate.startAccelerometer()](https://sdk.play.date/2.5.0#f-startAccelerometer), returns the x, y, and z values from the accelerometer as a list. Positive x points right, positive y points to the bottom of the screen, and positive z points through the screen away from the viewer. For example, with the device held upright this function returns the values (0,1,0). With it flat on its back, it returns (0,0,1).
     *
     * [Read more](https://sdk.play.date/2.5.0#f-readAccelerometer)
     *
     * @noSelf
     */
    export function readAccelerometer(): LuaMultiReturn<
        [number, number, number]
    >;

    /**
     * Returns true if the accelerometer is currently running.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-accelerometerIsRunning)
     *
     * @noSelf
     */
    export function accelerometerIsRunning(): boolean;

    /**
     * Returns true if _button_ is currently being pressed.
     *
     * _button_ should be one of the constants:
     *
     * *   _playdate.kButtonA_
     *
     * *   _playdate.kButtonB_
     *
     * *   _playdate.kButtonUp_
     *
     * *   _playdate.kButtonDown_
     *
     * *   _playdate.kButtonLeft_
     *
     * *   _playdate.kButtonRight_
     *
     *
     * Or one of the strings "a", "b", "up", "down", "left", "right".
     *
     * [Read more](https://sdk.play.date/2.5.0#f-buttonIsPressed)
     *
     * @noSelf
     */
    export function buttonIsPressed(button: PlaydateButton): boolean;

    /**
     * Returns true for _just one update cycle_ if _button_ was pressed. `buttonJustPressed` will not return true again until the button is released and pressed again. This is useful for, say, a player "jump" action, so the jump action is taken only once and not on every single update.
     *
     * _button_ should be one of the constants listed in [playdate.buttonIsPressed()](https://sdk.play.date/2.5.0#f-buttonIsPressed)
     *
     * [Read more](https://sdk.play.date/2.5.0#f-buttonJustPressed)
     *
     * @noSelf
     */
    export function buttonJustPressed(button: PlaydateButton): boolean;

    /**
     * Returns true for _just one update cycle_ if _button_ was released. `buttonJustReleased` will not return true again until the button is pressed and released again.
     *
     * _button_ should be one of the constants listed in [playdate.buttonIsPressed()](https://sdk.play.date/2.5.0#f-buttonIsPressed)
     *
     * [Read more](https://sdk.play.date/2.5.0#f-buttonJustReleased)
     *
     * @noSelf
     */
    export function buttonJustReleased(button: PlaydateButton): boolean;

    /**
     * Returns the above data in one call, with multiple return values (_current_, _pressed_, _released_) containing bitmasks indicating which buttons are currently down, and which were pressed and released since the last update. For example, if the d-pad left button and the A button are both down, the _current_ value will be (_playdate.kButtonA_|_playdate.kButtonLeft_).
     *
     * [Read more](https://sdk.play.date/2.5.0#f-getButtonState)
     *
     * @noSelf
     */
    export function getButtonState(): LuaMultiReturn<[number, number, number]>;

    /**
     * When set, button up/down events on the D pad and the A and B buttons are added to a list instead of simply polled at the beginning of a frame, allowing the code to handle multiple taps on a given button in a single frame. At the default 30 FPS, a queue size of 5 should be adequate. At lower frame rates/longer frame times, the queue size should be extended until all button presses are caught. Additionally, when the button queue is enabled the button callbacks listed below are passed the event time as an argument.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-setButtonQueueSize)
     *
     * @noSelf
     */
    export function setButtonQueueSize(size: number): void;

    /**
     * Called immediately after the player presses the A Button.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-AButtonDown)
     *
     * @noSelf
     */
    export function AButtonDown(): void;

    /**
     * Called after the A Button is held down for one second. This can be used for secondary actions (e.g., displaying a game world map, changing weapons).
     *
     * [Read more](https://sdk.play.date/2.5.0#c-AButtonHeld)
     *
     * @noSelf
     */
    export function AButtonHeld(): void;

    /**
     * Called immediately after the player releases the A Button.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-AButtonUp)
     *
     * @noSelf
     */
    export function AButtonUp(): void;

    /**
     * Called immediately after the player presses the B Button.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-BButtonDown)
     *
     * @noSelf
     */
    export function BButtonDown(): void;

    /**
     * Called after the B Button is held down for one second. This can be used for secondary actions (e.g., displaying a game world map, changing weapons).
     *
     * [Read more](https://sdk.play.date/2.5.0#c-BButtonHeld)
     *
     * @noSelf
     */
    export function BButtonHeld(): void;

    /**
     * Called immediately after the player releases the B Button.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-BButtonUp)
     *
     * @noSelf
     */
    export function BButtonUp(): void;

    /**
     * Called immediately after the player presses the down direction on the d-pad.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-downButtonDown)
     *
     * @noSelf
     */
    export function downButtonDown(): void;

    /**
     * Called immediately after the player releases the down direction on the d-pad.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-downButtonUp)
     *
     * @noSelf
     */
    export function downButtonUp(): void;

    /**
     * Called immediately after the player presses the left direction on the d-pad.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-leftButtonDown)
     *
     * @noSelf
     */
    export function leftButtonDown(): void;

    /**
     * Called immediately after the player releases the left direction on the d-pad.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-leftButtonUp)
     *
     * @noSelf
     */
    export function leftButtonUp(): void;

    /**
     * Called immediately after the player presses the right direction on the d-pad.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-rightButtonDown)
     *
     * @noSelf
     */
    export function rightButtonDown(): void;

    /**
     * Called immediately after the player releases the right direction on the d-pad.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-rightButtonUp)
     *
     * @noSelf
     */
    export function rightButtonUp(): void;

    /**
     * Called immediately after the player presses the up direction on the d-pad.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-upButtonDown)
     *
     * @noSelf
     */
    export function upButtonDown(): void;

    /**
     * Called immediately after the player releases the up direction on the d-pad.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-upButtonUp)
     *
     * @noSelf
     */
    export function upButtonUp(): void;

    /**
     * Returns a boolean indicating whether or not the crank is folded into the unit.
     *
     * Tip
     *
     * If your game requires the crank and `:isCrankDocked()` is true, you can use a [crank alert](https://sdk.play.date/2.5.0#C-ui.crankIndicator) to notify the user that the crank should be extended.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-isCrankDocked)
     *
     * @noSelf
     */
    export function isCrankDocked(): boolean;

    /**
     * Returns the absolute position of the crank (in degrees). Zero is pointing straight up parallel to the device. Turning the crank clockwise (when looking at the right edge of an upright device) increases the angle, up to a maximum value 359.9999. The value then resets back to zero as the crank continues its rotation.
     *
     *     local crankPosition = playdate.getCrankPosition()
     *
     * [Read more](https://sdk.play.date/2.5.0#f-getCrankPosition)
     *
     * @noSelf
     */
    export function getCrankPosition(): number;

    /**
     * Returns two values, _change_ and _acceleratedChange_. _change_ represents the angle change (in degrees) of the crank since the last time this function (or the [playdate.cranked()](https://sdk.play.date/2.5.0#c-cranked) callback) was called. Negative values are anti-clockwise. _acceleratedChange_ is change multiplied by a value that increases as the crank moves faster, similar to the way mouse acceleration works.
     *
     *     local change, acceleratedChange = playdate.getCrankChange()
     *
     * [Read more](https://sdk.play.date/2.5.0#f-getCrankChange)
     *
     * @noSelf
     */
    export function getCrankChange(): LuaMultiReturn<[number, number]>;

    /**
     * Returns the number of "ticks" — whose frequency is defined by the value of _ticksPerRevolution_ — the crank has turned through since the last time this function was called. Tick boundaries are set at absolute positions along the crank’s rotation. Ticks can be positive or negative, depending upon the direction of rotation.
     *
     * For example, say you have a movie player and you want your movie to advance 6 frames for every one revolution of the crank. Calling `playdate.getCrankTicks(6)` during each update will give you a return value of 1 as the crank turns past each 60 degree increment. (Since we passed in a 6, each tick represents 360 ÷ 6 = 60 degrees.) So `getCrankTicks(6)` will return a 1 as the crank turns past the 0 degree absolute position, the 60 degree absolute position, and so on for the 120, 180, 240, and 300 degree positions. Otherwise, 0 will be returned. (-1 will be returned if the crank moves past one of these mentioned positions while going in a backward direction.)
     *
     * Important
     *
     * You must import _CoreLibs/crank_ to use `getCrankTicks()`.
     *
     * Example: Reading crank input using getCrankTicks
     *
     *     import "CoreLibs/crank"
     *
     *     local ticksPerRevolution = 6
     *
     *     function playdate.update()
     *         local crankTicks = playdate.getCrankTicks(ticksPerRevolution)
     *
     *         if crankTicks == 1 then
     *             print("Forward tick")
     *         elseif crankTicks == -1 then
     *             print("Backward tick")
     *         end
     *     end
     *
     * [Read more](https://sdk.play.date/2.5.0#f-getCrankTicks)
     *
     * @noSelf
     */
    export function getCrankTicks(ticksPerRevolution: number): number;

    /**
     * For playdate.cranked(), _change_ is the angle change in degrees. _acceleratedChange_ is _change_ multiplied by a value that increases as the crank moves faster, similar to the way mouse acceleration works. Negative values are anti-clockwise.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-cranked)
     *
     * @noSelf
     */
    export function cranked(change: number, acceleratedChange: number): void;

    /**
     * This function, if defined, is called when the crank is docked.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-crankDocked)
     *
     * @noSelf
     */
    export function crankDocked(): void;

    /**
     * This function, if defined, is called when the crank is undocked.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-crankUndocked)
     *
     * @noSelf
     */
    export function crankUndocked(): void;

    /**
     * _True_ disables the default crank docking/undocking sound effects. _False_ re-enables them. Useful if the crank sounds seem out-of-place in your game.
     *
     * Note
     *
     * When your game terminates, crank sounds will automatically be re-enabled.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-setCrankSoundsDisabled)
     *
     * @noSelf
     */
    export function setCrankSoundsDisabled(disable: boolean): void;

    /**
     * _True_ disables the 3 minute auto-lock feature. _False_ re-enables it and resets the timer back to 3 minutes.
     *
     * Note
     *
     * Auto-lock will automatically be re-enabled when your game terminates.
     *
     * Tip
     *
     * If disabling auto-lock, developers should look for opportunities to re-enable auto-lock when appropriate. (For example, if your game is an MP3 audio player, auto-lock could be re-enabled when the user pauses the audio.)
     *
     * [Read more](https://sdk.play.date/2.5.0#f-setAutoLockDisabled)
     *
     * @noSelf
     */
    export function setAutoLockDisabled(disable: boolean): boolean;

    /**
     * Returns the number of milliseconds the game has been _active_ since launched.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-getCurrentTimeMilliseconds)
     *
     * @noSelf
     */
    export function getCurrentTimeMilliseconds(): number;

    /**
     * Resets the high-resolution timer.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-resetElapsedTime)
     *
     * @noSelf
     */
    export function resetElapsedTime(): number;

    /**
     * Returns the number of seconds since `playdate.resetElapsedTime()` was called. The value is a floating-point number with microsecond accuracy.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-getElapsedTime)
     *
     * @noSelf
     */
    export function getElapsedTime(): number;

    /**
     * Returns the number of seconds and milliseconds elapsed since midnight (hour 0), January 1 2000 UTC, as a list: _(seconds, milliseconds)_. This function is suitable for seeding the random number generator:
     *
     * Sample code for seeding the random number generator
     *
     *     math.randomseed(playdate.getSecondsSinceEpoch())
     *
     * [Read more](https://sdk.play.date/2.5.0#f-getSecondsSinceEpoch)
     *
     * @noSelf
     */
    export function getSecondsSinceEpoch(): number;

    /**
     * Returns a table with values for the local time, accessible via the following keys:
     *
     * *   _year_: 4-digit year (until 10,000 AD)
     *
     * *   _month_: month of the year, where 1 is January and 12 is December
     *
     * *   _day_: day of the month, 1 - 31
     *
     * *   _weekday_: day of the week, where 1 is Monday and 7 is Sunday
     *
     * *   _hour_: 0 - 23
     *
     * *   _minute_: 0 - 59
     *
     * *   _second_: 0 - 59 (or 60 on a leap second)
     *
     * *   _millisecond_: 0 - 999
     *
     * [Read more](https://sdk.play.date/2.5.0#f-getTime)
     *
     * @noSelf
     */
    export function getTime(): {
        year: number;
        month: number;
        day: number;
        weekday: number;
        hour: number;
        minute: number;
        second: number;
        millisecond: number;
    };

    /**
     * Returns a table in the same format as [playdate.getTime()](https://sdk.play.date/2.5.0#f-getTime), but in GMT rather than local time.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-getGMTTime)
     *
     * @noSelf
     */
    export function getGMTTime(): {
        year: number;
        month: number;
        day: number;
        weekday: number;
        hour: number;
        minute: number;
        second: number;
        millisecond: number;
    };

    /**
     * Returns the number of seconds and milliseconds between midnight (hour 0), January 1 2000 UTC and _time_, specified in local time, as a list: _(seconds, milliseconds)_.
     *
     * _time_ should be a table of the same format as the one returned by [playdate.getTime()](https://sdk.play.date/2.5.0#f-getTime).
     *
     * [Read more](https://sdk.play.date/2.5.0#f-epochFromTime)
     *
     * @noSelf
     */
    export function epochFromTime(time: {
        year: number;
        month: number;
        day: number;
        weekday: number;
        hour: number;
        minute: number;
        second: number;
        millisecond: number;
    }): LuaMultiReturn<[number, number]>;

    /**
     * Returns the number of seconds and milliseconds between midnight (hour 0), January 1 2000 UTC and _time_, specified in GMT time, as a list: _(seconds, milliseconds)_.
     *
     * _time_ should be a table of the same format as the one returned by [playdate.getTime()](https://sdk.play.date/2.5.0#f-getTime).
     *
     * [Read more](https://sdk.play.date/2.5.0#f-epochFromGMTTime)
     *
     * @noSelf
     */
    export function epochFromGMTTime(time: {
        year: number;
        month: number;
        day: number;
        weekday: number;
        hour: number;
        minute: number;
        second: number;
        millisecond: number;
    }): LuaMultiReturn<[number, number]>;

    /**
     * Converts the epoch to a local date and time table, in the same format as the table returned by [playdate.getTime()](https://sdk.play.date/2.5.0#f-getTime).
     *
     * [Read more](https://sdk.play.date/2.5.0#f-timeFromEpoch)
     *
     * @noSelf
     */
    export function timeFromEpoch(
        seconds: number,
        milliseconds: number
    ): {
        year: number;
        month: number;
        day: number;
        weekday: number;
        hour: number;
        minute: number;
        second: number;
        millisecond: number;
    };

    /**
     * Converts the epoch to a GMT date and time table, in the same format as the table returned by [playdate.getTime()](https://sdk.play.date/2.5.0#f-getTime).
     *
     * [Read more](https://sdk.play.date/2.5.0#f-GMTTimeFromEpoch)
     *
     * @noSelf
     */
    export function GMTTimeFromEpoch(
        seconds: number,
        milliseconds: number
    ): {
        year: number;
        month: number;
        day: number;
        weekday: number;
        hour: number;
        minute: number;
        second: number;
        millisecond: number;
    };

    /**
     * Returns true if the user has set the 24-Hour Time preference in the Settings program.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-shouldDisplay24HourTime)
     *
     * @noSelf
     */
    export function shouldDisplay24HourTime(): boolean;

    /**
     * _flag_ determines whether or not the print() function adds a newline to the end of the printed text. Default is _true_.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-setNewlinePrinted)
     *
     * @noSelf
     */
    export function setNewlinePrinted(flag: boolean): void;

    /**
     * Calculates the current frames per second and draws that value at _x, y_.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-drawFPS)
     *
     * @noSelf
     */
    export function drawFPS(x: number, y: number): void;

    /**
     * Returns the _measured, actual_ refresh rate in frames per second. This value may be different from the _specified_ refresh rate (see [playdate.display.getRefreshRate()](https://sdk.play.date/2.5.0#f-display.getRefreshRate)) by a little or a lot depending upon how much calculation is being done per frame.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-getFPS)
     *
     * @noSelf
     */
    export function getFPS(): number;

    /**
     * Returns a table containing percentages of time spent in each system task over the last interval, if more than zero. Possible keys are
     *
     * *   `kernel`
     *
     * *   `serial`
     *
     * *   `game`
     *
     * *   `GC`
     *
     * *   `wifi`
     *
     * *   `audio`
     *
     * *   `trace`
     *
     * *   `idle`
     *
     *
     * Important
     *
     * `playdate.getStats()` only functions on a Playdate device. In the Simulator, this function returns `nil`.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-getStats)
     *
     * @noSelf
     */
    export function getStats(): {
        kernel: number;
        serial: number;
        game: number;
        GC: number;
        wifi: number;
        audio: number;
        trace: number;
        idle: number;
    };

    /**
     * `setStatsInterval()` sets the length of time for each sample frame of runtime stats. Set _seconds_ to zero to disable stats collection.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-setStatsInterval)
     *
     * @noSelf
     */
    export function setStatsInterval(seconds: number): void;

    /**
     * Returns a table holding booleans with the following keys:
     *
     * *   _charging_: The battery is actively being charged
     *
     * *   _USB_: There is a powered USB cable connected
     *
     * *   _screws_: There is 5V being applied to the corner screws (via the dock, for example)
     *
     * [Read more](https://sdk.play.date/2.5.0#f-getPowerStatus)
     *
     * @noSelf
     */
    export function getPowerStatus(): {
        charging: boolean;
        USB: boolean;
        screws: boolean;
    };

    /**
     * Returns a value from 0-100 denoting the current level of battery charge. 0 = empty; 100 = full.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-getBatteryPercentage)
     *
     * @noSelf
     */
    export function getBatteryPercentage(): number;

    /**
     * Returns the battery’s current voltage level.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-getBatteryVoltage)
     *
     * @noSelf
     */
    export function getBatteryVoltage(): number;

    /**
     * Clears the simulator console.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-clearConsole)
     *
     * @noSelf
     */
    export function clearConsole(): void;

    /**
     * Sets the color of the [playdate.debugDraw()](https://sdk.play.date/2.5.0#c-debugDraw) overlay image. Values are in the range 0-1.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-setDebugDrawColor)
     *
     * @noSelf
     */
    export function setDebugDrawColor(
        r: number,
        g: number,
        b: number,
        a: number
    ): void;

    /**
     * Lets you act on keyboard keypresses when running in the Simulator ONLY. These can be useful for adding debugging functions that can be enabled via your keyboard.
     *
     * Note
     *
     * It is possible test a game on Playdate hardware and trap computer keyboard keypresses if you are using the Simulator’s `Control Device with Simulator` option.
     *
     * `key` is a string containing the character pressed or released on the keyboard. Note that:
     *
     * *   The key in question needs to have a textual representation or these functions will not be called. For instance, alphanumeric keys will call these functions; keyboard directional arrows will not.
     *
     * *   If the keypress in question is already in use by the Simulator for another purpose (say, to control the d-pad or A/B buttons), these functions will not be called.
     *
     * *   If _key_ is an alphabetic character, the value will always be lowercase, even if the user deliberately typed an uppercase character.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-keyPressed)
     *
     * @noSelf
     */
    export function keyPressed(key: string): void;

    /**
     * Lets you act on keyboard key releases when running in the Simulator ONLY. These can be useful for adding debugging functions that can be enabled via your keyboard.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-keyReleased)
     *
     * @noSelf
     */
    export function keyReleased(key: string): void;

    /**
     * Called immediately after [playdate.update()](https://sdk.play.date/2.5.0#c-update), any drawing performed during this callback is overlaid on the display in 50% transparent red (or another color selected with [playdate.setDebugDrawColor()](https://sdk.play.date/2.5.0#f-setDebugDrawColor)).
     *
     * White pixels are drawn in the [debugDrawColor](https://sdk.play.date/2.5.0#f-setDebugDrawColor). Black pixels are transparent.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-debugDraw)
     *
     * @noSelf
     */
    export function debugDraw(): void;

    /**
     * If _flag_ is false, automatic garbage collection is disabled and the game should manually collect garbage with Lua’s `collectgarbage()` function.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-setCollectsGarbage)
     *
     * @noSelf
     */
    export function setCollectsGarbage(flag: boolean): void;

    /**
     * Force the Lua garbage collector to run for at least _ms_ milliseconds every frame, so that garbage doesn’t pile up and cause the game to run out of memory and stall in emergency garbage collection. The default value is 1 millisecond.
     *
     * Tip
     *
     * If your game isn’t generating a lot of garbage, it might be advantageous to set a smaller minimum GC time, granting more CPU bandwidth to your game.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-setMinimumGCTime)
     *
     * @noSelf
     */
    export function setMinimumGCTime(ms: number): void;

    /**
     * When the amount of used memory is less than `min` (scaled from 0-1, as a percentage of total system memory), the system will only run the collector for the minimum GC time, as set by [playdate.setGCScaling()](https://sdk.play.date/2.5.0#f-setGCScaling), every frame. If the used memory is more than `max`, the system will spend all free time running the collector. Between the two, the time used by the garbage collector is scaled proportionally.
     *
     * For example, if the scaling is set to a min of 0.4 and max of 0.7, and memory is half full, the collector will run for the minimum GC time plus 1/3 of whatever time is left before the next frame (because (0.5 - 0.4) / (0.7 - 0.4) = 1/3).
     *
     * The default behavior is a scaling of `(0.0, 1.0)`. If set to `(0.0, 0.0)`, the system will use all available extra time each frame running GC.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-setGCScaling)
     *
     * @noSelf
     */
    export function setGCScaling(min: number, max: number): void;

    /**
     * Called when a `msg <text>` command is received on the serial port. The text following the command is passed to the function as the string _message_.
     *
     * Running `!msg <message>` in the simulator Lua console sends the command to the device if one is connected, otherwise it sends it to the game running in the simulator.
     *
     * [Read more](https://sdk.play.date/2.5.0#c-serialMessageReceived)
     *
     * @noSelf
     */
    export function serialMessageReceived(message: string): void;

    /**
     * If the simulator is launched from the command line, any extra arguments passed there are available in the `playdate.argv` array.
     *
     * [Read more](https://sdk.play.date/2.5.0#v-argv)
     */
    let argv: unknown;
    /**
     * This variable—not a function, so don’t invoke with _()_—it is set to 1 when running inside of the Simulator and is _nil_ otherwise.
     *
     * [Read more](https://sdk.play.date/2.5.0#v-isSimulator)
     */
    let isSimulator: 1 | null;

    namespace menu {
        namespace item {}

        class item {
            /**
             * Sets the callback function for this menu item.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-menu.item.setCallback)
             */
            setCallback(callback: () => void): void;

            /**
             * Sets the title displayed for this menu item.
             *
             * The `title` for a menu item can also be set using dot syntax.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-menu.item.setTitle)
             */
            setTitle(newTitle: string): void;

            /**
             * Returns the title displayed for this menu item.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-menu.item.getTitle)
             */
            getTitle(): string;

            /**
             * Sets the value for this menu item. The value is of a different type depending on the type of menu item:
             *
             * *   normal: integer
             *
             * *   checkmark: boolean
             *
             * *   options: string
             *
             *
             * Values for any menu type can also be set using integers.
             *
             * The `value` for a menu item can also be set using dot syntax.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-menu.item.setValue)
             */
            setValue(newValue: number | boolean | string): void;

            /**
             * Returns the value for this menu item.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-menu.item.getValue)
             */
            getValue(): number | boolean | string;
        }
    }

    class menu {
        /**
         * _title_ will be the title displayed by the menu item.
         *
         * [Read more](https://sdk.play.date/2.5.0#m-menu.addMenuItem)
         */
        addMenuItem(
            title: string,
            callback: () => void
        ):
            | LuaMultiReturn<[playdate.menu.item, undefined]>
            | LuaMultiReturn<[null, string]>;

        /**
         * Creates a new menu item that can be checked or unchecked by the player.
         *
         * _title_ will be the title displayed by the menu item.
         *
         * _initialValue_ can be set to `true` or `false`, indicating the checked state of the menu item. Optional, defaults to `false`.
         *
         * If this menu item is interacted with while the system menu is open, _callback_ will be called when the menu is closed, before [playdate.gameWillResume](https://sdk.play.date/2.5.0#c-gameWillResume) is called. The callback function will be passed one argument, a boolean value, indicating the current value of the menu item.
         *
         * If the returned [playdate.menu.item](https://sdk.play.date/2.5.0#menu-item) is nil, a second `errorMessage` return value will indicate the reason the operation failed.
         *
         * Note
         *
         * Playdate OS allows a maximum of **three** custom menu items to be added to the System Menu.
         *
         * [Read more](https://sdk.play.date/2.5.0#m-menu.addCheckmarkMenuItem)
         */
        addCheckmarkMenuItem(
            title: string,
            initialValue?: boolean = false,
            callback: (value: boolean) => void
        ):
            | LuaMultiReturn<[playdate.menu.item, undefined]>
            | LuaMultiReturn<[null, string]>;

        /**
         * Creates a menu item that allows the player to cycle through a set of options.
         *
         * _title_ will be the title displayed by the menu item.
         *
         * _options_ should be an array-style table of strings representing the states the menu item can have. Due to limited horizontal space, the option strings and title should be kept short for this type of menu item.
         *
         * _initialValue_ can optionally be set to any of the values in the options array.
         *
         * If the value of this menu item is changed while the system menu is open, _callback_ will be called when the menu is closed, before [playdate.gameWillResume](https://sdk.play.date/2.5.0#c-gameWillResume) is called. The callback function will be passed one string argument indicating the currently selection option.
         *
         * If the returned [playdate.menu.item](https://sdk.play.date/2.5.0#menu-item) is nil, a second `errorMessage` return value will indicate the reason the operation failed.
         *
         * Note
         *
         * Playdate OS allows a maximum of **three** custom menu items to be added to the System Menu.
         *
         * [Read more](https://sdk.play.date/2.5.0#m-menu.addOptionsMenuItem)
         */
        addOptionsMenuItem<TOptions extends string[]>(
            title: string,
            options: TOptions,
            initalValue?: TOptions[number],
            callback: () => void
        ):
            | LuaMultiReturn<[playdate.menu.item, undefined]>
            | LuaMultiReturn<[null, string]>;

        /**
         *
         * [Read more](https://sdk.play.date/2.5.0#m-menu.getMenuItems)
         */
        getMenuItems(): playdate.menu.item[];

        /**
         * Removes the specified [playdate.menu.item](https://sdk.play.date/2.5.0#menu-item) from the menu.
         *
         * [Read more](https://sdk.play.date/2.5.0#m-menu.removeMenuItem)
         */
        removeMenuItem(menuItem: playdate.menu.item): void;

        /**
         * Removes from the referenced menu object all [playdate.menu.item](https://sdk.play.date/2.5.0#menu-item)s added by your game.
         *
         * Note
         *
         * Items that were added to the System Menu by the operating system cannot be removed by this operation, or any other.
         *
         * [Read more](https://sdk.play.date/2.5.0#m-menu.removeAllMenuItems)
         */
        removeAllMenuItems(): void;
    }

    namespace inputHandlers {
        /**
         * Pushes a new input handler onto the stack.
         *
         * *   _handler:_ A table containing one or more custom input functions.
         *
         * *   _masksPreviousHandlers:_ If true, input functions not defined in _handler_ will not be called. If missing or false, the previously-pushed input handler tables will be searched for input functions missing from _handler_, cascading down to the default `playdate` table.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-inputHandlers.push)
         *
         * @noSelf
         */
        export function push(
            handler: PlaydateInputHandler,
            masksPreviousHandlers?: boolean
        ): void;

        /**
         * Pops the last input handler off of the stack.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-inputHandlers.pop)
         *
         * @noSelf
         */
        export function pop(): void;
    }

    namespace display {
        /**
         * Sets the desired refresh rate in frames per second. The default is 30 fps, which is a recommended figure that balances animation smoothness with performance and power considerations. Maximum is 50 fps.
         *
         * If _rate_ is 0, [playdate.update()](https://sdk.play.date/2.5.0#c-update) is called as soon as possible. Since the display refreshes line-by-line, and unchanged lines aren’t sent to the display, the update cycle will be faster than 30 times a second but at an indeterminate rate. [playdate.getCurrentTimeMilliseconds()](https://sdk.play.date/2.5.0#f-getCurrentTimeMilliseconds) should then be used as a steady time base.
         *
         * Equivalent to [`playdate->display->setRefreshRate()`](./Inside%20Playdate%20with%20C.html#f-display.setRefreshRate) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-display.setRefreshRate)
         *
         * @noSelf
         */
        export function setRefreshRate(rate: number): void;

        /**
         * Returns the specified refresh rate in frames per second. See also [playdate.getFPS()](https://sdk.play.date/2.5.0#f-getFPS) for _measured, actual_ frame rate.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-display.getRefreshRate)
         *
         * @noSelf
         */
        export function getRefreshRate(): number;

        /**
         * Sends the contents of the frame buffer to the display immediately. Useful if you have called [playdate.stop()](https://sdk.play.date/2.5.0#f-stop) to disable update callbacks in, say, the case where your app updates the display only in reaction to button presses.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-display.flush)
         *
         * @noSelf
         */
        export function flush(): void;

        /**
         * Returns the height the Playdate display, taking the current display scale into account; e.g., if the scale is 2, the values returned will be based off of a 200 x 120-pixel screen rather than the native 400 x 240. (See [playdate.display.setScale()](https://sdk.play.date/2.5.0#f-display.setScale).)
         *
         * Equivalent to [`playdate->display->getHeight()`](./Inside%20Playdate%20with%20C.html#f-display.getHeight) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-display.getHeight)
         *
         * @noSelf
         */
        export function getHeight(): number;

        /**
         * Returns the width the Playdate display, taking the current display scale into account; e.g., if the scale is 2, the values returned will be based off of a 200 x 120-pixel screen rather than the native 400 x 240. (See [playdate.display.setScale()](https://sdk.play.date/2.5.0#f-display.setScale).)
         *
         * Equivalent to [`playdate->display->getWidth()`](./Inside%20Playdate%20with%20C.html#f-display.getWidth) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-display.getWidth)
         *
         * @noSelf
         */
        export function getWidth(): number;

        /**
         * Returns the values _(width, height)_ describing the Playdate display size. Takes the current display scale into account; e.g., if the scale is 2, the values returned will be based off of a 200 x 120-pixel screen rather than the native 400 x 240. (See [playdate.display.setScale()](https://sdk.play.date/2.5.0#f-display.setScale).)
         *
         * [Read more](https://sdk.play.date/2.5.0#f-display.getSize)
         *
         * @noSelf
         */
        export function getSize(): LuaMultiReturn<[number, number]>;

        /**
         * Returns the values _(x, y, width, height)_ describing the Playdate display size. Takes the current display scale into account; e.g., if the scale is 2, the values returned will be based off of a 200 x 120-pixel screen rather than the native 400 x 240. (See [playdate.display.setScale()](https://sdk.play.date/2.5.0#f-display.setScale).)
         *
         * [Read more](https://sdk.play.date/2.5.0#f-display.getRect)
         *
         * @noSelf
         */
        export function getRect(): LuaMultiReturn<
            [number, number, number, number]
        >;

        /**
         * Sets the display scale factor. Valid values for _scale_ are 1, 2, 4, and 8.
         *
         * The top-left corner of the frame buffer is scaled up to fill the display; e.g., if the scale is set to 4, the pixels in rectangle \[0,100\] x \[0,60\] are drawn on the screen as 4 x 4 squares.
         *
         * Equivalent to [`playdate->display->setScale()`](./Inside%20Playdate%20with%20C.html#f-display.setScale) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-display.setScale)
         *
         * @noSelf
         */
        export function setScale(scale: 1 | 2 | 4 | 8): void;

        /**
         * Gets the display scale factor. Valid values for _scale_ are 1, 2, 4, and 8.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-display.getScale)
         *
         * @noSelf
         */
        export function getScale(): 1 | 2 | 4 | 8;

        /**
         * If the argument passed to `setInverted()` is true, the frame buffer will be drawn inverted (everything onscreen that was black will now be white, etc.)
         *
         * Equivalent to [`playdate->display->setInverted()`](./Inside%20Playdate%20with%20C.html#f-display.setInverted) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-display.setInverted)
         *
         * @noSelf
         */
        export function setInverted(flag: boolean): void;

        /**
         * Returns the current value of the display invert flag.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-display.getInverted)
         *
         * @noSelf
         */
        export function getInverted(): boolean;

        /**
         * Adds a mosaic effect to the display. Valid _x_ and _y_ values are between 0 and 3, inclusive.
         *
         * Equivalent to [`playdate->display->setMosaic()`](./Inside%20Playdate%20with%20C.html#f-display.setMosaic) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-display.setMosaic)
         *
         * @noSelf
         */
        export function setMosaic(x: number, y: number): void;

        /**
         * Returns the current mosaic effect settings as multiple values (_x_, _y_).
         *
         * [Read more](https://sdk.play.date/2.5.0#f-display.getMosaic)
         *
         * @noSelf
         */
        export function getMosaic(): LuaMultiReturn<[number, number]>;

        /**
         * Offsets the entire display by _x_, _y_. Offset values can be negative. The "exposed" part of the display is black or white, according to the value set in [playdate.graphics.setBackgroundColor()](https://sdk.play.date/2.5.0#f-graphics.setBackgroundColor). This is an efficient way to make a "shake" effect without redrawing anything.
         *
         * Caution
         *
         * This function is different from [playdate.graphics.setDrawOffset()](https://sdk.play.date/2.5.0#f-graphics.setDrawOffset).
         *
         * Equivalent to [`playdate->display->setOffset()`](./Inside%20Playdate%20with%20C.html#f-display.setOffset) in the C API.
         *
         * Example: A screen shake effect using setOffset
         *
         *     -- You can copy and paste this example directly as your main.lua file to see it in action
         *     import "CoreLibs/graphics"
         *     import "CoreLibs/timer"
         *
         *     -- This function relies on the use of timers, so the timer core library
         *     -- must be imported, and updateTimers() must be called in the update loop
         *     local function screenShake(shakeTime, shakeMagnitude)
         *         -- Creating a value timer that goes from shakeMagnitude to 0, over
         *         -- the course of 'shakeTime' milliseconds
         *         local shakeTimer = playdate.timer.new(shakeTime, shakeMagnitude, 0)
         *         -- Every frame when the timer is active, we shake the screen
         *         shakeTimer.updateCallback = function(timer)
         *             -- Using the timer value, so the shaking magnitude
         *             -- gradually decreases over time
         *             local magnitude = math.floor(timer.value)
         *             local shakeX = math.random(-magnitude, magnitude)
         *             local shakeY = math.random(-magnitude, magnitude)
         *             playdate.display.setOffset(shakeX, shakeY)
         *         end
         *         -- Resetting the display offset at the end of the screen shake
         *         shakeTimer.timerEndedCallback = function()
         *             playdate.display.setOffset(0, 0)
         *         end
         *     end
         *
         *     function playdate.update()
         *         playdate.timer.updateTimers()
         *         if playdate.buttonJustPressed(playdate.kButtonA) then
         *             -- Shake the screen for 500ms, with the screen
         *             -- shaking around by about 5 pixels on each side
         *             screenShake(500, 5)
         *         end
         *
         *         -- A circle to be able to view what the shaking looks like
         *         playdate.graphics.fillCircleAtPoint(200, 120, 10)
         *     end
         *
         * [Read more](https://sdk.play.date/2.5.0#f-display.setOffset)
         *
         * @noSelf
         */
        export function setOffset(x: number, y: number): void;

        /**
         * `getOffset()` returns the current display offset as multiple values (_x_, _y_).
         *
         * [Read more](https://sdk.play.date/2.5.0#f-display.getOffset)
         *
         * @noSelf
         */
        export function getOffset(): LuaMultiReturn<[number, number]>;

        /**
         * Flips the display on the x or y axis, or both.
         *
         * Caution
         *
         * Function arguments are booleans, and in Lua `0` evaluates to `true`.
         *
         * Equivalent to [`playdate->display->setFlipped()`](./Inside%20Playdate%20with%20C.html#f-display.setFlipped) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-display.setFlipped)
         *
         * @noSelf
         */
        export function setFlipped(x: boolean, y: boolean): void;

        /**
         * The simplest method for putting an image on the display. Copies the contents of the image at _path_ directly to the frame buffer. The image must be 400x240 pixels with no transparency.
         *
         * Tip
         *
         * Loading an image via [playdate.graphics.image.new()](https://sdk.play.date/2.5.0#f-graphics.image.new-path) and drawing it at a desired coordinate with [playdate.graphics.image:draw()](https://sdk.play.date/2.5.0#m-graphics.imgDraw) offers more flexibility.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-display.loadImage)
         *
         * @noSelf
         */
        export function loadImage(path: string): void;
    }

    namespace easingFunctions {
        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function linear(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function inQuad(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function outQuad(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function inOutQuad(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function outInQuad(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function inCubic(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function outCubic(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function inOutCubic(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function outInCubic(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function inQuart(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function outQuart(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function inOutQuart(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function outInQuart(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function inQuint(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function outQuint(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function inOutQuint(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function outInQuint(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function inSine(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function outSine(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function inOutSine(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function outInSine(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function inExpo(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function outExpo(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function inOutExpo(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function outInExpo(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function inCirc(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function outCirc(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function inOutCirc(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function outInCirc(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function inElastic(
            t: number,
            b: number,
            c: number,
            d: number,
            a?: number,
            p?: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function outElastic(
            t: number,
            b: number,
            c: number,
            d: number,
            a?: number,
            p?: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function inOutElastic(
            t: number,
            b: number,
            c: number,
            d: number,
            a?: number,
            p?: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function outInElastic(
            t: number,
            b: number,
            c: number,
            d: number,
            a?: number,
            p?: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function inBack(
            t: number,
            b: number,
            c: number,
            d: number,
            s?: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function outBack(
            t: number,
            b: number,
            c: number,
            d: number,
            s?: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function inOutBack(
            t: number,
            b: number,
            c: number,
            d: number,
            s?: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function outInBack(
            t: number,
            b: number,
            c: number,
            d: number,
            s?: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function outBounce(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function inBounce(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function inOutBounce(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;

        /**
         * *   _t_ is elapsed time
         *
         * *   _b_ is the beginning value
         *
         * *   _c_ is the change (or end value - start value)
         *
         * *   _d_ is the duration
         *
         * *   _a_ - amplitude
         *
         * *   _p_ - period parameter
         *
         * *   _s_ - amount of "overshoot"
         *
         * [Read more](https://sdk.play.date/2.5.0#f-easingFunctions)
         *
         * @noSelf
         */
        export function outInBounce(
            t: number,
            b: number,
            c: number,
            d: number
        ): void;
    }

    namespace datastore {
        /**
         * Encodes the given table into the named file. (The `.json` extension should be omitted from the file name.) The default file name is "data". If _pretty-print_ is true, the JSON will be nicely formatted.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-datastore.write)
         *
         * @noSelf
         */
        export function write(
            table: AnyTable,
            filename?: string,
            prettyPrint?: boolean
        ): void;

        /**
         * Returns a table instantiated with the data in the JSON-encoded file you specify. (The `.json` extension should be omitted.) The default file name is "data". If no file is found, this function returns nil.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-datastore.read)
         *
         * @noSelf
         */
        export function read(filename?: string): AnyTable | null;

        /**
         * Deletes the specified datastore file. The default file name is "data". Returns `false` if the datastore file could not be deleted.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-datastore.delete)
         *
         * @noSelf
         */
        export function _delete(filename?: string): boolean;

        export { _delete as delete };

        /**
         * Saves a [playdate.graphics.image](https://sdk.play.date/2.5.0#C-graphics.image) to a file. If _path_ doesn’t contain a folder name, the image is stored in a folder named "images".
         *
         * By default, this method writes out a PDI file, a custom image format used by Playdate that can be read back in using [readImage()](https://sdk.play.date/2.5.0#f-datastore.readImage). If you want to write out a GIF file, append a `.gif` extension to your _path_.
         *
         * Important
         *
         * Because `writeImage()` doesn’t currently support GIF transparency, if you attempt to write a GIF from an image buffer you instantiated, you must call [playdate.graphics.image.new( _width, height, bgcolor_ )](https://sdk.play.date/2.5.0#f-graphics.image.new) with _bgcolor_ set to `playdate.graphics.kColorWhite` or `playdate.graphics.kColorBlack`, otherwise your image will render improperly to the file.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-datastore.writeImage)
         *
         * @noSelf
         */
        export function writeImage(
            image: playdate.graphics.image,
            path: string
        ): void;

        /**
         * Reads a [playdate.graphics.image](https://sdk.play.date/2.5.0#C-graphics.image) from a file in the data folder. If _path_ doesn’t contain a folder name, the image is searched for in a folder named "images".
         *
         * Important
         *
         * `readImage()` can only load compiled pdi files. ([`writeImage()`](https://sdk.play.date/2.5.0#f-datastore.writeImage) by default creates compiled pdi files.)
         *
         * [Read more](https://sdk.play.date/2.5.0#f-datastore.readImage)
         *
         * @noSelf
         */
        export function readImage(path: string): playdate.graphics.image;
    }

    namespace file {
        /**
         * Returns a [playdate.file.file](https://sdk.play.date/2.5.0#M-file) corresponding to the opened file. _mode_ should be one of the following:
         *
         * *   **playdate.file.kFileRead**: the file is opened for reading; the system first looks in the /Data/<bundleid> folder for the given file, then in the game’s pdx folder if it isn’t found
         *
         * *   **playdate.file.kFileWrite**: the file is created if it doesn’t exist, truncated to zero length if it does, then opened for writing
         *
         * *   **playdate.file.kFileAppend**: the file is created if it doesn’t exist, opened for writing, with new data written to the end of the file
         *
         *
         * If _mode_ is not specified, the default is _playdate.file.kFileRead_.
         *
         * If the file couldn’t be opened, a second return value indicates the error. The filesystem has a limit of 64 simultaneous open files.
         *
         * Equivalent to [`playdate->file->open()`](./Inside%20Playdate%20with%20C.html#f-file.open) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-file.open)
         *
         * @noSelf
         */
        export function open(
            path: string,
            mode?: PlaydateFileOpenMode = PlaydateFileOpenMode.Read
        ): playdate.file.file;

        /**
         * Returns an array containing the file names in the given directory path as strings. Folders are indicated by a slash `/` at the end of the filename. If _showhidden_ is set, files beginning with a period will be included; otherwise, they are skipped.
         *
         * Call with no argument to get a list of all files and folders your game has access to. (For a game with default access permissions, `listFiles()`, `listFiles("/")`, and `listFiles(".")` should all return the same result.)
         *
         * Equivalent to [`playdate->file->listfiles()`](./Inside%20Playdate%20with%20C.html#f-file.listfiles) in the C API.
         *
         * [Learn more about the Playdate filesystem](https://sdk.play.date/2.5.0#about-playdate-filesystem).
         *
         * [Read more](https://sdk.play.date/2.5.0#f-file.listFiles)
         *
         * @noSelf
         */
        export function listFiles(path: string, showhidden?: boolean): string[];

        /**
         * Returns true if a file exists at the given path. Unlike the [image](https://sdk.play.date/2.5.0#f-graphics.image.new-path) or [sound](https://sdk.play.date/2.5.0#f-sound.sample.new-path) loading functions, this function requires _path_ to include the file extension since it cannot be inferred from context. Additionally, note that asset files are compiled into a format easier for Playdate to use and will have a different extension: `.wav` and `.aiff` audio files are compiled to `.pda` format, and `.gif` and `.png` files become \`.pdi\`s.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-file.exists)
         *
         * @noSelf
         */
        export function exists(path: string): boolean;

        /**
         * Returns true if a directory exists at the given path.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-file.isdir)
         *
         * @noSelf
         */
        export function isdir(path: string): boolean;

        /**
         * Creates a directory at the given path, under the /Data/<bundleid> folder. See [About the Playdate Filesystem](https://sdk.play.date/2.5.0#about-playdate-filesystem) for details.
         *
         * `playdate.file.mkdir()` will create all intermediate directories, if a succession of directories ("testdir/testdir/testdir/") is specified in _path_.
         *
         * Equivalent to [`playdate->file->mkdir()`](./Inside%20Playdate%20with%20C.html#f-file.mkdir) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-file.mkdir)
         *
         * @noSelf
         */
        export function mkdir(path: string): void;

        /**
         * Deletes the file at the given path. Returns true if successful, else false.
         *
         * If _recursive_ is `true`, this function will delete the directory at _path_ and its contents, otherwise the directory must be empty to be deleted.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-file.delete)
         *
         * @noSelf
         */
        export function _delete(path: string, recursive?: boolean): boolean;

        export { _delete as delete };

        /**
         * Returns the size of the file at the given path.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-file.getSize)
         *
         * @noSelf
         */
        export function getSize(path: string): number;

        /**
         * Returns the type of the file at the given path.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-file.getType)
         *
         * @noSelf
         */
        export function getType(path: string): number;

        /**
         * Returns the modification date/time of the file at the given path, as a table with keys:
         *
         * *   _year_: 4-digit year (until 10,000 AD)
         *
         * *   _month_: month of the year, where 1 is January and 12 is December
         *
         * *   _day_: day of the month, 1 - 31
         *
         * *   _hour_: 0 - 23
         *
         * *   _minute_: 0 - 59
         *
         * *   _second_: 0 - 59 (or 60 on a leap second)
         *
         * [Read more](https://sdk.play.date/2.5.0#f-file.modtime)
         *
         * @noSelf
         */
        export function modtime(path: string): {
            year: number;
            month: number;
            day: number;
            hour: number;
            minute: number;
            second: number;
        };

        /**
         * Renames the file at _path_, if it exists, to the value of newPath. This can result in the file being moved to a new directory, but directories will not be created. Returns true if the operation was successful.
         *
         * Equivalent to [`playdate->file->rename()`](./Inside%20Playdate%20with%20C.html#f-file.rename) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-file.rename)
         *
         * @noSelf
         */
        export function rename(path: string, newPath: string): boolean;

        /**
         * Loads the compiled _.pdz_ file at the given location and returns the contents as a function. The .pdz extension on _path_ is optional.
         *
         * _env_, if specified, is a table to use as the function’s global namespace instead of _\_G_.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-file.load)
         *
         * @noSelf
         */
        export function load(path: string, env?: AnyTable): void;

        /**
         * Runs the pdz file at the given location. Equivalent to `playdate.file.load(path, env)()`.
         *
         * The _.pdz_ extension on _path_ is optional. Values returned from the pdz file are left on the stack.
         *
         * _env_, if specified, is a table to use as the function’s global namespace instead of _\_G_.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-file.run)
         *
         * @noSelf
         */
        export function run(path: string, env?: AnyTable): void;

        namespace file {}

        class file {
            /**
             * Closes the file.
             *
             * Equivalent to [`playdate->file->close()`](./Inside%20Playdate%20with%20C.html#f-file.close) in the C API.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-file.close)
             */
            close(): void;

            /**
             * Writes the given string to the file and returns the number of bytes written if successful, or 0 and a second return value describing the error. If you wish to include line termination characters (`\n`, `\r`), please include them in the string.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-file.write)
             */
            write(
                string: string
            ):
                | LuaMultiReturn<[number, undefined]>
                | LuaMultiReturn<[0, string]>;

            /**
             * Flushes any buffered data written to the file to the disk.
             *
             * Equivalent to [`playdate->file->flush()`](./Inside%20Playdate%20with%20C.html#f-file.flush) in the C API.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-file.flush)
             */
            flush(): void;

            /**
             * Returns the next line of the file, delimited by either `\n` or `\r\n`. The returned string does not include newline characters.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-file.readline)
             */
            readline(): string;

            /**
             * Returns a buffer containing up to _numberOfBytes_ bytes from the file, and the number of bytes read. If the read failed, the function returns `nil` and a second value describing the error.
             *
             * Equivalent to [`playdate->file->read()`](./Inside%20Playdate%20with%20C.html#f-file.read) in the C API.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-file.read)
             */
            read(
                numberOfBytes: number
            ):
                | LuaMultiReturn<[string, number]>
                | LuaMultiReturn<[null, string]>;

            /**
             * Sets the file read/write position to the given byte offset.
             *
             * Equivalent to [`playdate->file->seek()`](./Inside%20Playdate%20with%20C.html#f-file.seek) in the C API.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-file.seek)
             */
            seek(offset: number): void;

            /**
             * Returns the current byte offset of the read/write position in the file.
             *
             * Equivalent to [`playdate->file->tell()`](./Inside%20Playdate%20with%20C.html#f-file.tell) in the C API.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-file.tell)
             */
            tell(): number;
        }
    }

    namespace geometry {
        /**
         * Returns the square of the distance from point _(x1, y1)_ to point _(x2, y2)_.
         *
         * Compared to [geometry.point:squaredDistanceToPoint()](https://sdk.play.date/2.5.0#m-geometry.point.squaredDistanceToPoint), this version will be slightly faster.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-geometry.squaredDistanceToPoint)
         *
         * @noSelf
         */
        export function squaredDistanceToPoint(
            x1: number,
            y1: number,
            x2: number,
            y2: number
        ): number;

        /**
         * Returns the the distance from point _(x1, y1)_ to point _(x2, y2)_.
         *
         * Compared to [geometry.point:distanceToPoint()](https://sdk.play.date/2.5.0#m-geometry.point.distanceToPoint), this version will be slightly faster.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-geometry.distanceToPoint)
         *
         * @noSelf
         */
        export function distanceToPoint(
            x1: number,
            y1: number,
            x2: number,
            y2: number
        ): number;

        namespace affineTransform {
            /**
             * Returns a new playdate.geometry.affineTransform. Use new() instead to get a new copy of the identity transform.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-geometry.affineTransform.new)
             *
             * @noSelf
             */
            export function _new(
                m11: number,
                m12: number,
                m21: number,
                m22: number,
                tx: number,
                ty: number
            ): playdate.geometry.affineTransformTransform;

            export { _new as new };

            /**
             * Returns a new playdate.geometry.affineTransform that is the identity transform.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-geometry.affineTransform.new-1)
             *
             * @noSelf
             */
            export function _new(): playdate.geometry.affineTransformTransform;

            export { _new as new };
        }

        class affineTransform {
            /**
             * Returns a new copy of the affine transform.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.copy)
             */
            copy(): playdate.geometry.affineTransformTransform;

            /**
             * Mutates the caller so that it is an affine transformation matrix constructed by inverting itself.
             *
             * Inversion is generally used to provide reverse transformation of points within transformed objects. Given the coordinates (x, y), which have been transformed by a given matrix to new coordinates (x’, y’), transforming the coordinates (x’, y’) by the inverse matrix produces the original coordinates (x, y).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.invert)
             */
            invert(): void;

            /**
             * Mutates the the caller, changing it to an identity transform matrix.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.reset)
             */
            reset(): void;

            /**
             * Mutates the the caller. The affine transform _af_ is concatenated to the caller.
             *
             * Concatenation combines two affine transformation matrices by multiplying them together. You might perform several concatenations in order to create a single affine transform that contains the cumulative effects of several transformations.
             *
             * Note that matrix operations are not commutative — the order in which you concatenate matrices is important. That is, the result of multiplying matrix t1 by matrix t2 does not necessarily equal the result of multiplying matrix t2 by matrix t1.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.concat)
             */
            concat(af: playdate.geometry.affineTransformTransform): void;

            /**
             * Mutates the caller by applying a translate transformation. x values are moved by _dx_, y values by _dy_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.translate)
             */
            translate(dx: number, dy: number): void;

            /**
             * Returns a copy of the calling affine transform with a translate transformation appended.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.translatedBy)
             */
            translatedBy(
                dx: number,
                dy: number
            ): playdate.geometry.affineTransformTransform;

            /**
             * Mutates the caller by applying a scaling transformation.
             *
             * If both parameters are passed, _sx_ is used to scale the x values of the transform, _sy_ is used to scale the y values.
             *
             * If only one parameter is passed, it is used to scale both x and y values.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.scale)
             */
            scale(sx: number, sy?: number): void;

            /**
             * Returns a copy of the calling affine transform with a scaling transformation appended.
             *
             * If both parameters are passed, _sx_ is used to scale the x values of the transform, _sy_ is used to scale the y values.
             *
             * If only one parameter is passed, it is used to scale both x and y values.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.scaledBy)
             */
            scaledBy(
                sx: number,
                sy?: number
            ): playdate.geometry.affineTransformTransform;

            /**
             * Mutates the caller by applying a rotation transformation.
             *
             * _angle_ is the value, in degrees, by which to rotate the affine transform. A positive value specifies clockwise rotation and a negative value specifies counterclockwise rotation. If the optional _x_ and _y_ arguments are given, the transform rotates around (_x_,_y_) instead of (0,0).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.rotate)
             */
            rotate(angle: number, x?: number, y?: number): void;
            /**
             * Mutates the caller by applying a rotation transformation.
             *
             * _angle_ is the value, in degrees, by which to rotate the affine transform. A positive value specifies clockwise rotation and a negative value specifies counterclockwise rotation. If the optional [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point) _point_ argument is given, the transform rotates around the _point_ instead of (0,0).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform:rotate-point)
             */
            rotate(angle: number, point?: playdate.geometry.point): void;

            /**
             * Returns a copy of the calling affine transform with a rotate transformation appended.
             *
             * _angle_ is the value, in degrees, by which to rotate the affine transform. A positive value specifies clockwise rotation and a negative value specifies counterclockwise rotation. If the optional _x_ and _y_ arguments are given, the transform rotates around (_x_,_y_) instead of (0,0).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.rotatedBy)
             */
            rotatedBy(
                angle: number,
                x?: number,
                y?: number
            ): playdate.geometry.affineTransformTransform;
            /**
             * Returns a copy of the calling affine transform with a rotate transformation appended.
             *
             * _angle_ is the value, in degrees, by which to rotate the affine transform. A positive value specifies clockwise rotation and a negative value specifies counterclockwise rotation. If the optional [point](https://sdk.play.date/2.5.0#C-geometry.point) _point_ argument is given, the transform rotates around the _point_ instead of (0,0).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform:rotatedBy-point)
             */
            rotatedBy(
                angle: number,
                point?: playdate.geometry.point
            ): playdate.geometry.affineTransformTransform;

            /**
             * Mutates the caller, appending a skew transformation. _sx_ is the value by which to skew the x axis, and _sy_ the value for the y axis. Values are in degrees.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.skew)
             */
            skew(sx: number, sy: number): void;

            /**
             * Returns the given transform with a skew transformation appended. _sx_ is the value by which to skew the x axis, and _sy_ the value for the y axis. Values are in degrees.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.skewedBy)
             */
            skewedBy(
                sx: number,
                sy: number
            ): playdate.geometry.affineTransformTransform;

            /**
             * Modifies the [point](https://sdk.play.date/2.5.0#C-geometry.point) _p_ by applying the affine transform.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.transformPoint)
             */
            transformPoint(p: playdate.geometry.point): void;

            /**
             * As above, but returns a new point rather than modifying _p_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.transformedPoint)
             */
            transformedPoint(
                p: playdate.geometry.point
            ): playdate.geometry.point;

            /**
             * Returns two values calculated by applying the affine transform to the point (_x_, _y_)
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.transformXY)
             */
            transformXY(x: number, y: number): LuaMultiReturn<[number, number]>;

            /**
             * Modifies the [line segment](https://sdk.play.date/2.5.0#C-geometry.lineSegment) _ls_ by applying the affine transform.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.transformLineSegment)
             */
            transformLineSegment(ls: playdate.geometry.lineSegmentnt): void;

            /**
             * As above, but returns a new [line segment](https://sdk.play.date/2.5.0#C-geometry.lineSegment) rather than modifying _ls_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.transformedLineSegment)
             */
            transformedLineSegment(
                ls: playdate.geometry.lineSegmentnt
            ): playdate.geometry.lineSegmentnt;

            /**
             * Modifies the axis aligned bounding box _r_ (a [rect](https://sdk.play.date/2.5.0#C-geometry.rect)) by applying the affine transform.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.transformAABB)
             */
            transformAABB(r: playdate.geometry.rect): void;

            /**
             * As above, but returns a new [rect](https://sdk.play.date/2.5.0#C-geometry.rect) rather than modifying _r_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.transformedAABB)
             */
            transformedAABB(r: playdate.geometry.rect): playdate.geometry.rect;

            /**
             * Modifies the [polygon](https://sdk.play.date/2.5.0#C-geometry.polygon) _p_ by applying the affine transform.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.transformPolygon)
             */
            transformPolygon(p: playdate.geometry.polygon): void;

            /**
             * As above, but returns a new [polygon](https://sdk.play.date/2.5.0#C-geometry.polygon) rather than modifying _p_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.affineTransform.transformedPolygon)
             */
            transformedPolygon(
                p: playdate.geometry.polygon
            ): playdate.geometry.polygon;
        }

        namespace arc {
            /**
             * Returns a new playdate.geometry.arc. Angles should be specified in degrees. Zero degrees represents the top of the circle.
             *
             * ![unitcircle](Inside%20Playdate/unitcircle.png)
             *
             * If specified, _direction_ should be true for clockwise, false for counterclockwise. If not specified, the direction is inferred from the start and end angles.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-geometry.arc.new)
             *
             * @noSelf
             */
            export function _new(
                x: number,
                y: number,
                radius: number,
                startAngle: number,
                endAngle: number,
                direction?: boolean
            ): playdate.geometry.arc;

            export { _new as new };
        }

        class arc {
            /**
             * Returns a new copy of the arc.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.arc.copy)
             */
            copy(): playdate.geometry.arc;

            /**
             * Returns the length of the arc.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.arc.length)
             */
            length(): number;

            /**
             * Returns true if the direction of the arc is clockwise.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.arc.isClockwise)
             */
            isClockwise(): boolean;

            /**
             * Sets the direction of the arc.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.arc.setIsClockwise)
             */
            setIsClockwise(flag: boolean): void;

            /**
             * Returns a new [point](https://sdk.play.date/2.5.0#C-geometry.point) on the arc, `distance` pixels from the arc’s start angle. If `extend` is true, the returned point is allowed to project past the arc’s endpoints; otherwise, it is constrained to the arc’s initial point if `distance` is negative, or the end point if `distance` is greater than the arc’s length.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.arc.pointOnArc)
             */
            pointOnArc(
                distance: number,
                extend?: boolean
            ): playdate.geometry.point;
        }

        namespace lineSegment {
            /**
             * Returns a new playdate.geometry.lineSegment.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-geometry.lineSegment.new)
             *
             * @noSelf
             */
            export function _new(
                x1: number,
                y1: number,
                x2: number,
                y2: number
            ): playdate.geometry.lineSegmentnt;

            export { _new as new };

            /**
             * For use in inner loops where speed is the priority.
             *
             * Returns true if there is an intersection between the line segments defined by _(x1, y1)_, _(x2, y2)_ and _(x3, y3)_, _(x4, y4)_. If there is an intersection, _x, y_ values representing the intersection point are also returned.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.lineSegment.fast_intersection)
             *
             * @noSelf
             */
            export function fast_intersection(
                x1: number,
                y1: number,
                x2: number,
                y2: number,
                x3: number,
                y3: number,
                x4: number,
                y4: number
            ): LuaMultiReturn<[boolean, number]>;
        }

        class lineSegment {
            /**
             * Returns a new copy of the line segment.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.lineSegment.copy)
             */
            copy(): playdate.geometry.lineSegmentnt;

            /**
             * Returns the values _x1, y1, x2, y2_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.lineSegment.unpack)
             */
            unpack(): LuaMultiReturn<[number, number, number, number]>;

            /**
             * Returns the length of the line segment.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.lineSegment.length)
             */
            length(): number;

            /**
             * Modifies the line segment, offsetting its values by _dx_, _dy_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.lineSegment.offset)
             */
            offset(dx: number, dy: number): void;

            /**
             * Returns a new line segment, the given segment offset by _dx_, _dy_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.lineSegment.offsetBy)
             */
            offsetBy(dx: number, dy: number): playdate.geometry.lineSegmentnt;

            /**
             * Returns a [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point) representing the mid point of the line segment.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.lineSegment.midPoint)
             */
            midPoint(): playdate.geometry.point;

            /**
             * Returns a [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point) on the line segment, `distance` pixels from the start of the line. If `extend` is true, the returned point is allowed to project past the segment’s endpoints; otherwise, it is constrained to the line segment’s initial point if `distance` is negative, or the end point if `distance` is greater than the segment’s length.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.lineSegment.pointOnLine)
             */
            pointOnLine(
                distance: number,
                extend?: boolean
            ): playdate.geometry.point;

            /**
             * Returns a [playdate.geometry.vector2D](https://sdk.play.date/2.5.0#C-geometry.vector2D) representation of the line segment.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.lineSegment.segmentVector)
             */
            segmentVector(): playdate.geometry.vector2D;

            /**
             * Returns a [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point) that is the closest point to point _p_ that is on the line segment.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.lineSegment.closestPointOnLineToPoint)
             */
            closestPointOnLineToPoint(
                p: playdate.geometry.point
            ): playdate.geometry.point;

            /**
             * Returns true if there is an intersection between the caller and the line segment _ls_.
             *
             * If there is an intersection, a [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point) representing that point is also returned.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.lineSegment.intersectsLineSegment)
             */
            intersectsLineSegment(
                ls: playdate.geometry.lineSegmentnt
            ):
                | LuaMultiReturn<[false, undefined]>
                | LuaMultiReturn<[true, playdate.geometry.point]>;

            /**
             * Returns the values (_intersects_, _intersectionPoints_).
             *
             * _intersects_ is true if there is at least one intersection between the caller and [poly](https://sdk.play.date/2.5.0#C-geometry.polygon).
             *
             * _intersectionPoints_ is an array of [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point)s containing all intersection points between the caller and [poly](https://sdk.play.date/2.5.0#C-geometry.polygon).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.lineSegment.intersectsPolygon)
             */
            intersectsPolygon(
                poly: playdate.geometry.polygon
            ): LuaMultiReturn<[boolean, number]>;

            /**
             * Returns the values (_intersects_, _intersectionPoints_).
             *
             * _intersects_ is true if there is at least one intersection between the caller and [rect](https://sdk.play.date/2.5.0#C-geometry.rect).
             *
             * _intersectionPoints_ is an array of [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point)s containing all intersection points between the caller and [rect](https://sdk.play.date/2.5.0#C-geometry.rect).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.lineSegment.intersectsRect)
             */
            intersectsRect(
                rect: playdate.geometry.rect
            ): LuaMultiReturn<[boolean, number]>;
        }

        namespace point {
            /**
             * Returns a new playdate.geometry.point.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-geometry.point.new)
             *
             * @noSelf
             */
            export function _new(x: number, y: number): playdate.geometry.point;

            export { _new as new };
        }

        class point {
            /**
             * Returns a new copy of the point.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.point.copy)
             */
            copy(): playdate.geometry.point;

            /**
             * Returns the values _x, y_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.point.unpack)
             */
            unpack(): LuaMultiReturn<[number, number]>;

            /**
             * Modifies the point, offsetting its values by _dx_, _dy_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.point.offset)
             */
            offset(dx: number, dy: number): void;

            /**
             * Returns a new point object, the given point offset by _dx_, _dy_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.point.offsetBy)
             */
            offsetBy(dx: number, dy: number): playdate.geometry.point;

            /**
             * Returns the square of the distance to point _p_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.point.squaredDistanceToPoint)
             */
            squaredDistanceToPoint(p: playdate.geometry.point): number;

            /**
             * Returns the distance to point _p_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.point.distanceToPoint)
             */
            distanceToPoint(p: playdate.geometry.point): number;
        }

        namespace polygon {
            /**
             * `new(x1, y1, x2, y2, ..., xn, yn)` returns a new playdate.geometry.polygon with vertices _(x1, y1)_ through _(xn, yn)_. The Lua function `table.unpack()` can be used to turn an array into function arguments.
             *
             * `new(p1, p2, ..., pn)` does the same, except the points are expressed via [point objects](https://sdk.play.date/2.5.0#C-geometry.point).
             *
             * `new(numberOfVertices)` returns a new playdate.geometry.polygon with space allocated for _numberOfVertices_ vertices. All vertices are initially (0, 0). Vertex coordinates can be set with [playdate.geometry.polygon:setPointAt()](https://sdk.play.date/2.5.0#m-geometry.polygon.setPointAt).
             *
             * Note
             *
             * If the polygon’s first and last points are coincident, the polygon will be considered [closed](https://sdk.play.date/2.5.0#m-geometry.polygon.isClosed). Alternatively, you may call [:close()](https://sdk.play.date/2.5.0#m-geometry.polygon.close) to automatically close the polygon.
             *
             * Tip
             *
             * To draw a polygon, use [`playdate.graphics.drawPolygon()`](https://sdk.play.date/2.5.0#f-graphics.drawPolygon).
             *
             * [Read more](https://sdk.play.date/2.5.0#f-geometry.polygon.new)
             *
             * @noSelf
             */
            export function _new(
                ...coordinates: number
            ): playdate.geometry.polygon;

            export { _new as new };

            /**
             * `new(x1, y1, x2, y2, ..., xn, yn)` returns a new playdate.geometry.polygon with vertices _(x1, y1)_ through _(xn, yn)_. The Lua function `table.unpack()` can be used to turn an array into function arguments.
             *
             * `new(p1, p2, ..., pn)` does the same, except the points are expressed via [point objects](https://sdk.play.date/2.5.0#C-geometry.point).
             *
             * `new(numberOfVertices)` returns a new playdate.geometry.polygon with space allocated for _numberOfVertices_ vertices. All vertices are initially (0, 0). Vertex coordinates can be set with [playdate.geometry.polygon:setPointAt()](https://sdk.play.date/2.5.0#m-geometry.polygon.setPointAt).
             *
             * Note
             *
             * If the polygon’s first and last points are coincident, the polygon will be considered [closed](https://sdk.play.date/2.5.0#m-geometry.polygon.isClosed). Alternatively, you may call [:close()](https://sdk.play.date/2.5.0#m-geometry.polygon.close) to automatically close the polygon.
             *
             * Tip
             *
             * To draw a polygon, use [`playdate.graphics.drawPolygon()`](https://sdk.play.date/2.5.0#f-graphics.drawPolygon).
             *
             * [Read more](https://sdk.play.date/2.5.0#f-geometry.polygon.new)
             *
             * @noSelf
             */
            export function _new(
                ...points: playdate.geometry.point
            ): playdate.geometry.polygon;

            export { _new as new };

            /**
             * `new(x1, y1, x2, y2, ..., xn, yn)` returns a new playdate.geometry.polygon with vertices _(x1, y1)_ through _(xn, yn)_. The Lua function `table.unpack()` can be used to turn an array into function arguments.
             *
             * `new(p1, p2, ..., pn)` does the same, except the points are expressed via [point objects](https://sdk.play.date/2.5.0#C-geometry.point).
             *
             * `new(numberOfVertices)` returns a new playdate.geometry.polygon with space allocated for _numberOfVertices_ vertices. All vertices are initially (0, 0). Vertex coordinates can be set with [playdate.geometry.polygon:setPointAt()](https://sdk.play.date/2.5.0#m-geometry.polygon.setPointAt).
             *
             * Note
             *
             * If the polygon’s first and last points are coincident, the polygon will be considered [closed](https://sdk.play.date/2.5.0#m-geometry.polygon.isClosed). Alternatively, you may call [:close()](https://sdk.play.date/2.5.0#m-geometry.polygon.close) to automatically close the polygon.
             *
             * Tip
             *
             * To draw a polygon, use [`playdate.graphics.drawPolygon()`](https://sdk.play.date/2.5.0#f-graphics.drawPolygon).
             *
             * [Read more](https://sdk.play.date/2.5.0#f-geometry.polygon.new)
             *
             * @noSelf
             */
            export function _new(
                numberOfVertices: number
            ): playdate.geometry.polygon;

            export { _new as new };
        }

        class polygon {
            /**
             * Returns a copy of a polygon.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.polygon.copy)
             */
            copy(): playdate.geometry.polygon;

            /**
             * `:close()` closes a polygon. If the polygon’s first and last point aren’t coincident, a line segment will be generated to connect them.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.polygon.close)
             */
            close(): void;

            /**
             * Returns true if the polygon is closed, false if not.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.polygon.isClosed)
             */
            isClosed(): boolean;

            /**
             * Returns a boolean value, true if the [point](https://sdk.play.date/2.5.0#C-geometry.point) _p_ or the point at _(x, y)_ is contained within the caller polygon.
             *
             * `fillrule` is an optional argument that can be one of the values defined in [playdate.graphics.setPolygonFillRule](https://sdk.play.date/2.5.0#f-graphics.setPolygonFillRule). By default `_playdate.graphics.kPolygonFillEvenOdd_` is used.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.polygon.containsPoint)
             */
            containsPoint(
                p: playdate.geometry.point,
                fillRule?: PlaydatePolygonFill = PlaydatePolygonFill.EvenOdd
            ): boolean;
            /**
             * Returns a boolean value, true if the [point](https://sdk.play.date/2.5.0#C-geometry.point) _p_ or the point at _(x, y)_ is contained within the caller polygon.
             *
             * `fillrule` is an optional argument that can be one of the values defined in [playdate.graphics.setPolygonFillRule](https://sdk.play.date/2.5.0#f-graphics.setPolygonFillRule). By default `_playdate.graphics.kPolygonFillEvenOdd_` is used.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.polygon.containsPoint)
             */
            containsPoint(
                x: number,
                y: number,
                fillRule?: PlaydatePolygonFill = PlaydatePolygonFill.EvenOdd
            ): boolean;

            /**
             * Returns multiple values (_x_, _y_, _width_, _height_) giving the axis-aligned bounding box for the polygon.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.polygon.getBounds)
             */
            getBounds(): LuaMultiReturn<[number, number, number, number]>;

            /**
             * Returns the axis-aligned bounding box for the given polygon as a [`playdate.geometry.rect`](https://sdk.play.date/2.5.0#C-geometry.rect) object.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.polygon.getBoundsRect)
             */
            getBoundsRect(): playdate.geometry.rect;

            /**
             * Returns the number of points in the polygon.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.polygon.count)
             */
            count(): number;

            /**
             * Returns the total length of all line segments in the polygon.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.polygon.length)
             */
            length(): number;

            /**
             * Sets the polygon’s _n_\-th point to (_x_, _y_).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.polygon.setPointAt)
             */
            setPointAt(n: number, x: number, y: number): void;

            /**
             * Returns the polygon’s _n_\-th point.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.polygon.getPointAt)
             */
            getPointAt(n: number): playdate.geometry.point;

            /**
             * Returns true if the given polygon intersects the polygon _p_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.polygon.intersects)
             */
            intersects(p: playdate.geometry.polygon): boolean;

            /**
             * Returns a [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point) on one of the polygon’s line segments, `distance` pixels from the start of the polygon. If `extend` is true, the point is allowed to project past the polygon’s ends; otherwise, it is constrained to the polygon’s initial point if `distance` is negative, or the last point if `distance` is greater than the polygon’s length.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.polygon.pointOnPolygon)
             */
            pointOnPolygon(
                distance: number,
                extend?: boolean
            ): playdate.geometry.point;

            /**
             * Translates each point on the polygon by _dx_, _dy_ pixels.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.polygon.translate)
             */
            translate(dx: number, dy: number): void;
        }

        namespace rect {
            /**
             * Returns a new playdate.geometry.rect.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-geometry.rect.new)
             *
             * @noSelf
             */
            export function _new(
                x: number,
                y: number,
                width: number,
                height: number
            ): playdate.geometry.rect;

            export { _new as new };

            /**
             * For use in inner loops where speed is the priority. About 3x faster than [intersection](https://sdk.play.date/2.5.0#m-geometry.rect.intersection).
             *
             * Returns multiple values (_x, y, width, height_) representing the overlapping portion of the two rects defined by _x1, y1, w1, h1_ and _x2, y2, w2, h2_. If there is no intersection, (0, 0, 0, 0) is returned.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-geometry.rect.fast_intersection)
             *
             * @noSelf
             */
            export function fast_intersection(
                x1: number,
                y1: number,
                w1: number,
                h1: number,
                x2: number,
                y2: number,
                w2: number,
                h2: number
            ):
                | LuaMultiReturn<[number, number, number, number]>
                | [number, number, number, number][];

            /**
             * For use in inner loops where speed is the priority. About 3x faster than [union](https://sdk.play.date/2.5.0#m-geometry.rect.union).
             *
             * Returns multiple values (_x, y, width, height_) representing the smallest possible rect that contains the two rects defined by _x1, y1, w1, h1_ and _x2, y2, w2, h2_.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-geometry.rect.fast_union)
             *
             * @noSelf
             */
            export function fast_union(
                x1: number,
                y1: number,
                w1: number,
                h1: number,
                x2: number,
                y2: number,
                w2: number,
                h2: number
            ): [number, number, number, number][];
        }

        class rect {
            /**
             * Returns a new copy of the rect.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.rect.copy)
             */
            copy(): playdate.geometry.rect;

            /**
             * Returns a new playdate.geometry.polygon version of the rect.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.rect.toPolygon)
             */
            toPolygon(): playdate.geometry.polygon;

            /**
             * Returns _x_, _y_, _width_ and _height_ as individual values.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.rect.unpack)
             */
            unpack(): LuaMultiReturn<[number, number, number, number]>;

            /**
             * Returns true if a rectangle has zero width or height.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.rect.isEmpty)
             */
            isEmpty(): boolean;

            /**
             * Returns true if the _x_, _y_, _width_, and _height_ values of the caller and _r2_ are all equal.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.rect.isEqual)
             */
            isEqual(r2: playdate.geometry.rect): boolean;

            /**
             * Returns true if _r2_ intersects the caller.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.rect.intersects)
             */
            intersects(r2: playdate.geometry.rect): boolean;

            /**
             * Returns a rect representing the overlapping portion of the caller and _r2_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.rect.intersection)
             */
            intersection(r2: playdate.geometry.rect): playdate.geometry.rect;

            /**
             * Returns the smallest possible rect that contains both the source rect and _r2_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.rect.union)
             */
            union(r2: playdate.geometry.rect): playdate.geometry.rect;

            /**
             * Insets the rect by the given _dx_ and _dy_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.rect.inset)
             */
            inset(dx: number, dy: number): void;

            /**
             * Returns a rect that is inset by the given _dx_ and _dy_, with the same center point.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.rect.insetBy)
             */
            insetBy(dx: number, dy: number): playdate.geometry.rect;

            /**
             * Offsets the rect by the given _dx_ and _dy_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.rect.offset)
             */
            offset(dx: number, dy: number): void;

            /**
             * Returns a rect with its origin point offset by _dx_, _dy_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.rect.offsetBy)
             */
            offsetBy(dx: number, dy: number): playdate.geometry.rect;

            /**
             * Returns true if the [rect](https://sdk.play.date/2.5.0#C-geometry.rect) _r2_ is contained within the caller [rect](https://sdk.play.date/2.5.0#C-geometry.rect).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.rect.containsRect-r2)
             */
            containsRect(r2: playdate.geometry.rect): boolean;
            /**
             * Returns true if the rect defined by _(x, y, width, height)_ is contained within the caller [rect](https://sdk.play.date/2.5.0#C-geometry.rect).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.rect.containsRect)
             */
            containsRect(
                x: number,
                y: number,
                width: number,
                height: number
            ): boolean;

            /**
             * Returns true if the [point](https://sdk.play.date/2.5.0#C-geometry.point) _p_ is contained within the caller [rect](https://sdk.play.date/2.5.0#C-geometry.rect).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.rect.containsPoint)
             */
            containsPoint(p: playdate.geometry.point): boolean;
            /**
             * Returns true if the point at _(x, y)_ is contained within the caller [rect](https://sdk.play.date/2.5.0#C-geometry.rect).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.rect.containsPoint-xy)
             */
            containsPoint(x: number, y: number): boolean;

            /**
             * Returns a [point](https://sdk.play.date/2.5.0#C-geometry.point) at the center of the caller.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.rect.centerPoint)
             */
            centerPoint(): playdate.geometry.point;

            /**
             * Flips the caller about the center of rect _r2_.
             *
             * _flip_ should be one of the following constants:
             *
             * *   _playdate.geometry.kUnflipped_
             *
             * *   _playdate.geometry.kFlippedX_
             *
             * *   _playdate.geometry.kFlippedY_
             *
             * *   _playdate.geometry.kFlippedXY_
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.rect.flipRelativeToRect)
             */
            flipRelativeToRect(
                r2: playdate.geometry.rect,
                flip: PlaydateFlip
            ): void;
        }

        namespace size {
            /**
             * Returns a new playdate.geometry.size.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-geometry.size.new)
             *
             * @noSelf
             */
            export function _new(
                width: number,
                height: number
            ): playdate.geometry.size;

            export { _new as new };
        }

        class size {
            /**
             * Returns a new copy of the size.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.size.copy)
             */
            copy(): playdate.geometry.size;

            /**
             * Returns the values _width, height_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.size.unpack)
             */
            unpack(): LuaMultiReturn<[number, number]>;
        }

        namespace vector2D {
            /**
             * Returns a new playdate.geometry.vector2D.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-geometry.vector2D.new)
             *
             * @noSelf
             */
            export function _new(
                x: number,
                y: number
            ): playdate.geometry.vector2D;

            export { _new as new };

            /**
             * Returns a new playdate.geometry.vector2D. Angles should be specified in degrees. Zero degrees represents the top of the circle.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-geometry.vector2D.newPolar)
             *
             * @noSelf
             */
            export function newPolar(
                length: number,
                angle: number
            ): playdate.geometry.vector2D;
        }

        class vector2D {
            /**
             * Returns a new copy of the vector2D.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.vector2D.copy)
             */
            copy(): playdate.geometry.vector2D;

            /**
             * Returns the values _dx, dy_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.vector2D.unpack)
             */
            unpack(): LuaMultiReturn<[number, number]>;

            /**
             * Modifies the caller by adding vector _v_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.vector2D.addVector)
             */
            addVector(v: playdate.geometry.vector2D): void;

            /**
             * Modifies the caller, scaling it by amount _s_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.vector2D.scale)
             */
            scale(s: number): void;

            /**
             * Returns the given vector scaled by _s_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.vector2D.scaledBy)
             */
            scaledBy(s: number): playdate.geometry.vector2D;

            /**
             * Modifies the caller by normalizing it so that its length is 1. If the vector is (0,0), the vector is unchanged.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.vector2D.normalize)
             */
            normalize(): void;

            /**
             * Returns a new vector by normalizing the given vector.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.vector2D.normalized)
             */
            normalized(): playdate.geometry.vector2D;

            /**
             * Returns the dot product of the caller and the vector _v_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.vector2D.dotProduct)
             */
            dotProduct(v: playdate.geometry.vector2D): number;

            /**
             * Returns the magnitude of the caller.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.vector2D.magnitude)
             */
            magnitude(): number;

            /**
             * Returns the square of the magnitude of the caller.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.vector2D.magnitudeSquared)
             */
            magnitudeSquared(): number;

            /**
             * Modifies the caller by projecting it along the vector _v_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.vector2D.projectAlong)
             */
            projectAlong(v: playdate.geometry.vector2D): void;

            /**
             * Returns a new vector created by projecting the given vector along the vector _v_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.vector2D.projectedAlong)
             */
            projectedAlong(
                v: playdate.geometry.vector2D
            ): playdate.geometry.vector2D;

            /**
             * Returns the angle between the caller and the vector _v_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.vector2D.angleBetween)
             */
            angleBetween(v: playdate.geometry.vector2D): number;

            /**
             * Returns a vector that is the left normal of the caller.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.vector2D.leftNormal)
             */
            leftNormal(): playdate.geometry.vector2D;

            /**
             * Returns a vector that is the right normal of the caller.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-geometry.vector2D.rightNormal)
             */
            rightNormal(): playdate.geometry.vector2D;
        }
    }

    namespace graphics {
        /**
         * Pushes the current graphics state to the context stack and creates a new context. If a [playdate.graphics.image](https://sdk.play.date/2.5.0#C-graphics.image) is given, drawing functions are applied to the image instead of the screen buffer.
         *
         * Important
         *
         * If you draw into an image context with color set to _playdate.graphics.kColorClear_, those drawn pixels will be set to transparent. When you later draw the image into the framebuffer, those pixels will not be rendered, i.e., will act as transparent pixels in the image.
         *
         * Note
         *
         * [playdate.graphics.lockFocus(_image_)](https://sdk.play.date/2.5.0#f-graphics.lockFocus) will reroute drawing into an image, without saving the overall graphics context.
         *
         * Equivalent to [`playdate->graphics->pushContext()`](./Inside%20Playdate%20with%20C.html#f-graphics.pushContext) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.pushContext)
         *
         * @noSelf
         */
        export function pushContext(image?: playdate.graphics.image): void;

        /**
         * Pops a graphics context off the context stack and restores its state.
         *
         * Equivalent to [`playdate->graphics->popContext()`](./Inside%20Playdate%20with%20C.html#f-graphics.popContext) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.popContext)
         *
         * @noSelf
         */
        export function popContext(): void;

        /**
         * Clears the entire display, setting the color to either the given _color_ argument, or the current background color set in [setBackgroundColor(color)](https://sdk.play.date/2.5.0#f-graphics.setBackgroundColor) if no argument is given.
         *
         * Equivalent to [`playdate->graphics->clear()`](./Inside%20Playdate%20with%20C.html#f-graphics.clear) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.clear)
         *
         * @noSelf
         */
        export function clear(color?: PlaydateColor): void;

        /**
         * Returns the pair (_width_, _height_) for the image at _path_ without actually loading the image.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.image.imageSizeAtPath)
         *
         * @noSelf
         */
        export function imageSizeAtPath(
            path: string
        ): LuaMultiReturn<[number, number]>;

        /**
         * Returns true if the non-alpha-masked portions of _image1_ and _image2_ overlap if they were drawn at positions (_x1_, _y1_) and (_x2_, _y2_) and flipped according to _flip1_ and _flip2_, which should each be one of the values listed in [`playdate.graphics.image:draw()`](https://sdk.play.date/2.5.0#m-graphics.imgDraw).
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.checkAlphaCollision)
         *
         * @noSelf
         */
        export function checkAlphaCollision(
            image1: playdate.graphics.image,
            x1: number,
            y1: number,
            flip1: PlaydateFlip,
            image2: playdate.graphics.image,
            x2: number,
            y2: number,
            flip2: PlaydateFlip
        ): boolean;

        /**
         * Sets and gets the current drawing color for primitives.
         *
         * _color_ should be one of the constants:
         *
         * *   _playdate.graphics.kColorBlack_
         *
         * *   _playdate.graphics.kColorWhite_
         *
         * *   _playdate.graphics.kColorClear_
         *
         * *   _playdate.graphics.kColorXOR_
         *
         *
         * This color applies to drawing primitive shapes such as lines and rectangles, not bitmap images.
         *
         * Important
         *
         * [`setColor()`](https://sdk.play.date/2.5.0#f-graphics.setColor) and [`setPattern()`](https://sdk.play.date/2.5.0#f-graphics.setPattern) / [`setDitherPattern()`](https://sdk.play.date/2.5.0#f-graphics.setDitherPattern) are mutually exclusive. Setting a color will overwrite a pattern, and vice versa.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.setColor)
         *
         * @noSelf
         */
        export function setColor(color: PlaydateColor): void;

        /**
         * Gets the current drawing color for primitives.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.getColor)
         *
         * @noSelf
         */
        export function getColor(): PlaydateColor;

        /**
         * Sets the color used for drawing the background, if necessary, before [playdate.graphics.sprite](https://sdk.play.date/2.5.0#C-graphics.sprite)s are drawn on top.
         *
         * _color_ should be one of the constants:
         *
         * *   _playdate.graphics.kColorBlack_
         *
         * *   _playdate.graphics.kColorWhite_
         *
         * *   _playdate.graphics.kColorClear_
         *
         *
         * Use _kColorClear_ if you intend to draw behind sprites.
         *
         * Equivalent to [`playdate->graphics->setBackgroundColor()`](./Inside%20Playdate%20with%20C.html#f-graphics.setBackgroundColor) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.setBackgroundColor)
         *
         * @noSelf
         */
        export function setBackgroundColor(color: PlaydateColor): void;

        /**
         * Gets the color used for drawing the background, if necessary, before [playdate.graphics.sprite](https://sdk.play.date/2.5.0#C-graphics.sprite)s are drawn on top.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.getBackgroundColor)
         *
         * @noSelf
         */
        export function getBackgroundColor(): PlaydateColor;

        /**
         * Sets the 8x8 pattern used for drawing. The _pattern_ argument is an array of 8 numbers describing the bitmap for each row; for example, _{ 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55 }_ specifies a checkerboard pattern. An additional 8 numbers can be specified for an alpha mask bitmap.
         *
         * Important
         *
         * To "un-set" a pattern, call [`setColor()`](https://sdk.play.date/2.5.0#f-graphics.setColor). [`setColor()`](https://sdk.play.date/2.5.0#f-graphics.setColor) and [`setPattern()`](https://sdk.play.date/2.5.0#f-graphics.setPattern) / [`setDitherPattern()`](https://sdk.play.date/2.5.0#f-graphics.setDitherPattern) are mutually exclusive. Setting a pattern will overwrite a color, and vice versa.
         *
         * `**playdate.graphics.setPattern(image, [x, y])**`
         *
         * Uses the given [playdate.graphics.image](https://sdk.play.date/2.5.0#C-graphics.image) to set the 8 x 8 pattern used for drawing. The optional _x_, _y_ offset (default 0, 0) indicates the top left corner of the 8 x 8 pattern.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.setPattern)
         *
         * @noSelf
         */
        export function setPattern(
            pattern: [
                number,
                number,
                number,
                number,
                number,
                number,
                number,
                number
            ]
        ): void;

        /**
         * Sets the pattern used for drawing to a dithered pattern. If the current drawing color is white, the pattern is white pixels on a transparent background and (due to a bug) the _alpha_ value is inverted: 1.0 is transparent and 0 is opaque. Otherwise, the pattern is black pixels on a transparent background and _alpha_ 0 is transparent while 1.0 is opaque.
         *
         * The optional _ditherType_ argument is a dither type as used in [`playdate.graphics.image:blurredImage()`](https://sdk.play.date/2.5.0#m-graphics.image.blurredImage), and should be an ordered dither type; i.e., line, screen, or Bayer.
         *
         * Caution
         *
         * The error-diffusing dither types Floyd-Steinberg (`kDitherTypeFloydSteinberg`), Burkes (`kDitherTypeBurkes`), and Atkinson (`kDitherTypeAtkinson`) are allowed but produce very unpredictable results here.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.setDitherPattern)
         *
         * @noSelf
         */
        export function setDitherPattern(
            alpha: number,
            ditherType?: PlaydateDitherType
        ): void;

        /**
         * Draws a line from (_x1_, _y1_) to (_x2_, _y2_), or draws the [playdate.geometry.lineSegment](https://sdk.play.date/2.5.0#C-geometry.lineSegment) _ls_.
         *
         * Line width is specified by [setLineWidth()](https://sdk.play.date/2.5.0#f-graphics.setLineWidth). End cap style is specified by [setLineCapStyle()](https://sdk.play.date/2.5.0#f-graphics.setLineCapStyle).
         *
         * Equivalent to [`playdate->graphics->drawLine()`](./Inside%20Playdate%20with%20C.html#f-graphics.drawLine) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawLine)
         *
         * @noSelf
         */
        export function drawLine(
            x1: number,
            y1: number,
            x2: number,
            y2: number
        ): void;

        /**
         * Draws a line from (_x1_, _y1_) to (_x2_, _y2_), or draws the [playdate.geometry.lineSegment](https://sdk.play.date/2.5.0#C-geometry.lineSegment) _ls_.
         *
         * Line width is specified by [setLineWidth()](https://sdk.play.date/2.5.0#f-graphics.setLineWidth). End cap style is specified by [setLineCapStyle()](https://sdk.play.date/2.5.0#f-graphics.setLineCapStyle).
         *
         * Equivalent to [`playdate->graphics->drawLine()`](./Inside%20Playdate%20with%20C.html#f-graphics.drawLine) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawLine)
         *
         * @noSelf
         */
        export function drawLine(ls: playdate.geometry.lineSegmentnt): void;

        /**
         * Specifies the shape of the endpoints drawn by [drawLine](https://sdk.play.date/2.5.0#f-graphics.drawLine).
         *
         * _style_ should be one of these constants:
         *
         * *   _playdate.graphics.kLineCapStyleButt_
         *
         * *   _playdate.graphics.kLineCapStyleRound_
         *
         * *   _playdate.graphics.kLineCapStyleSquare_
         *
         *
         * Equivalent to [`playdate->graphics->setLineCapStyle()`](./Inside%20Playdate%20with%20C.html#f-graphics.setLineCapStyle) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.setLineCapStyle)
         *
         * @noSelf
         */
        export function setLineCapStyle(style: PlaydateLineCapStyle): void;

        /**
         * Draw a single pixel in the current color at (_x_, _y_).
         *
         * `**playdate.graphics.drawPixel(p)**`
         *
         * Draw a single pixel in the current color at [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point) _p_.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawPixel)
         *
         * @noSelf
         */
        export function drawPixel(x: number, y: number): void;

        /**
         * Draws the rect _r_ or the rect with origin (_x_, _y_) with a size of (_w_, _h_).
         *
         * Line width is specified by [setLineWidth()](https://sdk.play.date/2.5.0#f-graphics.setLineWidth). Stroke location is specified by [setStrokeLocation()](https://sdk.play.date/2.5.0#f-graphics.setStrokeLocation).
         *
         * Equivalent to [`playdate->graphics->drawRect()`](./Inside%20Playdate%20with%20C.html#f-graphics.drawRect) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawRect)
         *
         * @noSelf
         */
        export function drawRect(
            x: number,
            y: number,
            w: number,
            h: number
        ): void;

        /**
         * Draws the rect _r_ or the rect with origin (_x_, _y_) with a size of (_w_, _h_).
         *
         * Line width is specified by [setLineWidth()](https://sdk.play.date/2.5.0#f-graphics.setLineWidth). Stroke location is specified by [setStrokeLocation()](https://sdk.play.date/2.5.0#f-graphics.setStrokeLocation).
         *
         * Equivalent to [`playdate->graphics->drawRect()`](./Inside%20Playdate%20with%20C.html#f-graphics.drawRect) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawRect)
         *
         * @noSelf
         */
        export function drawRect(r: playdate.geometry.rect): void;

        /**
         * Draws the filled rectangle _r_ or the rect at (_x_, _y_) of the given width and height.
         *
         * Equivalent to [`playdate->graphics->fillRect()`](./Inside%20Playdate%20with%20C.html#f-graphics.fillRect) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.fillRect)
         *
         * @noSelf
         */
        export function fillRect(
            x: number,
            y: number,
            width: number,
            height: number
        ): void;

        /**
         * Draws the filled rectangle _r_ or the rect at (_x_, _y_) of the given width and height.
         *
         * Equivalent to [`playdate->graphics->fillRect()`](./Inside%20Playdate%20with%20C.html#f-graphics.fillRect) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.fillRect)
         *
         * @noSelf
         */
        export function fillRect(r: playdate.geometry.rect): void;

        /**
         * Draws a rectangle with rounded corners in the rect _r_ or the rect with origin (_x_, _y_) and size (_w_, _h_).
         *
         * _radius_ defines the radius of the corners.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawRoundRect)
         *
         * @noSelf
         */
        export function drawRoundRect(
            x: number,
            y: number,
            w: number,
            h: number,
            radius: number
        ): void;

        /**
         * Draws a rectangle with rounded corners in the rect _r_ or the rect with origin (_x_, _y_) and size (_w_, _h_).
         *
         * _radius_ defines the radius of the corners.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawRoundRect)
         *
         * @noSelf
         */
        export function drawRoundRect(
            r: playdate.geometry.rect,
            radius: number
        ): void;

        /**
         * Draws a filled rectangle with rounded corners in the rect _r_ or the rect with origin (_x_, _y_) and size (_w_, _h_).
         *
         * _radius_ defines the radius of the corners.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.fillRoundRect)
         *
         * @noSelf
         */
        export function fillRoundRect(
            x: number,
            y: number,
            w: number,
            h: number,
            radius: number
        ): void;

        /**
         * Draws a filled rectangle with rounded corners in the rect _r_ or the rect with origin (_x_, _y_) and size (_w_, _h_).
         *
         * _radius_ defines the radius of the corners.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.fillRoundRect)
         *
         * @noSelf
         */
        export function fillRoundRect(
            r: playdate.geometry.rect,
            radius: number
        ): void;

        /**
         * Draws an arc using the current color.
         *
         * Angles are specified in degrees, not radians.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawArc)
         *
         * @noSelf
         */
        export function drawArc(arc: playdate.geometry.arc): void;

        /**
         * Draws an arc using the current color.
         *
         * Angles are specified in degrees, not radians.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawArc)
         *
         * @noSelf
         */
        export function drawArc(
            x: number,
            y: number,
            radius: number,
            startAngle: number,
            endAngle: number
        ): void;

        /**
         * Draws a circle at the point _(x, y)_ (or _p_) with radius _radius_.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawCircleAtPoint)
         *
         * @noSelf
         */
        export function drawCircleAtPoint(
            x: number,
            y: number,
            radius: number
        ): void;

        /**
         * Draws a circle at the point _(x, y)_ (or _p_) with radius _radius_.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawCircleAtPoint)
         *
         * @noSelf
         */
        export function drawCircleAtPoint(
            p: playdate.geometry.point,
            radius: number
        ): void;

        /**
         * Draws a circle in the rect _r_ or the rect with origin _(x, y)_ and size _(width, height)_.
         *
         * If the rect is not a square, the circle will be drawn centered in the rect.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawCircleInRect)
         *
         * @noSelf
         */
        export function drawCircleInRect(
            x: number,
            y: number,
            width: number,
            height: number
        ): void;

        /**
         * Draws a circle in the rect _r_ or the rect with origin _(x, y)_ and size _(width, height)_.
         *
         * If the rect is not a square, the circle will be drawn centered in the rect.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawCircleInRect)
         *
         * @noSelf
         */
        export function drawCircleInRect(r: playdate.geometry.rect): void;

        /**
         * Draws a filled circle at the point _(x, y)_ (or _p_) with radius _radius_.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.fillCircleAtPoint)
         *
         * @noSelf
         */
        export function fillCircleAtPoint(
            x: number,
            y: number,
            radius: number
        ): void;

        /**
         * Draws a filled circle at the point _(x, y)_ (or _p_) with radius _radius_.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.fillCircleAtPoint)
         *
         * @noSelf
         */
        export function fillCircleAtPoint(
            p: playdate.geometry.point,
            radius: number
        ): void;

        /**
         * Draws a filled circle in the rect _r_ or the rect with origin _(x, y)_ and size _(width, height)_.
         *
         * If the rect is not a square, the circle will be drawn centered in the rect.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.fillCircleInRect)
         *
         * @noSelf
         */
        export function fillCircleInRect(
            x: number,
            y: number,
            width: number,
            height: number
        ): void;

        /**
         * Draws a filled circle in the rect _r_ or the rect with origin _(x, y)_ and size _(width, height)_.
         *
         * If the rect is not a square, the circle will be drawn centered in the rect.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.fillCircleInRect)
         *
         * @noSelf
         */
        export function fillCircleInRect(r: playdate.geometry.rect): void;

        /**
         * Draws an ellipse in the rect _r_ or the rect with origin _(x, y)_ and size _(width, height)_.
         *
         * _startAngle_ and _endAngle_, if provided, should be in degrees (not radians), and will cause only the segment of the ellipse between _startAngle_ and _endAngle_ to be drawn.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawEllipseInRect)
         *
         * @noSelf
         */
        export function drawEllipseInRect(
            x: number,
            y: number,
            width: number,
            height: number,
            startAngle?: number,
            endAngle?: number
        ): void;

        /**
         * Draws an ellipse in the rect _r_ or the rect with origin _(x, y)_ and size _(width, height)_.
         *
         * _startAngle_ and _endAngle_, if provided, should be in degrees (not radians), and will cause only the segment of the ellipse between _startAngle_ and _endAngle_ to be drawn.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawEllipseInRect)
         *
         * @noSelf
         */
        export function drawEllipseInRect(
            rect: playdate.geometry.rect,
            startAngle?: number,
            endAngle?: number
        ): void;

        /**
         * Draws a filled ellipse in the rect _r_ or the rect with origin _(x, y)_ and size _(width, height)_.
         *
         * _startAngle_ and _endAngle_, if provided, should be in degrees (not radians), and will cause only the segment of the ellipse between _startAngle_ and _endAngle_ to be drawn.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.fillEllipseInRect)
         *
         * @noSelf
         */
        export function fillEllipseInRect(
            x: number,
            y: number,
            width: number,
            height: number,
            startAngle?: number,
            endAngle?: number
        ): void;

        /**
         * Draws a filled ellipse in the rect _r_ or the rect with origin _(x, y)_ and size _(width, height)_.
         *
         * _startAngle_ and _endAngle_, if provided, should be in degrees (not radians), and will cause only the segment of the ellipse between _startAngle_ and _endAngle_ to be drawn.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.fillEllipseInRect)
         *
         * @noSelf
         */
        export function fillEllipseInRect(
            rect: playdate.geometry.rect,
            startAngle?: number,
            endAngle?: number
        ): void;

        /**
         * Draw the [playdate.geometry.polygon](https://sdk.play.date/2.5.0#C-geometry.polygon) _p_. Only draws a line between the first and last vertex if the polygon is [closed](https://sdk.play.date/2.5.0#m-geometry.polygon.close).
         *
         * Line width is specified by [setLineWidth()](https://sdk.play.date/2.5.0#f-graphics.setLineWidth).
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawPolygon)
         *
         * @noSelf
         */
        export function drawPolygon(p: playdate.geometry.polygon): void;

        /**
         * Fills the polygon specified by a list of x,y coordinates. An edge between the last vertex and the first is assumed.
         *
         * Equivalent to [`playdate->graphics->fillPolygon()`](./Inside%20Playdate%20with%20C.html#f-graphics.fillPolygon) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.fillPolygon)
         *
         * @noSelf
         */
        export function fillPolygon(...coordinates: number): void;

        /**
         * Sets the winding rule for filling polygons, one of:
         *
         * *   _playdate.graphics.kPolygonFillNonZero_
         *
         * *   _playdate.graphics.kPolygonFillEvenOdd_
         *
         *
         * See [https://en.wikipedia.org/wiki/Nonzero-rule](https://en.wikipedia.org/wiki/Nonzero-rule) for an explanation of the winding rule.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.setPolygonFillRule)
         *
         * @noSelf
         */
        export function setPolygonFillRule(rule: PlaydateFillRule): void;

        /**
         * Draws a triangle with vertices (_x1_, _y1_), (_x2_, _y2_), and (_x3_, _y3_).
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawTriangle)
         *
         * @noSelf
         */
        export function drawTriangle(
            x1: number,
            y1: number,
            x2: number,
            y2: number,
            x3: number,
            y3: number
        ): void;

        /**
         * Draws a filled triangle with vertices (_x1_, _y1_), (_x2_, _y2_), and (_x3_, _y3_).
         *
         * Equivalent to [`playdate->graphics->fillTriangle()`](./Inside%20Playdate%20with%20C.html#f-graphics.fillTriangle) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.fillTriangle)
         *
         * @noSelf
         */
        export function fillTriangle(
            x1: number,
            y1: number,
            x2: number,
            y2: number,
            x3: number,
            y3: number
        ): void;

        /**
         * Returns the Perlin value (from 0.0 to 1.0) at position _(x, y, z)_.
         *
         * If _repeat_ is greater than 0, the pattern of noise will repeat at that point on all 3 axes.
         *
         * _octaves_ is the number of octaves of noise to apply. Compute time increases linearly with each additional octave, but the results are a bit more organic, consisting of a combination of larger and smaller variations.
         *
         * When using more than one octave, _persistence_ is a value from 0.0 - 1.0 describing the amount the amplitude is scaled each octave. The lower the value of _persistence_, the less influence each successive octave has on the final value.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.perlin)
         *
         * @noSelf
         */
        export function perlin(
            x: number,
            y: number,
            z: number,
            repeat: number,
            octaves?: number,
            persistence?: number
        ): void;

        /**
         * Returns an array of Perlin values at once, avoiding the performance penalty of calling _perlin()_ multiple times in a loop.
         *
         * The parameters are the same as _perlin()_ except:
         *
         * _count_ is the number of values to be returned.
         *
         * _dx_, _dy_, and _dz_ are how far to step along the x, y, and z axes in each iteration.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.perlinArray)
         *
         * @noSelf
         */
        export function perlinArray(
            count: number,
            x: number,
            dx: number,
            y?: number,
            dy: number,
            z: number,
            dz: number,
            repeat: number,
            octaves: number,
            persistence?: number
        ): number[];

        /**
         * Important
         *
         * You must import _CoreLibs/qrcode_ to use this function.
         *
         * Caution
         *
         * This function uses [`playdate.timer`](https://sdk.play.date/2.5.0#C-timer) internally, so be sure to call [`playdate.timer.updateTimers()`](https://sdk.play.date/2.5.0#f-timer.updateTimers) in your main [`playdate.update()`](https://sdk.play.date/2.5.0#c-update) function, otherwise the callback will never be invoked.
         *
         * Asynchronously returns an image representing a QR code for the passed-in string to the function `callback`. The arguments passed to the callback are [_image_](https://sdk.play.date/2.5.0#C-graphics.image), _errorMessage_. (If an _errorMessage_ string is returned, _image_ will be nil.)
         *
         * `desiredEdgeDimension` lets you specify an approximate edge dimension in pixels for the desired QR code, though the function has limited flexibility in sizing QR codes, based on the amount of information to be encoded, and the restrictions of a 1-bit screen. The function will attempt to generate a QR code _smaller_ than `desiredEdgeDimension` if possible. (Note that QR codes always have the same width and height.)
         *
         * If you specify nil for `desiredEdgeDimension`, the returned image will balance small size with easy readability. If you specify 0, the returned image will be the smallest possible QR code for the specified string.
         *
         * `generateQRCode()` will return a reference to the [timer](https://sdk.play.date/2.5.0#C-timer) it uses to run asynchronously. If you wish to stop execution of the background process generating the QR code, call [`:remove()`](https://sdk.play.date/2.5.0#m-timer.remove) on that returned timer.
         *
         * Tip
         *
         * If you know ahead of time what data you plan to encode, it is much faster to pre-generate the QR code, store it as a .png file in your game, and draw the .png at runtime. You can use [`playdate.simulator.writeToFile()`](https://sdk.play.date/2.5.0#f-simulator.writeToFile) to create this .png file.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.generateQRCode)
         *
         * @noSelf
         */
        export function generateQRCode(
            stringToEncode: string,
            desiredEdgeDimension: number,
            callback: () => void
        ): playdate.graphics.image;

        /**
         * Important
         *
         * You must import _CoreLibs/graphics_ to use this function.
         *
         * Draws an approximation of a sine wave between the points _startX, startY_ and _endX, endY_.
         *
         * *   _startAmplitude_: The number of pixels above and below the line from _startX, startY_ and _endX, endY_ the peaks and valleys of the wave will be drawn at the start of the wave.
         *
         * *   _endAmplitude_: The number of pixels above and below the line from _startX, startY_ and _endX, endY_ the peaks and valleys of the wave will be drawn at the end of the wave.
         *
         * *   _period_: The distance between peaks, in pixels.
         *
         * *   _phaseShift_: If provided, specifies the wave’s offset, in pixels.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawSineWave)
         *
         * @noSelf
         */
        export function drawSineWave(
            startX: number,
            startY: number,
            endX: number,
            endY: number,
            startAmplitude: number,
            endAmplitude: number,
            period: number,
            phaseShift?: number
        ): void;

        /**
         * `setClipRect()` sets the clipping rectangle for all subsequent graphics drawing, including bitmaps. The argument can either be separate dimensions or a [playdate.geometry.rect](https://sdk.play.date/2.5.0#C-geometry.rect) object. The clip rect is automatically cleared at the beginning of the [`playdate.update()`](https://sdk.play.date/2.5.0#c-update) callback. The function uses world coordinates; that is, the given rectangle will be translated by the current drawing offset. To use screen coordinates instead, use [`setScreenClipRect()`](https://sdk.play.date/2.5.0#f-graphics.setScreenClipRect)
         *
         * Equivalent to [`playdate->graphics->setClipRect()`](./Inside%20Playdate%20with%20C.html#f-graphics.setClipRect) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.setClipRect)
         *
         * @noSelf
         */
        export function setClipRect(
            x: number,
            y: number,
            width: number,
            height: number
        ): void;

        /**
         * `setClipRect()` sets the clipping rectangle for all subsequent graphics drawing, including bitmaps. The argument can either be separate dimensions or a [playdate.geometry.rect](https://sdk.play.date/2.5.0#C-geometry.rect) object. The clip rect is automatically cleared at the beginning of the [`playdate.update()`](https://sdk.play.date/2.5.0#c-update) callback. The function uses world coordinates; that is, the given rectangle will be translated by the current drawing offset. To use screen coordinates instead, use [`setScreenClipRect()`](https://sdk.play.date/2.5.0#f-graphics.setScreenClipRect)
         *
         * Equivalent to [`playdate->graphics->setClipRect()`](./Inside%20Playdate%20with%20C.html#f-graphics.setClipRect) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.setClipRect)
         *
         * @noSelf
         */
        export function setClipRect(rect: playdate.geometry.rect): void;

        /**
         * `getClipRect()` returns multiple values (_x_, _y_, _width_, _height_) giving the current clipping rectangle.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.getClipRect)
         *
         * @noSelf
         */
        export function getClipRect(): LuaMultiReturn<
            [number, number, number, number]
        >;

        /**
         * Sets the clip rectangle as above, but uses screen coordinates instead of world coordinates—​that is, it ignores the current drawing offset.
         *
         * Equivalent to [`playdate->graphics->setScreenClipRect()`](./Inside%20Playdate%20with%20C.html#f-graphics.setScreenClipRect) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.setScreenClipRect)
         *
         * @noSelf
         */
        export function setScreenClipRect(
            x: number,
            y: number,
            width: number,
            height: number
        ): void;

        /**
         * Sets the clip rectangle as above, but uses screen coordinates instead of world coordinates—​that is, it ignores the current drawing offset.
         *
         * Equivalent to [`playdate->graphics->setScreenClipRect()`](./Inside%20Playdate%20with%20C.html#f-graphics.setScreenClipRect) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.setScreenClipRect)
         *
         * @noSelf
         */
        export function setScreenClipRect(rect: playdate.geometry.rect): void;

        /**
         * Returns the clip rect as in `getClipRect()`, but using screen coordinates instead of world coordinates.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.getScreenClipRect)
         *
         * @noSelf
         */
        export function getScreenClipRect(): LuaMultiReturn<
            [number, number, number, number]
        >;

        /**
         * Clears the current clipping rectangle, set with [`setClipRect()`](https://sdk.play.date/2.5.0#f-graphics.setClipRect).
         *
         * Equivalent to [`playdate->graphics->clearClipRect()`](./Inside%20Playdate%20with%20C.html#f-graphics.clearClipRect) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.clearClipRect)
         *
         * @noSelf
         */
        export function clearClipRect(): void;

        /**
         * Sets the current [stencil](https://en.wikipedia.org/wiki/Stencil_buffer) to the given image. If _tile_ is set, the the stencil will be tiled; in this case, the image width must be a multiple of 32 pixels.
         *
         * Equivalent to [`playdate->graphics->setStencilImage()`](./Inside%20Playdate%20with%20C.html#f-graphics.setStencilImage) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.setStencilImage)
         *
         * @noSelf
         */
        export function setStencilImage(
            image: playdate.graphics.image,
            tile?: boolean
        ): void;

        /**
         * Sets a pattern to use for stenciled drawing, as an alternative to creating an image, drawing a pattern into the image, then using that in `setStencilImage()`. `pattern` should be a table of the form `{ row1, row2, row3, row4, row5, row6, row7, row8 }`.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.setStencilPattern)
         *
         * @noSelf
         */
        export function setStencilPattern(
            pattern: [
                number,
                number,
                number,
                number,
                number,
                number,
                number,
                number
            ]
        ): void;

        /**
         * Sets the stencil to a dither pattern specified by _level_ and optional _ditherType_ (defaults to `playdate.graphics.image.kDitherTypeBayer8x8`).
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.setStencilPattern-dither)
         *
         * @noSelf
         */
        export function setStencilPattern(
            level: number,
            ditherType?: PlaydateDitherType
        ): void;

        /**
         * Clears the [stencil buffer](https://en.wikipedia.org/wiki/Stencil_buffer).
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.clearStencil)
         *
         * @noSelf
         */
        export function clearStencil(): void;

        /**
         * Caution
         *
         * _Deprecated._
         *
         * Clears the [stencil buffer](https://en.wikipedia.org/wiki/Stencil_buffer).
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.clearStencilImage)
         *
         * @noSelf
         */
        export function clearStencilImage(): void;

        /**
         * Sets the current drawing mode for images.
         *
         * Important
         *
         * The draw mode applies to images and fonts (which are technically images). The draw mode does not apply to primitive shapes such as lines or rectangles.
         *
         * The available options for _mode_ (demonstrated by drawing a two-color background image first, setting the specified draw mode, then drawing the Crankin' character on top) are:
         *
         * *   _playdate.graphics.kDrawModeCopy_: Images are drawn exactly as they are (black pixels are drawn black and white pixels are drawn white)
         *
         *
         * ![drawmode copy](Inside%20Playdate/drawmode-copy.png)
         *
         * *   _playdate.graphics.kDrawModeWhiteTransparent_: Any white portions of an image are drawn transparent (black pixels are drawn black and white pixels are drawn transparent)
         *
         *
         * ![drawmode whitetransparent](Inside%20Playdate/drawmode-whitetransparent.png)
         *
         * *   _playdate.graphics.kDrawModeBlackTransparent_: Any black portions of an image are drawn transparent (black pixels are drawn transparent and white pixels are drawn white)
         *
         *
         * ![drawmode blacktransparent](Inside%20Playdate/drawmode-blacktransparent.png)
         *
         * *   _playdate.graphics.kDrawModeFillWhite_: All non-transparent pixels are drawn white (black pixels are drawn white and white pixels are drawn white)
         *
         *
         * ![drawmode fillwhite](Inside%20Playdate/drawmode-fillwhite.png)
         *
         * *   _playdate.graphics.kDrawModeFillBlack_: All non-transparent pixels are drawn black (black pixels are drawn black and white pixels are drawn black)
         *
         *
         * ![drawmode fillblack](Inside%20Playdate/drawmode-fillblack.png)
         *
         * *   _playdate.graphics.kDrawModeXOR_: Pixels are drawn inverted on white backgrounds, creating an effect where any white pixels in the original image will always be visible, regardless of the background color, and any black pixels will appear transparent (on a white background, black pixels are drawn white and white pixels are drawn black)
         *
         *
         * ![drawmode xor](Inside%20Playdate/drawmode-xor.png)
         *
         * *   _playdate.graphics.kDrawModeNXOR_: Pixels are drawn inverted on black backgrounds, creating an effect where any black pixels in the original image will always be visible, regardless of the background color, and any white pixels will appear transparent (on a black background, black pixels are drawn white and white pixels are drawn black)
         *
         *
         * ![drawmode nxor](Inside%20Playdate/drawmode-nxor.png)
         *
         * *   _playdate.graphics.kDrawModeInverted_: Pixels are drawn inverted (black pixels are drawn white and white pixels are drawn black)
         *
         *
         * ![drawmode inverted](Inside%20Playdate/drawmode-inverted.png)
         *
         * Instead of the above-specified constants, you can also use one of the following strings: "copy", "inverted", "XOR", "NXOR", "whiteTransparent", "blackTransparent", "fillWhite", or "fillBlack".
         *
         * Equivalent to [`playdate->graphics->setDrawMode()`](./Inside%20Playdate%20with%20C.html#f-graphics.setDrawMode) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.setImageDrawMode)
         *
         * @noSelf
         */
        export function setImageDrawMode(mode: PlaydateDrawMode): void;

        /**
         * Gets the current drawing mode for images.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.getImageDrawMode)
         *
         * @noSelf
         */
        export function getImageDrawMode(): PlaydateDrawMode;

        /**
         * Sets the width of the line for [drawLine](https://sdk.play.date/2.5.0#f-graphics.drawLine), [drawRect](https://sdk.play.date/2.5.0#f-graphics.drawRect), [drawPolygon](https://sdk.play.date/2.5.0#f-graphics.drawPolygon), and [drawArc](https://sdk.play.date/2.5.0#f-graphics.drawArc) when a [playdate.geometry.arc](https://sdk.play.date/2.5.0#C-geometry.arc) is passed as the argument. This value is saved and restored when pushing and popping the [graphics context](https://sdk.play.date/2.5.0#f-graphics.pushContext).
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.setLineWidth)
         *
         * @noSelf
         */
        export function setLineWidth(width: number): void;

        /**
         * Gets the current line width.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.getLineWidth)
         *
         * @noSelf
         */
        export function getLineWidth(): number;

        /**
         * Specifies where the stroke is placed relative to the rectangle passed into [drawRect](https://sdk.play.date/2.5.0#f-graphics.drawRect).
         *
         * _location_ is one of these constants:
         *
         * *   _playdate.graphics.kStrokeCentered_
         *
         * *   _playdate.graphics.kStrokeOutside_
         *
         * *   _playdate.graphics.kStrokeInside_
         *
         *
         * This value is saved and restored when pushing and popping the [graphics context](https://sdk.play.date/2.5.0#f-graphics.pushContext).
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.setStrokeLocation)
         *
         * @noSelf
         */
        export function setStrokeLocation(
            location: PlaydateStrokeLocation
        ): void;

        /**
         * Gets the current stroke position.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.getStrokeLocation)
         *
         * @noSelf
         */
        export function getStrokeLocation(): PlaydateStrokeLocation;

        /**
         * `lockFocus()` routes all drawing to the given [playdate.graphics.image](https://sdk.play.date/2.5.0#C-graphics.image). [playdate.graphics.unlockFocus()](https://sdk.play.date/2.5.0#f-graphics.unlockFocus) returns drawing to the frame buffer.
         *
         * Important
         *
         * If you draw into an image with color set to _playdate.graphics.kColorClear_, those drawn pixels will be set to transparent. When you later draw the image into the framebuffer, those pixels will not be rendered, i.e., will act as transparent pixels in the image.
         *
         * Note
         *
         * [playdate.graphics.pushContext(_image_)](https://sdk.play.date/2.5.0#f-graphics.pushContext) will also allow offscreen drawing into an image, with the additional benefit of being able to save and restore the graphics state.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.lockFocus)
         *
         * @noSelf
         */
        export function lockFocus(image: playdate.graphics.image): void;

        /**
         * After calling `unlockFocus()`, drawing is routed to the frame buffer.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.unlockFocus)
         *
         * @noSelf
         */
        export function unlockFocus(): void;

        /**
         * `setDrawOffset(x, y)` offsets the origin point for all drawing calls to _x_, _y_ (can be negative). So, for example, if the offset is set to -20, -20, an image drawn at 20, 20 will appear at the origin (in the upper left corner.)
         *
         * This is useful, for example, for centering a "camera" on a sprite that is moving around a world larger than the screen.
         *
         * Note
         *
         * The _x_ and _y_ arguments to `.setDrawOffset()` are always specified in the original, unaltered coordinate system. So, for instance, repeated calls to `playdate.graphics.setDrawOffset(-10, -10)` will leave the draw offset unchanged. Likewise, `.setDrawOffset(0, 0)` will always "disable" the offset.
         *
         * Tip
         *
         * It can be useful to have operations sometimes ignore the draw offsets. For example, you may want to have the score or some other heads-up display appear onscreen apart from scrolling content. A sprite can be set to ignore offsets by calling [playdate.graphics.sprite:setIgnoresDrawOffset(true)](https://sdk.play.date/2.5.0#m-graphics.sprite.setIgnoresDrawOffset). [playdate.graphics.image:drawIgnoringOffsets()](https://sdk.play.date/2.5.0#m-graphics.image.drawIgnoringOffset) lets you render an image using screen coordinates.
         *
         * Equivalent to [`playdate->graphics->setDrawOffset()`](./Inside%20Playdate%20with%20C.html#f-graphics.setDrawOffset) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.setDrawOffset)
         *
         * @noSelf
         */
        export function setDrawOffset(x: number, y: number): void;

        /**
         * `getDrawOffset()` returns multiple values (_x_, _y_) giving the current draw offset.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.getDrawOffset)
         *
         * @noSelf
         */
        export function getDrawOffset(): LuaMultiReturn<[number, number]>;

        /**
         * Returns a copy the contents of the _last completed frame_, i.e., a "screenshot", as a [playdate.graphics.image](https://sdk.play.date/2.5.0#C-graphics.image).
         *
         * Note
         *
         * Display functions like [setMosaic()](https://sdk.play.date/2.5.0#f-display.setMosaic), [setInverted()](https://sdk.play.date/2.5.0#f-display.setInverted), [setScale()](https://sdk.play.date/2.5.0#f-display.setScale), and [setOffset()](https://sdk.play.date/2.5.0#f-display.setOffset) do not affect the returned image.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.getDisplayImage)
         *
         * @noSelf
         */
        export function getDisplayImage(): playdate.graphics.image;

        /**
         * Returns a copy the contents of the working frame buffer — _the current frame, in-progress_ — as a [playdate.graphics.image](https://sdk.play.date/2.5.0#C-graphics.image).
         *
         * Note
         *
         * Display functions like [setMosaic()](https://sdk.play.date/2.5.0#f-display.setMosaic), [setInverted()](https://sdk.play.date/2.5.0#f-display.setInverted), [setScale()](https://sdk.play.date/2.5.0#f-display.setScale), and [setOffset()](https://sdk.play.date/2.5.0#f-display.setOffset) do not affect the returned image.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.getWorkingImage)
         *
         * @noSelf
         */
        export function getWorkingImage(): playdate.graphics.image;

        /**
         * Sets the sprite’s stencil to the given pattern, tiled across the screen.
         *
         * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setStencilPattern)
         *
         * @noSelf
         */
        export function setStencilPattern(
            pattern: [
                number,
                number,
                number,
                number,
                number,
                number,
                number,
                number
            ]
        ): void;

        /**
         * Sets the current font, a [playdate.graphics.font](https://sdk.play.date/2.5.0#C-graphics.font).
         *
         * _variant_ should be one of the strings "normal", "bold", or "italic", or one of the constants:
         *
         * *   _playdate.graphics.font.kVariantNormal_
         *
         * *   _playdate.graphics.font.kVariantBold_
         *
         * *   _playdate.graphics.font.kVariantItalic_
         *
         *
         * If no variant is specified, _kFontVariantNormal_ is used.
         *
         * Equivalent to [`playdate->graphics->setFont()`](./Inside%20Playdate%20with%20C.html#f-graphics.setFont) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.setFont)
         *
         * @noSelf
         */
        export function setFont(
            font: playdate.graphics.font,
            variant?: PlaydateFontVariant
        ): void;

        /**
         * Returns the current font, a [playdate.graphics.font](https://sdk.play.date/2.5.0#C-graphics.font).
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.getFont)
         *
         * @noSelf
         */
        export function getFont(
            variant?: PlaydateFontVariant
        ): playdate.graphics.font;

        /**
         * Sets multiple font variants at once. `fontFamily` should be a table using the following format:
         *
         * local fontFamily = {
         *  \[playdate.graphics.font.kVariantNormal\] = normal\_font,
         *     \[playdate.graphics.font.kVariantBold\] = bold\_font,
         *     \[playdate.graphics.font.kVariantItalic\] = italic\_font
         * }
         *
         * All fonts and font variants need not be present in the table.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.setFontFamily)
         *
         * @noSelf
         */
        export function setFontFamily(fontFamily: PlaydateFontVariant): void;

        /**
         * Sets the global font tracking (spacing between letters) in pixels. This value is added to the font’s own tracking value as specified in its .fnt file.
         *
         * See [playdate.graphics.font:setTracking](https://sdk.play.date/2.5.0#m-graphics.font.setTracking) to adjust tracking on a specific font.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.setFontTracking)
         *
         * @noSelf
         */
        export function setFontTracking(pixels: number): void;

        /**
         * Gets the global font tracking (spacing between letters) in pixels.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.getFontTracking)
         *
         * @noSelf
         */
        export function getFontTracking(): number;

        /**
         * Like [getFont()](https://sdk.play.date/2.5.0#f-graphics.getFont) but returns the system font rather than the currently set font.
         *
         * _variant_ should be one of the strings "normal", "bold", or "italic", or one of the constants:
         *
         * *   _playdate.graphics.font.kVariantNormal_
         *
         * *   _playdate.graphics.font.kVariantBold_
         *
         * *   _playdate.graphics.font.kVariantItalic_
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.getSystemFont)
         *
         * @noSelf
         */
        export function getSystemFont(
            variant?: PlaydateFontVariant
        ): playdate.graphics.font;

        /**
         * Draws the text using the current font and font advance at location (_x_, _y_).
         *
         * If _fontFamily_ is provided, the text is draw using the given fonts instead of the currently set font. _fontFamily_ should be a table of fonts using keys as specified in [setFontFamily(fontFamily)](https://sdk.play.date/2.5.0#f-graphics.setFontFamily).
         *
         * The optional _leadingAdjustment_ may be used to modify the spacing between lines of text. Pass nil to use the default leading for the font.
         *
         * Returns `_width_`, `_height_`, indicating the size in pixels of the drawn text.
         *
         * **Styling text**
         *
         * To draw bold text, surround the bold portion of text with asterisks. To draw italic text, surround the italic portion of text with underscores. For example:
         *
         * playdate.graphics.drawText("normal \*bold\* \_italic\_", x, y)
         *
         * which will output: "normal **bold** _italic_". Bold and italic font variations must be set using [setFont()](https://sdk.play.date/2.5.0#f-graphics.setFont) with the appropriate variant argument, otherwise the default Playdate fonts will be used.
         *
         * **Escaping styling characters**
         *
         * To draw an asterisk or underscore, use a double-asterisk or double-underscore. Styles may not be nested, but double-characters can be used inside of a styled portion of text.
         *
         * For a complete set of characters allowed in _text_, see [playdate.graphics.font](https://sdk.play.date/2.5.0#C-graphics.font). In addition, the newline character `\n` is allowed and works as expected.
         *
         * **Avoiding styling**
         *
         * Use [playdate.graphics.font:drawText()](https://sdk.play.date/2.5.0#m-graphics.font.drawText), which doesn’t support formatted text.
         *
         * **Inverting text color**
         *
         * To draw white-on-black text (assuming the font you are using is defined in the standard black-on-transparent manner), first call [playdate.graphics.setImageDrawMode(playdate.graphics.kDrawModeFillWhite)](https://sdk.play.date/2.5.0#f-graphics.setImageDrawMode), followed by the appropriate drawText() call. setImageDrawMode() affects how text is rendered because characters are technically images.
         *
         * Equivalent to [`playdate->graphics->drawText()`](./Inside%20Playdate%20with%20C.html#f-graphics.drawText) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawText)
         *
         * @noSelf
         */
        export function drawText(
            text: string,
            x: number,
            y: number,
            fontFamily?: PlaydateFontFamily,
            leadingAdjustment?: number
        ): LuaMultiReturn<[number, number]>;

        /**
         * Draws the text found by doing a lookup of _key_ in the .strings file corresponding to the current system language, or _language_, if specified.
         *
         * The optional _language_ argument can be one of the strings "en", "jp", or one of the constants:
         *
         * *   _playdate.graphics.font.kLanguageEnglish_
         *
         * *   _playdate.graphics.font.kLanguageJapanese_
         *
         *
         * For more information about localization and strings files, see the [Localization](https://sdk.play.date/2.5.0#localization) section.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawLocalizedText)
         *
         * @noSelf
         */
        export function drawLocalizedText(
            key: string,
            x: number,
            y: number,
            language?: PlaydateLanguage,
            leadingAdjustment?: number
        ): void;

        /**
         * Returns a string found by doing a lookup of _key_ in the .strings file corresponding to the current system language, or _language_, if specified.
         *
         * The optional _language_ argument can be one of the strings "en", "jp", or one of the constants:
         *
         * *   _playdate.graphics.font.kLanguageEnglish_
         *
         * *   _playdate.graphics.font.kLanguageJapanese_
         *
         *
         * For more information about localization and strings files, see the [Localization](https://sdk.play.date/2.5.0#localization) section.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.getLocalizedText)
         *
         * @noSelf
         */
        export function getLocalizedText(
            key: string,
            language?: PlaydateLanguage
        ): string;

        /**
         * Returns multiple values _(width, height)_ giving the dimensions required to draw the text _str_ using [drawText()](https://sdk.play.date/2.5.0#f-graphics.drawText). Newline characters (`\n`) are respected.
         *
         * _fontFamily_ should be a table of fonts using keys as specified in [setFontFamily(fontFamily)](https://sdk.play.date/2.5.0#f-graphics.setFontFamily). If provided, fonts from _fontFamily_ will be used for calculating the size of _str_ instead of the currently set font.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.getTextSize)
         *
         * @noSelf
         */
        export function getTextSize(
            str: string,
            fontFamily?: PlaydateFontFamily,
            leadingAdjustment?: number
        ): LuaMultiReturn<[number, number]>;

        /**
         * Important
         *
         * You must import _CoreLibs/graphics_ to use this function.
         *
         * Draws the string _text_ aligned to the left, right, or centered on the _x_ coordinate. Pass one of _kTextAlignment.left_, _kTextAlignment.center_, _kTextAlignment.right_ for the _alignment_ parameter.
         *
         * For text formatting options, see [drawText()](https://sdk.play.date/2.5.0#f-graphics.drawText)
         *
         * To draw unstyled text using a single font, see [playdate.graphics.font:drawTextAligned()](https://sdk.play.date/2.5.0#m-graphics.font.drawTextAligned)
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawTextAligned)
         *
         * @noSelf
         */
        export function drawTextAligned(
            text: string,
            x: number,
            y: number,
            alignment: PlaydateTextAlignment,
            leadingAdjustment?: number
        ): void;

        /**
         * Important
         *
         * You must import _CoreLibs/graphics_ to use these functions.
         *
         * Draws the text using the current font and font advance into the rect defined by (`_x_`, `_y_`, `_width_`, `_height_`) (or `_rect_`).
         *
         * If `_truncationString_` is provided and the text cannot fit in the rect, `_truncationString_` will be appended to the last line.
         *
         * `_alignment_`, if provided, should be one of one of `_kTextAlignment.left_`, `_kTextAlignment.center_`, `_kTextAlignment.right_`. Pass `nil` for `_leadingAdjustment_` and `_truncationString_` if those parameters are not required.
         *
         * `_font_`, if provided, will cause the text to be drawn unstyled using [font:drawText()](https://sdk.play.date/2.5.0#m-graphics.font.drawText) rather than [playdate.graphics.drawText()](https://sdk.play.date/2.5.0#f-graphics.drawText) using the currently-set system fonts.
         *
         * For text formatting options, see [drawText()](https://sdk.play.date/2.5.0#f-graphics.drawText)
         *
         * Returns `_width_`, `_height_`, `_textWasTruncated_`
         *
         * `_width_` and `_height_` indicate the size in pixels of the drawn text. These values may be smaller than the width and height specified when calling the function.
         *
         * `_textWasTruncated_` indicates if the text was truncated to fit within the specified rect.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawTextInRect)
         *
         * @noSelf
         */
        export function drawTextInRect(
            text: string,
            x: number,
            y: number,
            width: number,
            height: number,
            leadingAdjustment?: number,
            truncationString?: string,
            alignment?: PlaydateTextAlignment,
            font?: playdate.graphics.font
        ): LuaMultiReturn<[number, number, boolean]>;

        /**
         * Important
         *
         * You must import _CoreLibs/graphics_ to use these functions.
         *
         * Draws the text using the current font and font advance into the rect defined by (`_x_`, `_y_`, `_width_`, `_height_`) (or `_rect_`).
         *
         * If `_truncationString_` is provided and the text cannot fit in the rect, `_truncationString_` will be appended to the last line.
         *
         * `_alignment_`, if provided, should be one of one of `_kTextAlignment.left_`, `_kTextAlignment.center_`, `_kTextAlignment.right_`. Pass `nil` for `_leadingAdjustment_` and `_truncationString_` if those parameters are not required.
         *
         * `_font_`, if provided, will cause the text to be drawn unstyled using [font:drawText()](https://sdk.play.date/2.5.0#m-graphics.font.drawText) rather than [playdate.graphics.drawText()](https://sdk.play.date/2.5.0#f-graphics.drawText) using the currently-set system fonts.
         *
         * For text formatting options, see [drawText()](https://sdk.play.date/2.5.0#f-graphics.drawText)
         *
         * Returns `_width_`, `_height_`, `_textWasTruncated_`
         *
         * `_width_` and `_height_` indicate the size in pixels of the drawn text. These values may be smaller than the width and height specified when calling the function.
         *
         * `_textWasTruncated_` indicates if the text was truncated to fit within the specified rect.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawTextInRect)
         *
         * @noSelf
         */
        export function drawTextInRect(
            text: string,
            rect: playdate.geometry.rect,
            leadingAdjustment?: number,
            truncationString?: string,
            alignment?: PlaydateTextAlignment,
            font?: playdate.graphics.font
        ): LuaMultiReturn<[number, number, boolean]>;

        /**
         * Important
         *
         * You must import _CoreLibs/graphics_ to use this function.
         *
         * Same as [drawTextAligned()](https://sdk.play.date/2.5.0#f-graphics.drawTextAligned) except localized text is drawn.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawLocalizedTextAligned)
         *
         * @noSelf
         */
        export function drawLocalizedTextAligned(
            text: string,
            x: number,
            y: number,
            alignment: PlaydateTextAlignment,
            language?: PlaydateLanguage,
            leadingAdjustment?: number
        ): void;

        /**
         * Important
         *
         * You must import _CoreLibs/graphics_ to use these functions.
         *
         * Same as [drawTextInRect()](https://sdk.play.date/2.5.0#f-graphics.drawTextInRect) except localized text is drawn.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawLocalizedTextInRect)
         *
         * @noSelf
         */
        export function drawLocalizedTextInRect(
            text: string,
            x: number,
            y: number,
            width: number,
            height: number,
            leadingAdjustment?: number,
            truncationString?: string,
            alignment?: PlaydateTextAlignment,
            font?: playdate.graphics.font,
            language?: PlaydateLanguage
        ): LuaMultiReturn<[number, number, boolean]>;

        /**
         * Important
         *
         * You must import _CoreLibs/graphics_ to use these functions.
         *
         * Same as [drawTextInRect()](https://sdk.play.date/2.5.0#f-graphics.drawTextInRect) except localized text is drawn.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.drawLocalizedTextInRect)
         *
         * @noSelf
         */
        export function drawLocalizedTextInRect(
            text: string,
            rect: playdate.geometry.rect,
            leadingAdjustment?: number,
            truncationString?: string,
            alignment?: PlaydateTextAlignment,
            font?: playdate.graphics.font,
            language?: PlaydateLanguage
        ): LuaMultiReturn<[number, number, boolean]>;

        /**
         * Important
         *
         * You must import _CoreLibs/graphics_ to use this function.
         *
         * Returns `_width_`, `_height_` which indicate the minimum size required for `_text_` to be drawn using [drawTextInRect()](https://sdk.play.date/2.5.0#f-graphics.drawTextInRect). The `_width_` returned will be less than or equal to `_maxWidth_`.
         *
         * `_font_`, if provided, will cause the text size to be calculated without bold or italic styling using the specified font.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.getTextSizeForMaxWidth)
         *
         * @noSelf
         */
        export function getTextSizeForMaxWidth(
            text: string,
            maxWidth: number,
            leadingAdjustment?: number,
            font?: playdate.graphics.font
        ): LuaMultiReturn<[number, number]>;

        /**
         * Important
         *
         * You must import _CoreLibs/graphics_ to use this function.
         *
         * Generates an image containing `_text_`. This is useful if you need to redraw the same text frequently.
         *
         * `_maxWidth_` and `_maxHeight_` specify the maximum size of the returned image.
         *
         * `_backgroundColor_`, if specified, will cause the image’s background to be one of _playdate.graphics.kColorWhite_, _playdate.graphics.kColorBlack_, or _playdate.graphics.kColorClear_.
         *
         * `_font_`, if provided, will cause the text to be drawn without bold or italic styling using the specified font.
         *
         * The remaining arguments are the same as those in [drawTextInRect()](https://sdk.play.date/2.5.0#f-graphics.drawTextInRect).
         *
         * Returns `_image_`, `_textWasTruncated_`
         *
         * `_image_` is a newly-created image containing the specified text, or nil if an image could not be created. The image’s dimensions may be smaller than `_maxWidth_`, `_maxHeight_`.
         *
         * `_textWasTruncated_` indicates if the text was truncated to fit within the specified width and height.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-graphics.imageWithText)
         *
         * @noSelf
         */
        export function imageWithText(
            text: string,
            maxWidth: number,
            maxHeight: number,
            backgroundColor?: PlaydateColor,
            leadingAdjustment?: number,
            truncationString?: string,
            alignment?: PlaydateTextAlignment,
            font?: playdate.graphics.font
        ): LuaMultiReturn<[playdate.graphics.image, boolean]>;

        namespace image {
            /**
             * Creates a new blank image of the given width and height. The image can be drawn on using [playdate.graphics.pushContext()](https://sdk.play.date/2.5.0#f-graphics.pushContext) or [playdate.graphics.lockFocus()](https://sdk.play.date/2.5.0#f-graphics.lockFocus). The optional _bgcolor_ argument is one of the color constants as used in [playdate.graphics.setColor()](https://sdk.play.date/2.5.0#f-graphics.setColor), defaulting to _kColorClear_.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.image.new)
             *
             * @noSelf
             */
            export function _new(
                width: number,
                height: number,
                bgcolor?: PlaydateColor
            ): playdate.graphics.image;

            export { _new as new };

            /**
             * Returns a [playdate.graphics.image](https://sdk.play.date/2.5.0#C-graphics.image) object from the data at _path_. If there is no file at _path_, the function returns nil and a second value describing the error.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.image.new-path)
             *
             * @noSelf
             */
            export function _new(path: string): playdate.graphics.image;

            export { _new as new };
        }

        class image {
            /**
             * Loads a new image from the data at _path_ into an already-existing image, without allocating additional memory. The image at _path_ must be of the same dimensions as the original.
             *
             * Returns _(success, \[error\])_. If the boolean _success_ is false, _error_ is also returned.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.load)
             */
            load(
                path: string
            ):
                | LuaMultiReturn<[true, undefined]>
                | LuaMultiReturn<[false, string]>;

            /**
             * Returns a new `playdate.graphics.image` that is an exact copy of the original.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.copy)
             */
            copy(): playdate.graphics.image;

            /**
             * Returns the pair (_width_, _height_)
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.getSize)
             */
            getSize(): LuaMultiReturn<[number, number]>;

            /**
             * Draws the image with its upper-left corner at location (_x_, _y_) or [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point) _p_.
             *
             * The optional _flip_ argument can be one of the following:
             *
             * *   _playdate.graphics.kImageUnflipped_: the image is drawn normally
             *
             * *   _playdate.graphics.kImageFlippedX_: the image is flipped left to right
             *
             * *   _playdate.graphics.kImageFlippedY_: the image is flipped top to bottom
             *
             * *   _playdate.graphics.kImageFlippedXY_: the image if flipped both ways; i.e., rotated 180 degrees
             *
             *
             * Alternately, one of the strings "flipX", "flipY", or "flipXY" can be used for the _flip_ argument.
             *
             * _sourceRect_, if specified, will cause only the part of the image within sourceRect to be drawn. _sourceRect_ should be relative to the image’s bounds and can be a [playdate.geometry.rect](https://sdk.play.date/2.5.0#C-geometry.rect) or four integers, (_x_, _y_, _w_, _h_), representing the rect.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.imgDraw)
             */
            draw(
                x: number,
                y: number,
                flip?: PlaydateFlip,
                sourceRect?: playdate.geometry.rect
            ): void;
            /**
             * Draws the image with its upper-left corner at location (_x_, _y_) or [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point) _p_.
             *
             * The optional _flip_ argument can be one of the following:
             *
             * *   _playdate.graphics.kImageUnflipped_: the image is drawn normally
             *
             * *   _playdate.graphics.kImageFlippedX_: the image is flipped left to right
             *
             * *   _playdate.graphics.kImageFlippedY_: the image is flipped top to bottom
             *
             * *   _playdate.graphics.kImageFlippedXY_: the image if flipped both ways; i.e., rotated 180 degrees
             *
             *
             * Alternately, one of the strings "flipX", "flipY", or "flipXY" can be used for the _flip_ argument.
             *
             * _sourceRect_, if specified, will cause only the part of the image within sourceRect to be drawn. _sourceRect_ should be relative to the image’s bounds and can be a [playdate.geometry.rect](https://sdk.play.date/2.5.0#C-geometry.rect) or four integers, (_x_, _y_, _w_, _h_), representing the rect.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.imgDraw)
             */
            draw(
                p: playdate.geometry.point,
                flip?: PlaydateFlip,
                sourceRect?: playdate.geometry.rect
            ): void;

            /**
             * Draws the image at location _(x, y)_ centered at the point within the image represented by _(ax, ay)_ in unit coordinate space. For example, values of _ax = 0.0_, _ay = 0.0_ represent the image’s top-left corner, _ax = 1.0_, _ay = 1.0_ represent the bottom-right, and _ax = 0.5_, _ay = 0.5_ represent the center of the image.
             *
             * The _flip_ argument is optional; see [`playdate.graphics.image:draw()`](https://sdk.play.date/2.5.0#m-graphics.imgDraw) for valid values.
             *
             * Important
             *
             * You must import _CoreLibs/graphics_ to use this method.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.drawAnchored)
             */
            drawAnchored(
                x: number,
                y: number,
                ax: number,
                ay: number,
                flip?: PlaydateFlip
            ): void;

            /**
             * Draws the image centered at location _(x, y)_.
             *
             * The _flip_ argument is optional; see [`playdate.graphics.image:draw()`](https://sdk.play.date/2.5.0#m-graphics.imgDraw) for valid values.
             *
             * Important
             *
             * You must import _CoreLibs/graphics_ to use this method.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.drawCentered)
             */
            drawCentered(x: number, y: number, flip?: PlaydateFlip): void;

            /**
             * Draws the image ignoring the currently-set [`drawOffset`](https://sdk.play.date/2.5.0#f-graphics.setDrawOffset).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.drawIgnoringOffset)
             */
            drawIgnoringOffset(x: number, y: number, flip?: PlaydateFlip): void;
            /**
             * Draws the image ignoring the currently-set [`drawOffset`](https://sdk.play.date/2.5.0#f-graphics.setDrawOffset).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.drawIgnoringOffset)
             */
            drawIgnoringOffset(
                p: playdate.geometry.point,
                flip?: PlaydateFlip
            ): void;

            /**
             * Erases the contents of the image, setting all pixels to white if _color_ is _playdate.graphics.kColorWhite_, black if it’s _playdate.graphics.kColorBlack_, or clear if it’s _playdate.graphics.kColorClear_. If the image is cleared to black or white, the mask (if it exists) is set to fully opaque. If the image is cleared to kColorClear and the image doesn’t have a mask, a mask is added to it.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.clear)
             */
            clear(color: PlaydateColor): void;

            /**
             * Returns _playdate.graphics.kColorWhite_ if the image is white at (_x_, _y_), _playdate.graphics.kColorBlack_ if it’s black, or _playdate.graphics.kColorClear_ if it’s transparent.
             *
             * Note
             *
             * The upper-left pixel of the image is at coordinate _(0, 0)_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.sample)
             */
            sample(
                x: number,
                y: number
            ): Omit<PlaydateColor, PlaydateColor.XOR>;

            /**
             * Draws this image centered at point _(x,y)_ at (clockwise) _angle_ degrees, scaled by optional argument _scale_, with an optional separate scaling for the y axis.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.drawRotated)
             */
            drawRotated(
                x: number,
                y: number,
                angle: number,
                scale?: number,
                yscale?: number
            ): void;

            /**
             * Returns a new image containing this image rotated by (clockwise) _angle_ degrees, scaled by optional argument _scale_, with an optional separate scaling for the y axis.
             *
             * Caution
             *
             * Unless rotating by a multiple of 180 degrees, the new image will have different dimensions than the original.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.rotatedImage)
             */
            rotatedImage(
                angle: number,
                scale?: number,
                yscale?: number
            ): playdate.graphics.image;

            /**
             * Draws this image with its upper-left corner at point _(x,y)_, scaled by amount _scale_, with an optional separate scaling for the y axis.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.drawScaled)
             */
            drawScaled(
                x: number,
                y: number,
                scale: number,
                yscale?: number
            ): void;

            /**
             * Returns a new image containing this image scaled by amount _scale_, with an optional separate scaling for the y axis.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.scaledImage)
             */
            scaledImage(
                scale: number,
                yscale?: number
            ): playdate.graphics.image;

            /**
             * Draws this image centered at point _(x,y)_ with the [transform](https://sdk.play.date/2.5.0#C-geometry.affineTransform) _xform_ applied.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.drawWithTransform)
             */
            drawWithTransform(
                xform: playdate.geometry.affineTransformTransform,
                x: number,
                y: number
            ): void;

            /**
             * Returns a new image containing the image with the [transform](https://sdk.play.date/2.5.0#C-geometry.affineTransform) _xform_ applied.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.transformedImage)
             */
            transformedImage(
                xform: playdate.geometry.affineTransformTransform
            ): playdate.graphics.image;

            /**
             * Draws the image as if it’s mapped onto a tilted plane, transforming the target coordinates to image coordinates using an affine transform:
             *
             * x' = dxx \* x + dyx \* y + dx
             * y' = dxy \* x + dyy \* y + dy
             *
             * *   _x, y, width, height_: The rectangle to fill
             *
             * *   _centerx, centery_: The point in the above rectangle \[in (0,1)x(0,1) coordinates\] for the center of the transform
             *
             * *   _dxx, dyx, dxy, dyy, dx, dy_: Defines an affine transform from geometry coordinates to image coordinates
             *
             * *   _z_: The distance from the viewer to the target plane — lower z means more exaggerated perspective
             *
             * *   _tiltAngle_: The tilt of the target plane about the x axis, in degrees
             *
             * *   _tile_: A boolean, indicating whether the image is tiled on the target plane
             *
             *
             * The _Mode7Driver_ demo in the _/Examples_ folder of the SDK demonstrates the usage of this function.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.drawSampled)
             */
            drawSampled(
                x: number,
                y: number,
                width: number,
                height: number,
                centerx: number,
                centery: number,
                dxx: number,
                dyx: number,
                dxy: number,
                dyy: number,
                dx: number,
                dy: number,
                z: number,
                tiltAngle: number,
                tile: number
            ): void;

            /**
             * Sets the image’s mask to a copy of _maskImage_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.setMaskImage)
             */
            setMaskImage(maskImage: playdate.graphics.image): void;

            /**
             * If the image has a mask, returns the mask as a separate image. Otherwise, returns `nil`.
             *
             * Important
             *
             * The returned image references the original’s data, so drawing into this image alters the original image’s mask.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.getMaskImage)
             */
            getMaskImage(): playdate.graphics.image;

            /**
             * Adds a mask to the image if it doesn’t already have one. If _opaque_ is `true` or not specified, the image mask applied will be completely white, so the image will be entirely opaque. If _opaque_ is `false`, the mask will be completely black, so the image will be entirely transparent.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.addMask)
             */
            addMask(opaque?: boolean): void;

            /**
             * Removes the mask from the image if it has one.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.removeMask)
             */
            removeMask(): void;

            /**
             * Returns _true_ if the image has a mask.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.hasMask)
             */
            hasMask(): boolean;

            /**
             * Erases the contents of the image’s mask, so that the image is entirely opaque if _opaque_ is 1, transparent otherwise. This function has no effect if the image doesn’t have a mask.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.clearMask)
             */
            clearMask(opaque?: number): 1 | 0;

            /**
             * Tiles the image into the given rectangle, using either listed dimensions or a [`playdate.geometry.rect`](https://sdk.play.date/2.5.0#C-geometry.rect) object, and the optional flip style.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.drawTiled)
             */
            drawTiled(
                x: number,
                y: number,
                width: number,
                height: number,
                flip?: PlaydateFlip
            ): void;
            /**
             * Tiles the image into the given rectangle, using either listed dimensions or a [`playdate.geometry.rect`](https://sdk.play.date/2.5.0#C-geometry.rect) object, and the optional flip style.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.drawTiled)
             */
            drawTiled(rect: playdate.geometry.rect, flip?: PlaydateFlip): void;

            /**
             * Draws a blurred version of the image at (_x_, _y_).
             *
             * *   _radius_: A bigger radius means a more blurred result. Processing time is independent of the radius.
             *
             * *   _numPasses_: A box blur is used to blur the image. The more passes, the more closely the blur approximates a gaussian blur. However, higher values will take more time to process.
             *
             * *   _ditherType_: The algorithm to use when blurring the image, must be one of the values listed in [`playdate.graphics.image:blurredImage()`](https://sdk.play.date/2.5.0#m-graphics.image.blurredImage)
             *
             * *   _flip_: optional; see [`playdate.graphics.image:draw()`](https://sdk.play.date/2.5.0#m-graphics.imgDraw) for valid values.
             *
             * *   _xPhase_, _yPhase_: optional; integer values that affect the appearance of _playdate.graphics.image.kDitherTypeDiagonalLine_, _playdate.graphics.image.kDitherTypeVerticalLine_, _playdate.graphics.image.kDitherTypeHorizontalLine_, _playdate.graphics.image.kDitherTypeScreen_, _playdate.graphics.image.kDitherTypeBayer2x2_, _playdate.graphics.image.kDitherTypeBayer4x4_, and _playdate.graphics.image.kDitherTypeBayer8x8_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.drawBlurred)
             */
            drawBlurred(
                x: number,
                y: number,
                radius: number,
                numPasses: number,
                ditherType: number,
                flip?: PlaydateFlip,
                xPhase?: number,
                yPhase?: number
            ): void;

            /**
             * Returns a blurred copy of the caller.
             *
             * *   _radius_: A bigger radius means a more blurred result. Processing time is independent of the radius.
             *
             * *   _numPasses_: A box blur is used to blur the image. The more passes, the more closely the blur approximates a gaussian blur. However, higher values will take more time to process.
             *
             * *   _ditherType_: The original image is blurred into a greyscale image then dithered back to 1-bit using one of the following dithering algorithms:
             *
             *     *   _playdate.graphics.image.kDitherTypeNone_
             *
             *     *   _playdate.graphics.image.kDitherTypeDiagonalLine_
             *
             *     *   _playdate.graphics.image.kDitherTypeVerticalLine_
             *
             *     *   _playdate.graphics.image.kDitherTypeHorizontalLine_
             *
             *     *   _playdate.graphics.image.kDitherTypeScreen_
             *
             *     *   _playdate.graphics.image.kDitherTypeBayer2x2_
             *
             *     *   _playdate.graphics.image.kDitherTypeBayer4x4_
             *
             *     *   _playdate.graphics.image.kDitherTypeBayer8x8_
             *
             *     *   _playdate.graphics.image.kDitherTypeFloydSteinberg_
             *
             *     *   _playdate.graphics.image.kDitherTypeBurkes_
             *
             *     *   _playdate.graphics.image.kDitherTypeAtkinson_
             *
             *
             * *   _padEdges_: Boolean indicating whether the edges of the images should be padded to accommodate the blur radius. Defaults to false.
             *
             * *   _xPhase_, _yPhase_: optional; integer values that affect the appearance of _playdate.graphics.image.kDitherTypeDiagonalLine_, _playdate.graphics.image.kDitherTypeVerticalLine_, _playdate.graphics.image.kDitherTypeHorizontalLine_, _playdate.graphics.image.kDitherTypeScreen_, _playdate.graphics.image.kDitherTypeBayer2x2_, _playdate.graphics.image.kDitherTypeBayer4x4_, and _playdate.graphics.image.kDitherTypeBayer8x8_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.blurredImage)
             */
            blurredImage(
                radius: number,
                numPasses: number,
                ditherType: number,
                padEdges?: number,
                xPhase?: number,
                yPhase?: number
            ): playdate.graphics.image;

            /**
             * Draws a partially transparent image with its upper-left corner at location (_x_, _y_)
             *
             * *   _alpha_: The alpha value used to draw the image, with 1 being fully opaque, and 0 being completely transparent.
             *
             * *   _ditherType_: The caller is faded using one of the dithering algorithms listed in [`playdate.graphics.image:blurredImage()`](https://sdk.play.date/2.5.0#m-graphics.image.blurredImage)
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.drawFaded)
             */
            drawFaded(
                x: number,
                y: number,
                alpha: number,
                ditherType: number
            ): void;

            /**
             * Returns a faded version of the caller.
             *
             * *   _alpha_: The alpha value assigned to the caller, in the range 0.0 - 1.0. If an image mask already exists it is multiplied by _alpha_.
             *
             * *   _ditherType_: The caller is faded into a greyscale image and dithered with one of the dithering algorithms listed in [playdate.graphics.image:blurredImage()](https://sdk.play.date/2.5.0#m-graphics.image.blurredImage)
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.fadedImage)
             */
            fadedImage(
                alpha: number,
                ditherType: number
            ): playdate.graphics.image;

            /**
             * If _flag_ is true, the image will be drawn with its colors inverted. If the image is being used as a stencil, its behavior is reversed: pixels are drawn where the stencil is black, nothing is drawn where the stencil is white.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.setInverted)
             */
            setInverted(flag: boolean): void;

            /**
             * Returns a color-inverted copy of the caller.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.invertedImage)
             */
            invertedImage(): playdate.graphics.image;

            /**
             * Returns an image that is a blend between the caller and _image_.
             *
             * *   _image_: the playdate.graphics.image to be blended with the caller.
             *
             * *   _alpha_: The alpha value assigned to the caller. _image_ will have an alpha of (1 - _alpha_).
             *
             * *   _ditherType_: The caller and _image_ are blended into a greyscale image and dithered with one of the dithering algorithms listed in [`playdate.graphics.image:blurredImage()`](https://sdk.play.date/2.5.0#m-graphics.image.blurredImage)
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.blendWithImage)
             */
            blendWithImage(
                image: playdate.graphics.image,
                alpha: number,
                ditherType: PlaydateDitherType
            ): playdate.graphics.image;

            /**
             * Returns an image created by applying a VCR pause effect to the calling image.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.image.vcrPauseFilterImage)
             */
            vcrPauseFilterImage(): playdate.graphics.image;
        }

        namespace nineSlice {
            /**
             * Returns a new 9 slice image from the image at imagePath with the stretchable region defined by other parameters. The arguments represent the origin and dimensions of the innermost ("center") slice.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.nineSlice.new)
             *
             * @noSelf
             */
            export function _new(
                imagePath: string,
                innerX: number,
                innerY: number,
                innerWidth: number,
                innerHeight: number
            ): playdate.graphics.nineSlice;

            export { _new as new };
        }

        class nineSlice {
            /**
             * Returns the size of the 9 slice image as a pair _(width, height)_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.nineSlice.getSize)
             */
            getSize(): LuaMultiReturn<[number, number]>;

            /**
             * Returns the minimum size of the 9 slice image as a pair _(width, height)_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.nineSlice.getMinSize)
             */
            getMinSize(): LuaMultiReturn<[number, number]>;

            /**
             * Draws the 9 slice image at the desired coordinates by stretching the defined region to achieve the width and height inputs.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.nineSlice.drawInRect)
             */
            drawInRect(
                x: number,
                y: number,
                width: number,
                height: number
            ): void;
            /**
             * Draws the 9 slice image at the desired coordinates by stretching the defined region to achieve the width and height inputs.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.nineSlice.drawInRect)
             */
            drawInRect(rect: playdate.geometry.rect): void;
        }

        namespace animation {
            namespace loop {
                /**
                 * Creates a new animation object.
                 *
                 * *   **_imageTable_** should be a [`playdate.graphics.imagetable`](https://sdk.play.date/2.5.0#C-graphics.imagetable), or nil.
                 *
                 *
                 * The following properties can be read or set directly, and have these defaults:
                 *
                 * *   **_delay_** : the value of _delay_, if passed, or 100ms (the delay before moving to the next frame)
                 *
                 * *   **_startFrame_** : 1 (the value the object resets to when the loop completes)
                 *
                 * *   **_endFrame_** : the number of images in _imageTable_ if passed, or 1 (the last frame value in the loop)
                 *
                 * *   **_frame_** : 1 (the current frame counter)
                 *
                 * *   **_step_** : 1 (the value by which frame increments)
                 *
                 * *   **_shouldLoop_** : the value of _shouldLoop_, if passed, or true. (whether the object loops when it completes)
                 *
                 * *   **_paused_** : false (paused loops don’t change their frame value)
                 *
                 * [Read more](https://sdk.play.date/2.5.0#f-graphics.animation.loop.new)
                 *
                 * @noSelf
                 */
                export function _new(
                    delay?: number,
                    imageTable?: playdate.graphics.imagetable,
                    shouldLoop?: boolean
                ): playdate.graphics.animation.loop;

                export { _new as new };
            }

            class loop {
                /**
                 * Draw’s the loop’s current image at _x_, _y_.
                 *
                 * The _flip_ argument is optional; see [`playdate.graphics.image:draw()`](https://sdk.play.date/2.5.0#m-graphics.imgDraw) for valid values.
                 *
                 * [Read more](https://sdk.play.date/2.5.0#m-graphics.animation.loop.draw)
                 */
                draw(x: number, y: number, flip?: PlaydateFlip): void;

                /**
                 * Returns a [`playdate.graphics.image`](https://sdk.play.date/2.5.0#C-graphics.image) from the caller’s _imageTable_ if it exists. The image returned will be at the imageTable’s index that matches the caller’s _frame_.
                 *
                 * [Read more](https://sdk.play.date/2.5.0#m-graphics.animation.loop.image)
                 */
                image(): playdate.graphics.image;

                /**
                 * Returns false if the loop has passed its last frame and does not loop.
                 *
                 * [Read more](https://sdk.play.date/2.5.0#m-graphics.animation.loop.isValid)
                 */
                isValid(): boolean;

                /**
                 * Sets the [`playdate.graphics.imagetable`](https://sdk.play.date/2.5.0#C-graphics.imagetable) to be used for this animation loop, and sets the loop’s endFrame property to #imageTable.
                 *
                 * [Read more](https://sdk.play.date/2.5.0#m-graphics.animation.loop.setImageTable)
                 */
                setImageTable(imageTable: playdate.graphics.imagetable): void;
            }

            namespace blinker {
                /**
                 * Creates a new blinker object. Check the object’s `on` property to determine whether the blinker is on (`true`) or off (`false`). The default properties are:
                 *
                 * *   _onDuration_: 200 (the number of milliseconds the blinker is "on")
                 *
                 * *   _offDuration_: 200 (the number of milliseconds the blinker is "off")
                 *
                 * *   _loop_: false (should the blinker restart after completing)
                 *
                 * *   _cycles_: 6 (the number of changes the blinker goes through before it’s complete)
                 *
                 * *   _default_: true (the state the blinker will start in. **Note:** if default is `true`, `blinker.on` will return `true` when the blinker is in its _onDuration_ phase. If default is `false`, `blinker.on` will return `false` when the blinker is in its _onDuration_ phase.)
                 *
                 *
                 * Other informative properties:
                 *
                 * *   _counter_: Read this property to see which cycle the blinker is on (counts from _n_ down to zero)
                 *
                 * *   _on_: Read this property to determine the current state of the blinker. The blinker always starts in the state specified by the `default` property.
                 *
                 * *   _running_: Read this property to see if the blinker is actively running
                 *
                 * [Read more](https://sdk.play.date/2.5.0#f-graphics.animation.blinker.new)
                 *
                 * @noSelf
                 */
                export function _new(
                    onDuration: number = 200,
                    offDuration: number = 200,
                    loop: boolean = false,
                    cycles: number = 6,
                    _default: boolean = true
                ): playdate.graphics.animation.blinker;

                export { _new as new };

                /**
                 * Updates the state of all valid blinkers by calling [:update()](https://sdk.play.date/2.5.0#m-graphics.animation.blinker.update) on each.
                 *
                 * Important
                 *
                 * If you intend to use blinkers, be sure to call `:updateAll()` once a cycle, ideally in your game’s [`playdate.update()`](https://sdk.play.date/2.5.0#c-update) function.
                 *
                 * [Read more](https://sdk.play.date/2.5.0#f-graphics.animation.blinker.updateAll)
                 *
                 * @noSelf
                 */
                export function updateAll(): void;

                /**
                 * Stops all blinkers.
                 *
                 * [Read more](https://sdk.play.date/2.5.0#f-graphics.animation.blinker.stopAll)
                 *
                 * @noSelf
                 */
                export function stopAll(): void;
            }

            class blinker {
                /**
                 * Updates the caller’s state.
                 *
                 * [Read more](https://sdk.play.date/2.5.0#m-graphics.animation.blinker.update)
                 */
                update(): void;

                /**
                 * Starts a blinker if it’s not running. Pass values for any property values you wish to modify.
                 *
                 * [Read more](https://sdk.play.date/2.5.0#m-graphics.animation.blinker.start)
                 */
                start(
                    onDuration: number = 200,
                    offDuration: number = 200,
                    loop: boolean = false,
                    cycles: number = 6,
                    _default: boolean = true
                ): void;

                /**
                 * Starts a blinker if it’s not running and sets its `loop` property to true. Equivalent to calling `playdate.graphics.animation.blinker:start(nil, nil, true)`
                 *
                 * [Read more](https://sdk.play.date/2.5.0#m-graphics.animation.blinker.startLoop)
                 */
                startLoop(): void;

                /**
                 * Stops a blinker if it’s running, returning the blinker’s `on` properly to the default value.
                 *
                 * [Read more](https://sdk.play.date/2.5.0#m-graphics.animation.blinker.stop)
                 */
                stop(): void;

                /**
                 * Flags the caller for removal from the global list of blinkers
                 *
                 * [Read more](https://sdk.play.date/2.5.0#m-graphics.animation.blinker.remove)
                 */
                remove(): void;
            }
        }

        namespace animator {
            /**
             * Animates between two number or [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point) values.
             *
             * _duration_ is the total time of the animation in milliseconds.
             *
             * _startValue_ and _endValue_ should be either numbers or [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point)
             *
             * _easingFunction_, if supplied, should be a value from [playdate.easingFunctions](https://sdk.play.date/2.5.0#M-easingFunctions). If your easing function requires additional variables _s_, _a_, or _p_, set them on the animator directly after creation. For example:
             *
             *     local a = playdate.graphics.animator.new(1000, 0, 100, playdate.easingFunctions.inBack)
             *     a.s = 1.9
             *
             * _startTimeOffset_, if supplied, will shift the start time of the animation by the specified number of milliseconds. (If positive, the animation will be delayed. If negative, the animation will effectively have started before the moment the animator is instantiated.)
             *
             * Example: Using an animator to animate movement
             *
             *     -- You can copy and paste this example directly as your main.lua file to see it in action
             *     import "CoreLibs/graphics"
             *     import "CoreLibs/animator"
             *
             *     -- We'll be demonstrating how to use an animator to animate a square moving across the screen
             *     local square = playdate.graphics.image.new(20, 20, playdate.graphics.kColorBlack)
             *
             *     -- 1000ms, or 1 second
             *     local animationDuration = 1000
             *     -- We're animating from the left to the right of the screen
             *     local startX, endX = -20, 400
             *     -- Setting an easing function to get a nice, smooth movement
             *     local easingFunction = playdate.easingFunctions.inOutCubic
             *     local animator = playdate.graphics.animator.new(animationDuration, startX, endX, easingFunction)
             *     animator.repeatCount = -1 -- Make animator repeat forever
             *
             *     function playdate.update()
             *         -- Clear the screen
             *         playdate.graphics.clear()
             *
             *         -- By using :currentValue() as the x value, the square follows along with the animation
             *         square:draw(animator:currentValue(), 120)
             *     end
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.animator.new1)
             *
             * @noSelf
             */
            export function _new<
                TSubject extends number | playdate.geometry.point
            >(
                duration: number,
                startValue: TSubject,
                endValue: TSubect,
                easingFunction?: PlaydateEasingFunction,
                startTimeOffset?: number
            ): playdate.graphics.animator<TSubject>;

            export { _new as new };

            /**
             * Creates a new Animator that will animate along the provided [playdate.geometry.lineSegment](https://sdk.play.date/2.5.0#C-geometry.lineSegment)
             *
             * Example: Using an animator to animate along a line
             *
             *     -- You can copy and paste this example directly as your main.lua file to see it in action
             *     import "CoreLibs/graphics"
             *     import "CoreLibs/animator"
             *
             *     -- We'll be demonstrating how to use an animator to animate a square moving across the screen
             *     local square = playdate.graphics.image.new(20, 20, playdate.graphics.kColorBlack)
             *
             *     -- 1000ms, or 1 second
             *     local animationDuration = 1000
             *     -- We're animating from the top left to the bottom right of the screen
             *     local line = playdate.geometry.lineSegment.new(0, 0, 400, 240)
             *     local animator = playdate.graphics.animator.new(animationDuration, line)
             *
             *     function playdate.update()
             *         -- Clear the screen
             *         playdate.graphics.clear()
             *
             *         -- We can use :currentValue() directly, as it returns a point
             *         square:draw(animator:currentValue())
             *     end
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.animator.new2)
             *
             * @noSelf
             */
            export function _new(
                duration: number,
                lineSegment: playdate.geometry.lineSegmentnt,
                easingFunction?: PlaydateEasingFunction,
                startTimeOffset?: number
            ): playdate.graphics.animator;

            export { _new as new };

            /**
             * Creates a new Animator that will animate along the provided [playdate.geometry.arc](https://sdk.play.date/2.5.0#C-geometry.arc)
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.animator.new3)
             *
             * @noSelf
             */
            export function _new(
                duration: number,
                arc: playdate.geometry.arc,
                easingFunction?: PlaydateEasingFunction,
                startTimeOffset?: number
            ): playdate.graphics.animator;

            export { _new as new };

            /**
             * Creates a new Animator that will animate along the provided [playdate.geometry.polygon](https://sdk.play.date/2.5.0#C-geometry.polygon)
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.animator.new4)
             *
             * @noSelf
             */
            export function _new(
                duration: number,
                polygon: playdate.geometry.polygon,
                easingFunction?: PlaydateEasingFunction,
                startTimeOffset?: number
            ): playdate.graphics.animator;

            export { _new as new };

            /**
             * Creates a new Animator that will animate along each of the items in the _parts_ array in order, which should be comprised of [playdate.geometry.lineSegment](https://sdk.play.date/2.5.0#C-geometry.lineSegment), [playdate.geometry.arc](https://sdk.play.date/2.5.0#C-geometry.arc), or [playdate.geometry.polygon](https://sdk.play.date/2.5.0#C-geometry.polygon) objects.
             *
             * _durations_ should be an array of durations, one for each item in _parts_.
             *
             * _easingFunctions_ should be an array of [playdate.easingFunctions](https://sdk.play.date/2.5.0#M-easingFunctions), one for each item in _parts_.
             *
             * Note
             *
             * By default, animators do not repeat. If you would like them to, set the animator’s _repeatCount_ property to the number of times the animation should repeat. It can be set to any positive number or -1 to indicate the animation should repeat forever. Note that a repeat count of 1 means the animation will play twice - once for the initial animation plus one repeat.
             *
             * Example: Using an animator with parts
             *
             *     -- You can copy and paste this example directly as your main.lua file to see it in action
             *     import "CoreLibs/graphics"
             *     import "CoreLibs/animator"
             *
             *     -- We'll be demonstrating how to animate something with parts
             *     local square = playdate.graphics.image.new(20, 20, playdate.graphics.kColorBlack)
             *
             *     -- First part will take 3 seconds, second part will take 1, and third part will take 2
             *     local animationDurations = {3000, 1000, 2000}
             *     -- We'll first animate along a line, then an arc, and then a polygon
             *     local animationParts = {
             *         playdate.geometry.lineSegment.new(0, 0, 200, 80),
             *         playdate.geometry.arc.new(200, 120, 40, 0, 180),
             *         playdate.geometry.polygon.new(200, 160, 300, 90, 390, 230)
             *     }
             *     -- We must set the easing functions for each part, and they can all be different
             *     local animationEasingFunctions = {
             *         playdate.easingFunctions.outQuart,
             *         playdate.easingFunctions.inOutCubic,
             *         playdate.easingFunctions.outBounce
             *     }
             *
             *     -- To animate by parts, each argument must be arrays of equal length
             *     local animator = playdate.graphics.animator.new(animationDurations, animationParts, animationEasingFunctions)
             *
             *     function playdate.update()
             *         -- Clear the screen
             *         playdate.graphics.clear()
             *
             *         -- We can use :currentValue() directly, as it returns a point
             *         square:draw(animator:currentValue())
             *     end
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.animator.new5)
             *
             * @noSelf
             */
            export function _new(
                durations: number,
                parts: (
                    | playdate.geometry.lineSegmentnt
                    | playdate.geometry.arc
                    | playdate.geometry.polygon
                )[],
                easingFunctions: PlaydateEasingFunction[],
                startTimeOffset?: number
            ): playdate.graphics.animator;

            export { _new as new };
        }

        class animator<TSubject extends number | playdate.geometry.point> {
            /**
             * Returns the current value of the animation, which will be either a number or a [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point), depending on the type of animator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.animator.currentValue)
             */
            currentValue(): TSubject;

            /**
             * Returns the value of the animation at the given number of milliseconds after the start time. The value will be either a number or a [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point), depending on the type of animator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.animator.valueAtTime)
             */
            valueAtTime(time: number): TSubject;

            /**
             * Returns the current progress of the animation as a value from 0 to 1.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.animator.progress)
             */
            progress(): number;

            /**
             * Resets the animation, setting its start time to the current time, and changes the animation’s duration if a new duration is given.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.animator.reset)
             */
            reset(duration?: number): void;

            /**
             * Returns true if the animation is completed. Only returns true if this function or [`currentValue()`](https://sdk.play.date/2.5.0#m-graphics.animator.currentValue) has been called since the animation ended in order to allow animations to fully finish before true is returned.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.animator.ended)
             */
            ended(): void;

            /**
             * For [easing functions](https://sdk.play.date/2.5.0#M-easingFunctions) that take additional amplitude (such as _inOutElastic_), set these values on animator instances to the desired values.
             *
             * [Read more](https://sdk.play.date/2.5.0#v-graphics.animator.easingAmplitude)
             */
            easingAmplitude: number;
            /**
             * For [easing functions](https://sdk.play.date/2.5.0#M-easingFunctions) that take additional period arguments (such as _inOutElastic_), set these values on animator instances to the desired values.
             *
             * [Read more](https://sdk.play.date/2.5.0#v-graphics.animator.easingPeriod)
             */
            easingPeriod: number;
            /**
             * Indicates the number of times after the initial animation the animator should repeat; i.e., if repeatCount is set to 2, the animation will play through 3 times.
             *
             * [Read more](https://sdk.play.date/2.5.0#v-graphics.animator.repeatCount)
             */
            repeatCount: number;
            /**
             * If set to true, after the animation reaches the end, it runs in reverse from the end to the start. The time to complete both the forward and reverse will be _duration_ x 2. Defaults to false.
             *
             * [Read more](https://sdk.play.date/2.5.0#v-graphics.animator.reverses)
             */
            reverses: number;
        }

        namespace imagetable {
            /**
             * Returns a [playdate.graphics.imagetable](https://sdk.play.date/2.5.0#C-graphics.imagetable) object from the data at _path_. If there is no file at _path_, the function returns nil and a second value describing the error. If the file at _path_ is an animated GIF, successive frames of the GIF will be loaded as consecutive bitmaps in the imagetable. Any timing data in the animated GIF will be ignored.
             *
             * Important
             *
             * To load a **matrix** image table defined in `frames-table-16-16.png`, you call `playdate.graphics.imagetable.new("frames")`.
             *
             * Important
             *
             * To load a **sequential** image table defined with the files `frames-table-1.png`, `frames-table-2.png`, etc., you call `playdate.graphics.imagetable.new("frames")`.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.imagetable.new)
             *
             * @noSelf
             */
            export function _new(path: string): playdate.graphics.imagetable;

            export { _new as new };

            /**
             * Returns an empty image table for loading images into via [imagetable:load()](https://sdk.play.date/2.5.0#m-graphics.imagetable.load) or setting already-loaded images into with [imagetable:setImage()](https://sdk.play.date/2.5.0#m-graphics.imagetable.setImage). If set, _cellsWide_ is used to locate images by x,y position. The optional _cellSize_ argument gives the allocation size for the images, if [load()](https://sdk.play.date/2.5.0#m-graphics.imagetable.load) will be used. (This is a weird technical detail, so ask us if you need guidance here.)
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.imagetable.new-alloc)
             *
             * @noSelf
             */
            export function _new(
                count: number,
                cellsWide?: number,
                cellSize?: any
            ): playdate.graphics.imagetable;

            export { _new as new };
        }

        class imagetable {
            /**
             * Returns the _n_\-th [playdate.graphics.image](https://sdk.play.date/2.5.0#C-graphics.image) in the table (ordering left-to-right, top-to-bottom). The first image is at index 1. If .n\_ or (_x_,_y_) is out of bounds, the function returns nil. See also [imagetable\[n\]](https://sdk.play.date/2.5.0#m-graphics.imagetable.__len).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.imagetable.getImage-n)
             */
            getImage(n: number): playdate.graphics.image;
            /**
             * Returns the image in cell (_x_,_y_) in the original bitmap. The first image is at index 1. If _n_ or (_x_,_y_) is out of bounds, the function returns nil. See also [imagetable\[n\]](https://sdk.play.date/2.5.0#m-graphics.imagetable.__len).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.imagetable.getImage-xy)
             */
            getImage(x: number, y: number): playdate.graphics.image | null;

            /**
             * Sets the image at slot _n_ in the image table by creating a reference to the data in _image_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.imagetable.setImage)
             */
            setImage(n: number, image: playdate.graphics.image): void;

            /**
             * Loads a new image table from the data at _path_ into an already-existing image table, without allocating additional memory. The image table at _path_ must contain images of the same dimensions as the previous.
             *
             * Returns `(success, [error])`. If the boolean `success` is false, `error` is also returned.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.imagetable.load)
             */
            load(
                path: string
            ):
                | LuaMultiReturn<[true, undefined]>
                | LuaMultiReturn<[false, string]>;

            /**
             * Returns the number of images in the table. See also [#imagetable](https://sdk.play.date/2.5.0#m-graphics.imagetable.__len).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.imagetable.getLength)
             */
            getLength(): number;

            /**
             * Returns the pair (_cellsWide_, _cellsHigh_).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.imagetable.getSize)
             */
            getSize(): LuaMultiReturn<[number, number]>;

            /**
             * Equivalent to `graphics.imagetable:getImage(n):draw(x,y,[flip])`.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.imagetable.drawImage)
             */
            drawImage(
                n: number,
                x: number,
                y: number,
                flip?: PlaydateFlip
            ): void;
        }

        namespace tilemap {
            /**
             * Creates a new tilemap object.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.tilemap.new)
             *
             * @noSelf
             */
            export function _new(): playdate.graphics.tilemap;

            export { _new as new };
        }

        class tilemap {
            /**
             * Sets the tilemap’s [playdate.graphics.imagetable](https://sdk.play.date/2.5.0#C-graphics.imagetable) to _table_, a [playdate.graphics.imagetable](https://sdk.play.date/2.5.0#C-graphics.imagetable).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.tilemap.setImageTable)
             */
            setImageTable(table: playdate.graphics.imagetable): void;

            /**
             * Sets the tilemap’s width to _width_, then populates the tilemap with _data_, which should be a flat, one-dimensional array-like table containing index values to the [tilemap’s imagetable](https://sdk.play.date/2.5.0#m-graphics.tilemap.setImageTable).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.tilemap.setTiles)
             */
            setTiles(data: number[], width: number): void;

            /**
             * Returns _data_, _width_
             * _data_ is a flat, one-dimensional array-like table containing index values to the [tilemap’s imagetable](https://sdk.play.date/2.5.0#m-graphics.tilemap.setImageTable).
             * _width_ is the width of the tile map, in number of tiles.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.tilemap.getTiles)
             */
            getTiles(): LuaMultiReturn<[number[], number]>;

            /**
             * Draws the tile map at screen coordinate (_x_, _y_).
             *
             * _sourceRect_, if specified, will cause only the part of the tilemap within sourceRect to be drawn. _sourceRect_ should be relative to the tilemap’s bounds and can be a [playdate.geometry.rect](https://sdk.play.date/2.5.0#C-geometry.rect) or four integers, (_x_, _y_, _w_, _h_), representing the rect.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.tilemap.draw)
             */
            draw(
                x: number,
                y: number,
                sourceRect?: playdate.geometry.rect
            ): void;

            /**
             * Draws the tilemap ignoring the currently-set [`drawOffset`](https://sdk.play.date/2.5.0#f-graphics.setDrawOffset).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.tilemap.drawIgnoringOffset)
             */
            drawIgnoringOffset(
                x: number,
                y: number,
                sourceRect?: playdate.geometry.rect
            ): void;

            /**
             * Sets the index of the tile at tilemap position (_x_, _y_). _index_ is the (1-based) index of the image in the tilemap’s [playdate.graphics.imagetable](https://sdk.play.date/2.5.0#C-graphics.imagetable).
             *
             * Note
             *
             * Tilemaps and imagetables, like Lua arrays, are 1-based, not 0-based. `tilemap:setTileAtPosition(1, 1, 2)` will set the index of the tile in the top-leftmost position to 2.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.tilemap.setTileAtPosition)
             */
            setTileAtPosition(x: number, y: number, index: number): void;

            /**
             * Returns the image index of the tile at the given _x_ and _y_ coordinate. If _x_ or _y_ is out of bounds, returns nil.
             *
             * Note
             *
             * Tilemaps and imagetables, like Lua arrays, are 1-based, not 0-based. `tilemap:getTileAtPosition(1, 1)` will return the index of the top-leftmost tile.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.tilemap.getTileAtPosition)
             */
            getTileAtPosition(x: number, y: number): number | null;

            /**
             * Sets the tilemap’s width and height, in number of tiles.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.tilemap.setSize)
             */
            setSize(width: number, height: number): void;

            /**
             * Returns the size of the tile map, in tiles, as a pair, (_width_, _height_).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.tilemap.getSize)
             */
            getSize(): LuaMultiReturn<[number, number]>;

            /**
             * Returns the size of the tilemap in pixels; that is, the size of the image multiplied by the number of rows and columns in the map. Returns multiple values (_width_, _height_).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.tilemap.getPixelSize)
             */
            getPixelSize(): LuaMultiReturn<[number, number]>;

            /**
             * Returns multiple values (_width_, _height_), the pixel width and height of an individual tile.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.tilemap.getTileSize)
             */
            getTileSize(): LuaMultiReturn<[number, number]>;

            /**
             * This function returns an array of [playdate.geometry.rect](https://sdk.play.date/2.5.0#C-geometry.rect) objects that describe the areas of the tilemap that should trigger collisions. You can also think of them as the "impassable" rects of your tilemap. These rects will be in tilemap coordinates, not pixel coordinates.
             *
             * _emptyIDs_ is an array that contains the tile IDs of "empty" (or "passable") tiles in the tilemap — in other words, tile IDs that should not trigger a collision. Tiles with default IDs of 0 are treated as empty by default, so you do not need to include 0 in the array.
             *
             * For example, if you have a tilemap describing terrain, where tile ID 1 represents grass the player can walk over, and tile ID 2 represents mountains that the player can’t cross, you’d pass an array containing just the value 1. You’ll get a back an array of a minimal number of rects describing the areas where there are mountain tiles.
             *
             * You can then pass each of those rects into [playdate.graphics.sprite.addEmptyCollisionSprite()](https://sdk.play.date/2.5.0#f-graphics.sprite.addEmptyCollisionSprite) to add an empty (invisible) sprite into the scene for the built-in collision detection methods. In this example, collide rects would be added around mountain tiles but not grass tiles.
             *
             * Alternatively, instead of calling getCollisionRects() at all, you can use the convenience function [playdate.graphics.sprite.addWallSprites()](https://sdk.play.date/2.5.0#f-graphics.sprite.addWallSprites), which is effectively a shortcut for calling getCollisionRects() and passing all the resulting rects to [addEmptyCollisionSprite()](https://sdk.play.date/2.5.0#f-graphics.sprite.addEmptyCollisionSprite).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.tilemap.getCollisionRects)
             */
            getCollisionRects(emptyIDs: number[]): playdate.geometry.rect[];
        }

        namespace sprite {
            /**
             * This class method (note the "." syntax rather than ":") returns a new sprite object. A previously-loaded [image](https://sdk.play.date/2.5.0#C-graphics.image) or [tilemap](https://sdk.play.date/2.5.0#C-graphics.tilemap) object can be optionally passed-in.
             *
             * Important
             *
             * To see your sprite onscreen, you will need to call [`:add()`](https://sdk.play.date/2.5.0#m-graphics.sprite.add) on your sprite to add it to the display list.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.new)
             *
             * @noSelf
             */
            export function _new(
                image_or_tilemap?:
                    | playdate.graphics.image
                    | playdate.graphics.tilemap
            ): playdate.graphics.sprite;

            export { _new as new };

            /**
             * Important
             *
             * You must import _CoreLibs/sprites_ to use this function.
             *
             * A conveneince function that creates a sprite with an image of `_text_`, as generated by [imageWithText()](https://sdk.play.date/2.5.0#f-graphics.imageWithText).
             *
             * The arguments are the same as those in [imageWithText()](https://sdk.play.date/2.5.0#f-graphics.imageWithText).
             *
             * Returns `_sprite_`, `_textWasTruncated_`
             *
             * `_sprite_` is a newly-created [sprite](https://sdk.play.date/2.5.0#C-graphics.sprite) with its image set to an image of the text specified. The sprite’s dimensions may be smaller than `_maxWidth_`, `_maxHeight_`.
             *
             * `_textWasTruncated_` indicates if the text was truncated to fit within the specified width and height.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.spriteWithText)
             *
             * @noSelf
             */
            export function spriteWithText(
                text: string,
                maxWidth: number,
                maxHeight: number,
                backgroundColor?: PlaydateColor,
                leadingAdjustment?: number,
                truncationString?: string,
                alignment?: PlaydateTextAlignment,
                font?: playdate.graphics.font
            ): playdate.graphics.sprite;

            /**
             * This class method (note the "." syntax rather than ":") calls the [update()](https://sdk.play.date/2.5.0#c-graphics.sprite.update) function on every sprite in the global sprite list and redraws all of the dirty rects.
             *
             * Important
             *
             * You will generally want to call `playdate.graphics.sprite.update()` once in your [`playdate.update()`](https://sdk.play.date/2.5.0#c-update) method, to ensure that your sprites are updated and drawn during every frame. Failure to do so may mean your sprites will not appear onscreen.
             *
             * Caution
             *
             * Be careful not confuse `sprite.update()` with [`sprite:update()`](https://sdk.play.date/2.5.0#c-graphics.sprite.update): the former updates all sprites; the latter updates just the sprite being invoked.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.update)
             *
             * @noSelf
             */
            export function update(): void;

            /**
             * Adds the given sprite to the display list, so that it is drawn in the current scene. Note that this is called with a period `.` instead of a colon `:`.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.addSprite)
             *
             * @noSelf
             */
            export function addSprite(sprite: playdate.graphics.sprite): void;

            /**
             * Removes the given sprite from the display list. As with `add()`/`addSprite()`, note that this is called with a period `.` instead of a colon `:`.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.removeSprite)
             *
             * @noSelf
             */
            export function removeSprite(
                sprite: playdate.graphics.sprite
            ): void;

            /**
             * Important
             *
             * You must import _CoreLibs/sprites_ to use this function.
             *
             * A convenience function for drawing a background image behind your sprites.
             *
             * _drawCallback_ is a routine you specify that implements your background drawing. The callback should be a function taking the arguments `x, y, width, height`, where _x, y, width, height_ specify the region (in screen coordinates, not world coordinates) of the background region that needs to be updated.
             *
             * Note
             *
             * Some implementation details: `setBackgroundDrawingCallback()` creates a screen-sized sprite with a z-index set to the lowest possible value so it will draw behind other sprites, and adds the sprite to the display list so that it is drawn in the current scene. The background sprite ignores the [drawOffset](https://sdk.play.date/2.5.0#f-graphics.setDrawOffset), and will not be automatically redrawn when the draw offset changes; use [playdate.graphics.sprite.redrawBackground()](https://sdk.play.date/2.5.0#f-graphics.sprite.redrawBackground) if necessary in this case. _drawCallback_ will be called from the newly-created background sprite’s [playdate.graphics.sprite:draw()](https://sdk.play.date/2.5.0#c-graphics.sprite.draw) callback function and is where you should do your background drawing. This function returns the newly created [playdate.graphics.sprite](https://sdk.play.date/2.5.0#C-graphics.sprite).
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.setBackgroundDrawingCallback)
             *
             * @noSelf
             */
            export function setBackgroundDrawingCallback(
                drawCallback: (
                    x: number,
                    y: number,
                    width: number,
                    height: number
                ) => void
            ): void;

            /**
             * Important
             *
             * You must import _CoreLibs/sprites_ to use this function.
             *
             * Marks the background sprite dirty, forcing the drawing callback to be run when [playdate.graphics.sprite.update()](https://sdk.play.date/2.5.0#f-graphics.sprite.update) is called.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.redrawBackground)
             *
             * @noSelf
             */
            export function redrawBackground(): void;

            /**
             * Sets the clip rect for sprites in the given z-index range.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.setClipRectsInRange)
             *
             * @noSelf
             */
            export function setClipRectsInRange(
                x: number,
                y: number,
                width: number,
                height: number,
                startz: number,
                endz: number
            ): void;

            /**
             * Sets the clip rect for sprites in the given z-index range.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.setClipRectsInRange)
             *
             * @noSelf
             */
            export function setClipRectsInRange(
                rect: playdate.geometry.rect,
                startz: number,
                endz: number
            ): void;

            /**
             * Clears sprite clip rects in the given z-index range.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.clearClipRectsInRange)
             *
             * @noSelf
             */
            export function clearClipRectsInRange(
                startz: number,
                endz: number
            ): void;

            /**
             * If set to true, causes all sprites to draw each frame, whether or not they have been marked dirty. This may speed up the performance of your game if the system’s dirty rect tracking is taking up too much time - for example if there are many sprites moving around on screen at once.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.setAlwaysRedraw)
             *
             * @noSelf
             */
            export function setAlwaysRedraw(flag: boolean): void;

            /**
             * Return’s the sprites "always redraw" flag.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.getAlwaysRedraw)
             *
             * @noSelf
             */
            export function getAlwaysRedraw(): boolean;

            /**
             * Marks the given rectangle (in screen coordinates) as needing a redraw. playdate.graphics drawing functions now call this automatically, adding their drawn areas to the sprite’s dirty list, so there’s likely no need to call this manually any more. This behavior may change in the future, though.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.addDirtyRect)
             *
             * @noSelf
             */
            export function addDirtyRect(
                x: number,
                y: number,
                width: number,
                height: number
            ): void;

            /**
             * Returns an array of all sprites in the display list.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.getAllSprites)
             *
             * @noSelf
             */
            export function getAllSprites(): playdate.graphics.sprite[];

            /**
             * Important
             *
             * You must import _CoreLibs/sprites_ to use this function.
             *
             * Performs the function _f_ on all sprites in the display list. _f_ should take one argument, which will be a sprite.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.performOnAllSprites)
             *
             * @noSelf
             */
            export function performOnAllSprites(
                f: (sprite: playdate.graphics.sprite) => void
            ): void;

            /**
             * Returns the number of sprites in the display list.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.spriteCount)
             *
             * @noSelf
             */
            export function spriteCount(): number;

            /**
             * Removes all sprites from the global sprite list.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.removeAll)
             *
             * @noSelf
             */
            export function removeAll(): void;

            /**
             * Removes all sprites in `spriteArray` from the global sprite list.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.removeSprites)
             *
             * @noSelf
             */
            export function removeSprites(
                spriteArray: playdate.graphics.sprite[]
            ): void;

            /**
             * Returns an array of array-style tables, each containing two sprites that have overlapping collide rects. All sprite pairs that are have overlapping collide rects (taking the sprites' group and collides-with masks into consideration) are returned.
             *
             * An example of iterating over the collisions array:
             *
             *     local collisions = gfx.sprite.allOverlappingSprites()
             *
             *     for i = 1, #collisions do
             *             local collisionPair = collisions[i]
             *             local sprite1 = collisionPair[1]
             *             local sprite2 = collisionPair[2]
             *             -- do something with the colliding sprites
             *     end
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.allOverlappingSprites)
             *
             * @noSelf
             */
            export function allOverlappingSprites(): [
                playdate.graphics.sprite,
                playdate.graphics.sprite
            ][];

            /**
             * Returns all sprites with collision rects containing the point.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.querySpritesAtPoint)
             *
             * @noSelf
             */
            export function querySpritesAtPoint(
                x: number,
                y: number
            ): playdate.graphics.sprite[];

            /**
             * Returns all sprites with collision rects containing the point.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.querySpritesAtPoint)
             *
             * @noSelf
             */
            export function querySpritesAtPoint(
                p: playdate.geometry.point
            ): playdate.graphics.sprite[];

            /**
             * Returns all sprites with collision rects overlapping the rect.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.querySpritesInRect)
             *
             * @noSelf
             */
            export function querySpritesInRect(
                x: number,
                y: number,
                width: number,
                height: number
            ): playdate.graphics.sprite[];

            /**
             * Returns all sprites with collision rects overlapping the rect.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.querySpritesInRect)
             *
             * @noSelf
             */
            export function querySpritesInRect(
                rect: playdate.geometry.rect
            ): playdate.graphics.sprite[];

            /**
             * Returns all sprites with collision rects intersecting the line segment.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.querySpritesAlongLine)
             *
             * @noSelf
             */
            export function querySpritesAlongLine(
                x1: number,
                y1: number,
                x2: number,
                y2: number
            ): playdate.graphics.sprite[];

            /**
             * Returns all sprites with collision rects intersecting the line segment.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.querySpritesAlongLine)
             *
             * @noSelf
             */
            export function querySpritesAlongLine(
                lineSegment: playdate.geometry.lineSegmentnt
            ): playdate.graphics.sprite[];

            /**
             * Similar to _querySpritesAlongLine()_, but instead of sprites returns an array of _collisionInfo_ tables containing information about sprites intersecting the line segment, and _len_, which is the number of collisions found. If you don’t need this information, use _querySpritesAlongLine()_ as it will be faster.
             *
             * Each _collisionInfo_ table contains:
             *
             * *   _sprite_: the sprite being intersected by the segment.
             *
             * *   _entryPoint_: a [`point`](https://sdk.play.date/2.5.0#C-geometry.point) representing the coordinates of the first intersection between `sprite` and the line segment.
             *
             * *   _exitPoint_: a [`point`](https://sdk.play.date/2.5.0#C-geometry.point) representing the coordinates of the second intersection between `sprite` and the line segment.
             *
             * *   _ti1_ & _ti2_: numbers between 0 and 1 which indicate how far from the starting point of the line segment the collision happened; t1 for the entry point, t2 for the exit point. This can be useful for things like having a laser cause more damage if the impact is close.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.querySpriteInfoAlongLine)
             *
             * @noSelf
             */
            export function querySpriteInfoAlongLine(
                x1: number,
                y1: number,
                x2: number,
                y2: number
            ): PlaydateCollisionInfo;

            /**
             * Similar to _querySpritesAlongLine()_, but instead of sprites returns an array of _collisionInfo_ tables containing information about sprites intersecting the line segment, and _len_, which is the number of collisions found. If you don’t need this information, use _querySpritesAlongLine()_ as it will be faster.
             *
             * Each _collisionInfo_ table contains:
             *
             * *   _sprite_: the sprite being intersected by the segment.
             *
             * *   _entryPoint_: a [`point`](https://sdk.play.date/2.5.0#C-geometry.point) representing the coordinates of the first intersection between `sprite` and the line segment.
             *
             * *   _exitPoint_: a [`point`](https://sdk.play.date/2.5.0#C-geometry.point) representing the coordinates of the second intersection between `sprite` and the line segment.
             *
             * *   _ti1_ & _ti2_: numbers between 0 and 1 which indicate how far from the starting point of the line segment the collision happened; t1 for the entry point, t2 for the exit point. This can be useful for things like having a laser cause more damage if the impact is close.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.querySpriteInfoAlongLine)
             *
             * @noSelf
             */
            export function querySpriteInfoAlongLine(
                lineSegment: playdate.geometry.lineSegmentnt
            ): PlaydateCollisionInfo;

            /**
             * Important
             *
             * You must import _CoreLibs/sprites_ to use this function.
             *
             * This convenience function adds an invisible sprite defined by the rectangle _x_, _y_, _w_, _h_ (or the [playdate.geometry.rect](https://sdk.play.date/2.5.0#C-geometry.rect) _r_) for the purpose of triggering collisions. This is useful for making areas impassable, triggering an event when a sprite enters a certain area, and so on.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.addEmptyCollisionSprite)
             *
             * @noSelf
             */
            export function addEmptyCollisionSprite(
                r: playdate.geometry.rect
            ): void;

            /**
             * Important
             *
             * You must import _CoreLibs/sprites_ to use this function.
             *
             * This convenience function adds an invisible sprite defined by the rectangle _x_, _y_, _w_, _h_ (or the [playdate.geometry.rect](https://sdk.play.date/2.5.0#C-geometry.rect) _r_) for the purpose of triggering collisions. This is useful for making areas impassable, triggering an event when a sprite enters a certain area, and so on.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.addEmptyCollisionSprite)
             *
             * @noSelf
             */
            export function addEmptyCollisionSprite(
                x: number,
                y: number,
                w: number,
                h: number
            ): void;

            /**
             * Important
             *
             * You must import _CoreLibs/sprites_ to use this function.
             *
             * This convenience function automatically adds empty collision sprites necessary to restrict movement within a tilemap.
             *
             * _tilemap_ is a [playdate.graphics.tilemap](https://sdk.play.date/2.5.0#C-graphics.tilemap).
             *
             * _emptyIDs_ is an array of tile IDs that should be considered "passable" — in other words, not walls. Tiles with default IDs of 0 are treated as passable by default, so you do not need to include 0 in the array.
             *
             * _xOffset, yOffset_ optionally indicate the distance the new sprites should be offset from (0,0).
             *
             * Returns an array-style table of the newly created sprites.
             *
             * Calling this function is effectively a shortcut for calling [playdate.graphics.tilemap:getCollisionRects()](https://sdk.play.date/2.5.0#m-graphics.tilemap.getCollisionRects) and passing the resulting rects to [addEmptyCollisionSprite()](https://sdk.play.date/2.5.0#f-graphics.sprite.addEmptyCollisionSprite).
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.sprite.addWallSprites)
             *
             * @noSelf
             */
            export function addWallSprites(
                tilemap: playdate.graphics.tilemap,
                emptyIDs: number[],
                xOffset?: number,
                yOffset?: number
            ): void;
        }

        class sprite {
            /**
             * Sets the sprite’s image to `image`, which should be an instance of [playdate.graphics.image](https://sdk.play.date/2.5.0#C-graphics.image). The .flip\_ argument is optional; see [playdate.graphics.image:draw()](https://sdk.play.date/2.5.0#m-graphics.imgDraw) for valid values. Optional scale arguments are also accepted. Unless disabled with [playdate.graphics.sprite:setRedrawOnImageChange()](https://sdk.play.date/2.5.0#m-graphics.sprite.setRedrawsOnImageChange), the sprite is automatically marked for redraw if the image isn’t the previous image.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setImage)
             */
            setImage(
                image: playdate.graphics.image,
                flip?: PlaydateFlip,
                scale?: number,
                yscale?: number
            ): void;

            /**
             * Returns the playdate.graphics.image object that was set with setImage().
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.getImage)
             */
            getImage(): playdate.graphics.image;

            /**
             * Adds the given sprite to the display list, so that it is drawn in the current scene.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.add)
             */
            add(): void;

            /**
             * Removes the given sprite from the display list.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.remove)
             */
            remove(): void;

            /**
             * Moves the sprite and resets the bounds based on the image dimensions and center.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.moveTo)
             */
            moveTo(x: number, y: number): void;

            /**
             * Returns the sprite’s current x, y position as multiple values (_x_, _y_).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.getPosition)
             */
            getPosition(): LuaMultiReturn<[number, number]>;

            /**
             * Moves the sprite by _x_, _y_ pixels relative to its current position.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.moveBy)
             */
            moveBy(x: number, y: number): void;

            /**
             * Sets the Z-index of the given sprite. Sprites with higher Z-indexes are drawn on top of those with lower Z-indexes. Valid values for _z_ are in the range (-32768, 32767).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setZIndex)
             */
            setZIndex(z: number): void;

            /**
             * Returns the Z-index of the given sprite.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.getZIndex)
             */
            getZIndex(): number;

            /**
             * Sprites that aren’t visible don’t get their [draw()](https://sdk.play.date/2.5.0#c-graphics.sprite.draw) method called.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setVisible)
             */
            setVisible(flag: boolean): void;

            /**
             * Returns a boolean value, true if the sprite is visible.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.isVisible)
             */
            isVisible(): boolean;

            /**
             * Sets the sprite’s drawing center as a fraction (ranging from 0.0 to 1.0) of the height and width. Default is 0.5, 0.5 (the center of the sprite). This means that when you call [:moveTo(x, y)](https://sdk.play.date/2.5.0#m-graphics.sprite.moveTo), the center of your sprite will be positioned at _x_, _y_. If you want x and y to represent the upper left corner of your sprite, specify the center as 0, 0.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setCenter)
             */
            setCenter(x: number, y: number): void;

            /**
             * Returns multiple values (`x, y`) representing the sprite’s drawing center as a fraction (ranging from 0.0 to 1.0) of the height and width.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.getCenter)
             */
            getCenter(): LuaMultiReturn<[number, number]>;

            /**
             * Returns a [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point) representing the sprite’s drawing center as a fraction (ranging from 0.0 to 1.0) of the height and width.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.getCenterPoint)
             */
            getCenterPoint(): playdate.geometry.point;

            /**
             * Sets the sprite’s size. The method has no effect if the sprite has an image set.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setSize)
             */
            setSize(width: number, height: number): void;

            /**
             * Returns multiple values _(width, height)_, the current size of the sprite.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.getSize)
             */
            getSize(): LuaMultiReturn<[number, number]>;

            /**
             * Sets the scaling factor for the sprite, with an optional separate scaling for the y axis. If setImage() is called after this, the scale factor is applied to the new image. Only affects sprites that have an image set.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setScale)
             */
            setScale(scale: number, yScale?: any): void;

            /**
             * Returns multiple values _(xScale, yScale)_, the current scaling of the sprite.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.getScale)
             */
            getScale(): LuaMultiReturn<[number, number]>;

            /**
             * Sets the rotation for the sprite, in degrees clockwise, with an optional scaling factor. If setImage() is called after this, the rotation and scale is applied to the new image. Only affects sprites that have an image set. This function should be used with discretion, as it’s likely to be slow on the hardware. Consider pre-rendering rotated images for your sprites instead.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setRotation)
             */
            setRotation(angle: number, scale?: number, yScale?: any): void;

            /**
             * Returns the current rotation of the sprite.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.getRotation)
             */
            getRotation(): number;

            /**
             * Returns a copy of the caller.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.copy)
             */
            copy(): playdate.graphics.sprite;

            /**
             * The sprite’s _updatesEnabled_ flag (defaults to true) determines whether a sprite’s [update()](https://sdk.play.date/2.5.0#c-graphics.sprite.update) method will be called. By default, a sprite’s `update` method does nothing; however, you may choose to have your sprite do something on every frame by implementing an update method on your sprite instance, or implementing it in your sprite subclass.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setUpdatesEnabled)
             */
            setUpdatesEnabled(flag: boolean): void;

            /**
             * Returns a boolean value, true if updates are enabled on the sprite.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.updatesEnabled)
             */
            updatesEnabled(): boolean;

            /**
             * Sets the sprite’s tag, an integer value in the range of 0 to 255, useful for identifying sprites later, particularly when working with collisions.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setTag)
             */
            setTag(tag: number): void;

            /**
             * Returns the sprite’s tag, an integer value.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.getTag)
             */
            getTag(): number;

            /**
             * Sets the mode for drawing the bitmap. See [playdate.graphics.setImageDrawMode(mode)](https://sdk.play.date/2.5.0#f-graphics.setImageDrawMode) for valid modes.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setImageDrawMode)
             */
            setImageDrawMode(mode: PlaydateDrawMode): void;

            /**
             * Flips the bitmap. See [playdate.graphics.image:draw()](https://sdk.play.date/2.5.0#m-graphics.imgDraw) for valid `flip` values.
             *
             * If `true` is passed for the optional _flipCollideRect_ argument, the sprite’s collideRect will be flipped as well.
             *
             * Calling setImage() will reset the sprite to its default, non-flipped orientation. So, if you call both setImage() and setImageFlip(), call setImage() first.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setImageFlip)
             */
            setImageFlip(flip: PlaydateFlip, flipCollideRect?: boolean): void;

            /**
             * Returns one of the values listed at [playdate.graphics.image:draw()](https://sdk.play.date/2.5.0#m-graphics.imgDraw).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.getImageFlip)
             */
            getImageFlip(): PlaydateFlip;

            /**
             * When set to _true_, the sprite will draw in screen coordinates, ignoring the currently-set [_drawOffset_](https://sdk.play.date/2.5.0#f-graphics.setDrawOffset).
             *
             * This only affects drawing, and should not be used on sprites being used for collisions, which will still happen in world-space.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setIgnoresDrawOffset)
             */
            setIgnoresDrawOffset(flag: boolean): void;

            /**
             * `setBounds()` positions and sizes the sprite, used for drawing and for calculating dirty rects. _upper-left-x_ and _upper-left-y_ are relative to the overall display coordinate system. (If an image is attached to the sprite, the size will be defined by that image, and not by the _width_ and _height_ parameters passed in to `setBounds()`.)
             *
             * Note
             *
             * In `setBounds()`, _x_ and _y_ always correspond to the upper left corner of the sprite, regardless of how a [sprite’s center](https://sdk.play.date/2.5.0#m-graphics.sprite.setCenter) is defined. This makes it different from [sprite:moveTo()](https://sdk.play.date/2.5.0#m-graphics.sprite.moveTo), where _x_ and _y_ honor the sprite’s defined center (by default, at a point 50% along the sprite’s width and height.)
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setBounds)
             */
            setBounds(
                upperLeftX: number,
                upperLeftY: number,
                width: number,
                height: number
            ): void;
            /**
             * `setBounds(rect)` sets the bounds of the sprite with a [`playdate.geometry.rect`](https://sdk.play.date/2.5.0#C-geometry.rect) object.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setBounds-rect)
             */
            setBounds(rect: playdate.geometry.rect): void;

            /**
             * `getBounds()` returns multiple values (_x_, _y_, _width_, _height_).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.getBounds)
             */
            getBounds(): LuaMultiReturn<[number, number, number, number]>;

            /**
             * `getBoundsRect()` returns the sprite bounds as a [`playdate.geometry.rect`](https://sdk.play.date/2.5.0#C-geometry.rect) object.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.getBoundsRect)
             */
            getBoundsRect(): playdate.geometry.rect;

            /**
             * Marking a sprite opaque tells the sprite system that it doesn’t need to draw anything underneath the sprite, since it will be overdrawn anyway. If you set an image without a mask/alpha channel on the sprite, it automatically sets the opaque flag.
             *
             * Setting a sprite to opaque can have performance benefits.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setOpaque)
             */
            setOpaque(flag: boolean): void;

            /**
             * Returns the sprite’s current opaque flag.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.isOpaque)
             */
            isOpaque(): boolean;

            /**
             * Sets the sprite’s contents to the given [tilemap](https://sdk.play.date/2.5.0#C-graphics.tilemap). Useful if you want to automate drawing of your tilemap, especially if interleaved by depth with other sprites being drawn.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setTilemap)
             */
            setTilemap(tilemap: playdate.graphics.tilemap): void;

            /**
             * Important
             *
             * You must import _CoreLibs/sprites_ to use the `setAnimator` method.
             *
             * `setAnimator` assigns an [playdate.graphics.animator](https://sdk.play.date/2.5.0#C-graphics.animator) to the sprite, which will cause the sprite to automatically update its position each frame while the animator is active.
             *
             * _movesWithCollisions_, if provided and true will cause the sprite to move with collisions. A collision rect must be set on the sprite prior to passing true for this argument.
             *
             * _removeOnCollision_, if provided and true will cause the animator to be removed from the sprite when a collision occurs.
             *
             * Note
             *
             * `setAnimator` should be called only after any custom update method has been set on the sprite.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setAnimator)
             */
            setAnimator(
                animator: playdate.graphics.animator,
                moveWithCollisions?: boolean,
                removeOnCollision?: boolean
            ): void;

            /**
             * Removes a [playdate.graphics.animator](https://sdk.play.date/2.5.0#C-graphics.animator) assigned to the sprite
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.removeAnimator)
             */
            removeAnimator(): void;

            /**
             * Sets the clipping rectangle for the sprite, using separate parameters or a [`playdate.geometry.rect`](https://sdk.play.date/2.5.0#C-geometry.rect) object. Only areas within the rect will be drawn.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setClipRect)
             */
            setClipRect(
                x: number,
                y: number,
                width: number,
                height: number
            ): void;
            /**
             * Sets the clipping rectangle for the sprite, using separate parameters or a [`playdate.geometry.rect`](https://sdk.play.date/2.5.0#C-geometry.rect) object. Only areas within the rect will be drawn.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setClipRect)
             */
            setClipRect(rect: playdate.geometry.rect): void;

            /**
             * Clears the sprite’s current clipping rectangle.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.clearClipRect)
             */
            clearClipRect(): void;

            /**
             * Specifies a stencil image to be set on the frame buffer before the sprite is drawn. If _tile_ is set, the the stencil will be tiled; in this case, the image width must be a multiple of 32 pixels.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setStencilImage)
             */
            setStencilImage(
                stencil: playdate.graphics.image,
                tile?: boolean
            ): void;

            /**
             * Sets the sprite’s stencil to a dither pattern specified by _level_ and optional _ditherType_ (defaults to `playdate.graphics.image.kDitherTypeBayer8x8`).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setStencilPattern-dither)
             */
            setStencilPattern(
                level: number,
                ditherType?: PlaydateDitherType = PlaydateDitherType.Bayer8x8
            ): void;

            /**
             * Clears the sprite’s stencil.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.clearStencil)
             */
            clearStencil(): void;

            /**
             * Marks the rect defined by the sprite’s current bounds as needing a redraw.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.markDirty)
             */
            markDirty(): void;

            /**
             * By default, sprites are automatically marked for redraw when their image is changed via [playdate.graphics.sprite:setImage()](https://sdk.play.date/2.5.0#m-graphics.sprite.setImage). If disabled by calling this function with a _false_ argument, [playdate.graphics.sprite.addDirtyRect()](https://sdk.play.date/2.5.0#m-graphics.sprite.addDirtyRect) can be used to mark the (potentially smaller) area of the screen that needs to be redrawn.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setRedrawsOnImageChange)
             */
            setRedrawsOnImageChange(flag: boolean): void;

            /**
             * If the sprite doesn’t have an image, the sprite’s draw function is called as needed to update the display. The rect passed in is the current dirty rect being updated by the display list. The rect coordinates passed in are relative to the sprite itself (i.e. x = 0, y = 0 refers to the top left corner of the sprite). Note that the callback is only called when the sprite is on screen and has a size specified via [sprite:setSize()](https://sdk.play.date/2.5.0#m-graphics.sprite.setSize) or [sprite:setBounds()](https://sdk.play.date/2.5.0#m-graphics.sprite.setBounds).
             *
             * Example: Overriding the sprite draw method
             *
             *     -- You can copy and paste this example directly as your main.lua file to see it in action
             *     import "CoreLibs/graphics"
             *     import "CoreLibs/sprites"
             *
             *     local mySprite = playdate.graphics.sprite.new()
             *     mySprite:moveTo(200, 120)
             *     -- You MUST set a size first for anything to show up (either directly or by setting an image)
             *     mySprite:setSize(30, 30)
             *     mySprite:add()
             *
             *     -- The x, y, width, and height arguments refer to the dirty rect being updated, NOT the sprite dimensions
             *     function mySprite:draw(x, y, width, height)
             *         -- Custom draw methods gives you more flexibility over what's drawn, but with the added benefits of sprites
             *
             *         -- Here we're just modulating the circle radius over time
             *         local spriteWidth, spriteHeight = self:getSize()
             *         if not self.radius or self.radius > spriteWidth then
             *             self.radius = 0
             *         end
             *         self.radius += 1
             *
             *         -- Drawing coordinates are relative to the sprite (e.g. (0, 0) is the top left of the sprite)
             *         playdate.graphics.fillCircleAtPoint(spriteWidth / 2, spriteHeight / 2, self.radius)
             *     end
             *
             *     function playdate.update()
             *         -- Your custom draw method gets called here, but only if the sprite is dirty
             *         playdate.graphics.sprite.update()
             *
             *         -- You might need to manually mark it dirty
             *         mySprite:markDirty()
             *     end
             *
             * [Read more](https://sdk.play.date/2.5.0#c-graphics.sprite.draw)
             */
            draw(x: number, y: number, width: number, height: number): void;

            /**
             * Called by [playdate.graphics.sprite.update()](https://sdk.play.date/2.5.0#f-graphics.sprite.update) (note the syntactic difference between the period and the colon) before sprites are drawn. Implementing `:update()` gives you the opportunity to perform some code upon every frame.
             *
             * Note
             *
             * The update method will only be called on sprites that have had [add()](https://sdk.play.date/2.5.0#m-graphics.sprite.add) called on them, and have their [updates enabled](https://sdk.play.date/2.5.0#m-graphics.sprite.updatesEnabled).
             *
             * Caution
             *
             * Be careful not confuse `sprite:update()` with [`sprite.update()`](https://sdk.play.date/2.5.0#f-graphics.sprite.update): the latter updates all sprites; the former updates just the sprite being invoked.
             *
             * Example: Overriding the sprite update method
             *
             *     local mySprite = playdate.graphics.sprite.new()
             *     mySprite:moveTo(200, 120)
             *     mySprite:add() -- Sprite needs to be added to get drawn and updated
             *     -- mySprite:remove() will make it so the sprite stops getting drawn/updated
             *
             *     -- Option 1: override the update method using an anonymous function
             *     mySprite.update = function(self)
             *         print("This gets called every frame when I'm added to the display list")
             *         -- Manipulate sprite using "self"
             *         print(self.x) -- Prints 200.0
             *         print(self.y) -- Prints 120.0
             *     end
             *
             *     -- Option 2: override the update method using a function stored in a variable
             *     local function mySpriteUpdate(self)
             *         print("This gets called every frame when I'm added to the display list")
             *         -- Manipulate sprite using "self"
             *         print(self.x) -- Prints 200.0
             *         print(self.y) -- Prints 120.0
             *     end
             *     mySprite.update = mySpriteUpdate
             *
             *     -- Option 3: override the update method by directly defining it
             *     function mySprite:update()
             *         print("This gets called every frame when I'm added to the display list")
             *         -- Manipulate sprite using "self"
             *         print(self.x) -- Prints 200.0
             *         print(self.y) -- Prints 120.0
             *     end
             *
             *     function playdate.update()
             *         -- Your custom update method gets called here every frame if the sprite has been added
             *         playdate.graphics.sprite.update()
             *     end
             *
             *     -- VERY simplified psuedocode explanation of what's happening in sprite.update() (not real code)
             *     local displayList = {} -- Added sprites are kept track of in a list
             *     function playdate.graphics.sprite.update()
             *         -- The display list is iterated over
             *         for i=1, #displayList do
             *             local sprite = displayList[i]
             *             -- Checks if updates on the sprites are enabled
             *             if sprite:updatesEnabled() then
             *                 -- The sprite update method is called
             *                 sprite:update()
             *             end
             *             ...
             *             -- Redraw all of the dirty rects, handle collisions, etc.
             *         end
             *     end
             *
             * [Read more](https://sdk.play.date/2.5.0#c-graphics.sprite.update)
             */
            update(): void;

            /**
             * `setCollideRect()` marks the area of the sprite, relative to its own internal coordinate system, to be checked for collisions with other sprites' collide rects. Note that the coordinate space is relative to the top-left corner of the bounds, regardless of where the sprite’s [center/anchor](https://sdk.play.date/2.5.0#m-graphics.sprite.setCenter) is located.
             *
             * Tip
             *
             * If you want to set the sprite’s collide rect to be the same size as the sprite itself, you can write `sprite:setCollideRect( 0, 0, sprite:getSize() )`.
             *
             * Important
             *
             * `setCollideRect()` must be invoked on a sprite in order to get it to participate in collisions.
             *
             * Important
             *
             * Very large sprites with very large collide rects should be avoided, as they will have a negative impact on performance and memory usage.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setCollideRect)
             */
            setCollideRect(
                x: number,
                y: number,
                width: number,
                height: number
            ): void;
            /**
             * `setCollideRect()` marks the area of the sprite, relative to its own internal coordinate system, to be checked for collisions with other sprites' collide rects. Note that the coordinate space is relative to the top-left corner of the bounds, regardless of where the sprite’s [center/anchor](https://sdk.play.date/2.5.0#m-graphics.sprite.setCenter) is located.
             *
             * Tip
             *
             * If you want to set the sprite’s collide rect to be the same size as the sprite itself, you can write `sprite:setCollideRect( 0, 0, sprite:getSize() )`.
             *
             * Important
             *
             * `setCollideRect()` must be invoked on a sprite in order to get it to participate in collisions.
             *
             * Important
             *
             * Very large sprites with very large collide rects should be avoided, as they will have a negative impact on performance and memory usage.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setCollideRect)
             */
            setCollideRect(rect: playdate.geometry.rect): void;

            /**
             * Returns the sprite’s collide rect set with [`setCollideRect()`](https://sdk.play.date/2.5.0#m-graphics.sprite.setCollideRect). Return value is a [`playdate.geometry.rect`](https://sdk.play.date/2.5.0#C-geometry.rect).
             *
             * Important
             *
             * This function return coordinates relative to the sprite itself; the sprite’s position has no bearing on these values.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.getCollideRect)
             */
            getCollideRect(): playdate.geometry.rect;

            /**
             * Returns the sprite’s collide rect as multiple values, (_x_, _y_, _width_, _height_).
             *
             * Important
             *
             * This function return coordinates relative to the sprite itself; the sprite’s position has no bearing on these values.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.getCollideBounds)
             */
            getCollideBounds(): LuaMultiReturn<
                [number, number, number, number]
            >;

            /**
             * Clears the sprite’s collide rect set with [`setCollideRect()`](https://sdk.play.date/2.5.0#m-graphics.sprite.setCollideRect).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.clearCollideRect)
             */
            clearCollideRect(): void;

            /**
             * Returns an array of sprites that have collide rects that are currently overlapping the calling sprite’s collide rect, taking the sprites' groups and collides-with masks into consideration.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.overlappingSprites)
             */
            overlappingSprites(): playdate.graphics.sprite[];

            /**
             * Returns a boolean value set to true if a pixel-by-pixel comparison of the sprite images shows that non-transparent pixels are overlapping, based on the current bounds of the sprites.
             *
             * This method may be used in conjunction with the standard collision architecture. Say, if [`overlappingSprites()`](https://sdk.play.date/2.5.0#m-graphics.sprite.overlappingSprites) or [`moveWithCollisions()`](https://sdk.play.date/2.5.0#m-graphics.sprite.moveWithCollisions) report a collision of two sprite’s bounding rects, alphaCollision() could then be used to discern if a pixel-level collision occurred.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.alphaCollision)
             */
            alphaCollision(anotherSprite: playdate.graphics.sprite): boolean;

            /**
             * The sprite’s _collisionsEnabled_ flag (defaults to true) can be set to `false` in order to temporarily keep a sprite from colliding with any other sprite.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setCollisionsEnabled)
             */
            setCollisionsEnabled(flag: boolean): void;

            /**
             * Returns the sprite’s _collisionsEnabled_ flag.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.collisionsEnabled)
             */
            collisionsEnabled(): boolean;

            /**
             * Adds the sprite to one or more collision groups. A group is a collection of sprites that exhibit similar collision behavior. (An example: in Atari’s _Asteroids_, asteroid sprites would all be added to the same group, while the player’s spaceship might be in a different group.) Use [`setCollidesWithGroups()`](https://sdk.play.date/2.5.0#m-graphics.sprite.setCollidesWithGroups) to define which groups a sprite should collide with.
             *
             * There are 32 groups, each defined by the integer 1 through 32. To add a sprite to only groups 1 and 3, for example, call `mySprite:setGroups({1, 3})`.
             *
             * Alternatively, use [`setGroupMask()`](https://sdk.play.date/2.5.0#m-graphics.sprite.setGroupMask) to set group membership via a bitmask.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setGroups)
             */
            setGroups(groups: number[]): void;

            /**
             * Pass in a group number or an array of group numbers to specify which groups this sprite can collide with. Groups are numbered 1 through 32. Use [`setGroups()`](https://sdk.play.date/2.5.0#m-graphics.sprite.setGroups) to specify which groups a sprite belongs to.
             *
             * Alternatively, you can specify group collision behavior with a bitmask by using [`setCollidesWithGroupsMask()`](https://sdk.play.date/2.5.0#m-graphics.sprite.setCollidesWithGroupsMask).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setCollidesWithGroups)
             */
            setCollidesWithGroups(groups: number | number[]): void;

            /**
             * `setGroupMask()` sets the sprite’s group bitmask, which is 32 bits. In conjunction with the [`setCollidesWithGroupsMask()`](https://sdk.play.date/2.5.0#m-graphics.sprite.setCollidesWithGroupsMask) method, this controls which sprites can collide with each other.
             *
             * For large group mask numbers, pass the number as a hex value, eg. `0xFFFFFFFF` to work around limitations in Lua’s integer sizes.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setGroupMask)
             */
            setGroupMask(mask: number): void;

            /**
             * `getGroupMask()` returns the integer value of the sprite’s group bitmask.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.getGroupMask)
             */
            getGroupMask(): number;

            /**
             * Sets the sprite’s collides-with-groups bitmask, which is 32 bits. The mask specifies which other sprite groups this sprite can collide with. Sprites only collide if the moving sprite’s _collidesWithGroupsMask_ matches at least one group of a potential collision sprite (i.e. a bitwise AND (&) between the moving sprite’s _collidesWithGroupsMask_ and a potential collision sprite’s _groupMask_ != zero) or if the moving sprite’s _collidesWithGroupsMask_ and the other sprite’s _groupMask_ are both set to 0x00000000 (the default values).
             *
             * For large mask numbers, pass the number as a hex value, eg. `0xFFFFFFFF` to work around limitations in Lua’s integer sizes.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.setCollidesWithGroupsMask)
             */
            setCollidesWithGroupsMask(mask: number): void;

            /**
             * Returns the integer value of the sprite’s collision bitmask.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.getCollidesWithGroupsMask)
             */
            getCollidesWithGroupsMask(): number;

            /**
             * Resets the sprite’s group mask to `0x00000000`.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.resetGroupMask)
             */
            resetGroupMask(): void;

            /**
             * Resets the sprite’s collides-with-groups mask to `0x00000000`.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.resetCollidesWithGroupsMask)
             */
            resetCollidesWithGroupsMask(): void;

            /**
             * Moves the sprite towards _goalX_, _goalY_ or _goalPoint_ taking collisions into account, which means the sprite’s final position may not be the same as _goalX_, _goalY_ or _goalPoint_.
             *
             * Returns _actualX_, _actualY_, _collisions_, _length_.
             *
             *
             *
             * _actualX_, _actualY_
             *
             * the final position of the sprite. If no collisions occurred, this will be the same as _goalX_, _goalY_.
             *
             * _collisions_
             *
             * an array of userdata objects containing information about all collisions that occurred. Each item in the array contains values for the following indices:
             *
             * \- _sprite_: The sprite being moved.
             *
             * \- _other_: The sprite colliding with the sprite being moved.
             *
             * \- _type_: The result of [_collisionResponse_](https://sdk.play.date/2.5.0#c-graphics.sprite.collisionResponse).
             *
             * \- _overlaps_: Boolean. True if the sprite was overlapping _other_ when the collision started. False if it didn’t overlap but tunneled through _other_.
             *
             * \- _ti_: A number between 0 and 1 indicating how far along the movement to the goal the collision occurred.
             *
             * \- _move_: [playdate.geometry.vector2D](https://sdk.play.date/2.5.0#C-geometry.vector2D). The difference between the original coordinates and the actual ones when the collision happened.
             *
             * \- _normal_: [playdate.geometry.vector2D](https://sdk.play.date/2.5.0#C-geometry.vector2D). The collision normal; usually -1, 0, or 1 in _x_ and _y_. Use this value to determine things like if your character is touching the ground.
             *
             * \- _touch_: [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point). The coordinates where the sprite started touching _other_.
             *
             * \- _spriteRect_: [playdate.geometry.rect](https://sdk.play.date/2.5.0#C-geometry.rect). The rectangle the sprite occupied when the touch happened.
             *
             * \- _otherRect_: [playdate.geometry.rect](https://sdk.play.date/2.5.0#C-geometry.rect). The rectangle `other` occupied when the touch happened.
             *
             * If the collision type was _playdate.graphics.sprite.kCollisionTypeBounce_ the table also contains _bounce_, a [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point) indicating the coordinates to which the sprite attempted to bounce (could be different than _actualX_, _actualY_ if further collisions occurred).
             *
             * If the collision type was _playdate.graphics.sprite.kCollisionTypeSlide_ the table also contains _slide_, a [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point) indicating the coordinates to which the sprite attempted to slide.
             *
             * _length_
             *
             * the length of the collisions array, equal to _#collisions_
             *
             * Note that the collision info items are only valid until the next call of _moveWithCollisions_ or _checkCollisions_. To save collision information for later, the data should be copied out of the collision info userdata object.
             *
             * See also [`checkCollisions()`](https://sdk.play.date/2.5.0#m-graphics.sprite.checkCollisions) to check for collisions without actually moving the sprite.
             *
             * Example: Using moveWithCollisions for a simple player collision example
             *
             *     -- You can copy and paste this example directly as your main.lua file to see it in action
             *     import "CoreLibs/graphics"
             *     import "CoreLibs/sprites"
             *
             *     -- Creating a tags object, to keep track of tags more easily
             *     TAGS = {
             *         player = 1,
             *         obstacle = 2,
             *         coin = 3,
             *         powerUp = 4
             *     }
             *
             *     -- Creating a player sprite we can move around and collide things with
             *     local playerImage = playdate.graphics.image.new(20, 20)
             *     playdate.graphics.pushContext(playerImage)
             *         playdate.graphics.fillCircleInRect(0, 0, playerImage:getSize())
             *     playdate.graphics.popContext()
             *     local playerSprite = playdate.graphics.sprite.new(playerImage)
             *     -- Setting a tag on the player, so we can check the tag to see if we're colliding against the player
             *     playerSprite:setTag(TAGS.player)
             *     playerSprite:moveTo(200, 120)
             *     -- Remember to set a collision rect, or this all doesn't work!
             *     playerSprite:setCollideRect(0, 0, playerSprite:getSize())
             *     playerSprite:add()
             *
             *     -- Creating an obstacle sprite we can collide against
             *     local obstacleImage = playdate.graphics.image.new(20, 20, playdate.graphics.kColorBlack)
             *     local obstacleSprite = playdate.graphics.sprite.new(obstacleImage)
             *     -- Setting a tag for the obstacle as well
             *     obstacleSprite:setTag(TAGS.obstacle)
             *     obstacleSprite:moveTo(300, 120)
             *     -- Can't forget this!
             *     obstacleSprite:setCollideRect(0, 0, obstacleSprite:getSize())
             *     obstacleSprite:add()
             *
             *     function playdate.update()
             *         playdate.graphics.sprite.update()
             *
             *         -- Some simple movement code for the sake of demonstration
             *         local moveSpeed = 3
             *         local goalX, goalY = playerSprite.x, playerSprite.y
             *         if playdate.buttonIsPressed(playdate.kButtonUp) then
             *             goalY -= moveSpeed
             *         elseif playdate.buttonIsPressed(playdate.kButtonDown) then
             *             goalY += moveSpeed
             *         elseif playdate.buttonIsPressed(playdate.kButtonLeft) then
             *             goalX -= moveSpeed
             *         elseif playdate.buttonIsPressed(playdate.kButtonRight) then
             *             goalX += moveSpeed
             *         end
             *
             *         -- Remember to use :moveWithCollisions(), and not :moveTo() or :moveBy(), or collisions won't happen!
             *         -- To do a "moveBy" operation, sprite:moveBy(5, 5) == sprite:moveWithCollisions(sprite.x + 5, sprite.y + 5)
             *         local actualX, actualY, collisions, numberOfCollisions = playerSprite:moveWithCollisions(goalX, goalY)
             *
             *         -- If we get into this loop, there was a collision
             *         for i=1, numberOfCollisions do
             *             -- This is getting data about one of things we're currently colliding with. Since we could
             *             -- be colliding with multiple things at once, we have to handle each collision individually
             *             local collision = collisions[i]
             *
             *             -- Always prints 'true', as the sprite property is the sprite being moved (in this case, the player)
             *             print(collision.sprite == playerSprite)
             *             -- Also prints 'true', as we set the tag on the player sprite to the player tag
             *             print(collision.sprite:getTag() == TAGS.player)
             *
             *             -- This gets the actual sprite object we're colliding with
             *             local collidedSprite = collision.other
             *             local collisionTag = collidedSprite:getTag()
             *             -- Since we set a tag on the obstacle, we can check if we're colliding with that
             *             if collisionTag == TAGS.obstacle then
             *                 print("Collided with an obstacle!")
             *
             *                 -- We can use the collision normal to check which side we collided with
             *                 local collisionNormal = collision.normal
             *                 if collisionNormal.x == -1 then
             *                     print("Touched left side!")
             *                 elseif collisionNormal.x == 1 then
             *                     print("Touched right side!")
             *                 end
             *
             *                 if collisionNormal.y == -1 then
             *                     print("Touched top!")
             *                 elseif collisionNormal.y == 1 then
             *                     print("Touched bottom!")
             *                 end
             *             -- Handle some other collisions, like collecting a coin or a power up
             *             elseif collisionTag == TAGS.coin then
             *                 print("Coin collected!")
             *             elseif collisionTag == TAGS.powerUp then
             *                 print("Powered up!")
             *             end
             *         end
             *     end
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.moveWithCollisions)
             */
            moveWithCollisions(
                goalX: number,
                goalY: number
            ): LuaMultiReturn<[number, number, PlaydateCollision[], number]>;
            /**
             * Moves the sprite towards _goalX_, _goalY_ or _goalPoint_ taking collisions into account, which means the sprite’s final position may not be the same as _goalX_, _goalY_ or _goalPoint_.
             *
             * Returns _actualX_, _actualY_, _collisions_, _length_.
             *
             *
             *
             * _actualX_, _actualY_
             *
             * the final position of the sprite. If no collisions occurred, this will be the same as _goalX_, _goalY_.
             *
             * _collisions_
             *
             * an array of userdata objects containing information about all collisions that occurred. Each item in the array contains values for the following indices:
             *
             * \- _sprite_: The sprite being moved.
             *
             * \- _other_: The sprite colliding with the sprite being moved.
             *
             * \- _type_: The result of [_collisionResponse_](https://sdk.play.date/2.5.0#c-graphics.sprite.collisionResponse).
             *
             * \- _overlaps_: Boolean. True if the sprite was overlapping _other_ when the collision started. False if it didn’t overlap but tunneled through _other_.
             *
             * \- _ti_: A number between 0 and 1 indicating how far along the movement to the goal the collision occurred.
             *
             * \- _move_: [playdate.geometry.vector2D](https://sdk.play.date/2.5.0#C-geometry.vector2D). The difference between the original coordinates and the actual ones when the collision happened.
             *
             * \- _normal_: [playdate.geometry.vector2D](https://sdk.play.date/2.5.0#C-geometry.vector2D). The collision normal; usually -1, 0, or 1 in _x_ and _y_. Use this value to determine things like if your character is touching the ground.
             *
             * \- _touch_: [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point). The coordinates where the sprite started touching _other_.
             *
             * \- _spriteRect_: [playdate.geometry.rect](https://sdk.play.date/2.5.0#C-geometry.rect). The rectangle the sprite occupied when the touch happened.
             *
             * \- _otherRect_: [playdate.geometry.rect](https://sdk.play.date/2.5.0#C-geometry.rect). The rectangle `other` occupied when the touch happened.
             *
             * If the collision type was _playdate.graphics.sprite.kCollisionTypeBounce_ the table also contains _bounce_, a [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point) indicating the coordinates to which the sprite attempted to bounce (could be different than _actualX_, _actualY_ if further collisions occurred).
             *
             * If the collision type was _playdate.graphics.sprite.kCollisionTypeSlide_ the table also contains _slide_, a [playdate.geometry.point](https://sdk.play.date/2.5.0#C-geometry.point) indicating the coordinates to which the sprite attempted to slide.
             *
             * _length_
             *
             * the length of the collisions array, equal to _#collisions_
             *
             * Note that the collision info items are only valid until the next call of _moveWithCollisions_ or _checkCollisions_. To save collision information for later, the data should be copied out of the collision info userdata object.
             *
             * See also [`checkCollisions()`](https://sdk.play.date/2.5.0#m-graphics.sprite.checkCollisions) to check for collisions without actually moving the sprite.
             *
             * Example: Using moveWithCollisions for a simple player collision example
             *
             *     -- You can copy and paste this example directly as your main.lua file to see it in action
             *     import "CoreLibs/graphics"
             *     import "CoreLibs/sprites"
             *
             *     -- Creating a tags object, to keep track of tags more easily
             *     TAGS = {
             *         player = 1,
             *         obstacle = 2,
             *         coin = 3,
             *         powerUp = 4
             *     }
             *
             *     -- Creating a player sprite we can move around and collide things with
             *     local playerImage = playdate.graphics.image.new(20, 20)
             *     playdate.graphics.pushContext(playerImage)
             *         playdate.graphics.fillCircleInRect(0, 0, playerImage:getSize())
             *     playdate.graphics.popContext()
             *     local playerSprite = playdate.graphics.sprite.new(playerImage)
             *     -- Setting a tag on the player, so we can check the tag to see if we're colliding against the player
             *     playerSprite:setTag(TAGS.player)
             *     playerSprite:moveTo(200, 120)
             *     -- Remember to set a collision rect, or this all doesn't work!
             *     playerSprite:setCollideRect(0, 0, playerSprite:getSize())
             *     playerSprite:add()
             *
             *     -- Creating an obstacle sprite we can collide against
             *     local obstacleImage = playdate.graphics.image.new(20, 20, playdate.graphics.kColorBlack)
             *     local obstacleSprite = playdate.graphics.sprite.new(obstacleImage)
             *     -- Setting a tag for the obstacle as well
             *     obstacleSprite:setTag(TAGS.obstacle)
             *     obstacleSprite:moveTo(300, 120)
             *     -- Can't forget this!
             *     obstacleSprite:setCollideRect(0, 0, obstacleSprite:getSize())
             *     obstacleSprite:add()
             *
             *     function playdate.update()
             *         playdate.graphics.sprite.update()
             *
             *         -- Some simple movement code for the sake of demonstration
             *         local moveSpeed = 3
             *         local goalX, goalY = playerSprite.x, playerSprite.y
             *         if playdate.buttonIsPressed(playdate.kButtonUp) then
             *             goalY -= moveSpeed
             *         elseif playdate.buttonIsPressed(playdate.kButtonDown) then
             *             goalY += moveSpeed
             *         elseif playdate.buttonIsPressed(playdate.kButtonLeft) then
             *             goalX -= moveSpeed
             *         elseif playdate.buttonIsPressed(playdate.kButtonRight) then
             *             goalX += moveSpeed
             *         end
             *
             *         -- Remember to use :moveWithCollisions(), and not :moveTo() or :moveBy(), or collisions won't happen!
             *         -- To do a "moveBy" operation, sprite:moveBy(5, 5) == sprite:moveWithCollisions(sprite.x + 5, sprite.y + 5)
             *         local actualX, actualY, collisions, numberOfCollisions = playerSprite:moveWithCollisions(goalX, goalY)
             *
             *         -- If we get into this loop, there was a collision
             *         for i=1, numberOfCollisions do
             *             -- This is getting data about one of things we're currently colliding with. Since we could
             *             -- be colliding with multiple things at once, we have to handle each collision individually
             *             local collision = collisions[i]
             *
             *             -- Always prints 'true', as the sprite property is the sprite being moved (in this case, the player)
             *             print(collision.sprite == playerSprite)
             *             -- Also prints 'true', as we set the tag on the player sprite to the player tag
             *             print(collision.sprite:getTag() == TAGS.player)
             *
             *             -- This gets the actual sprite object we're colliding with
             *             local collidedSprite = collision.other
             *             local collisionTag = collidedSprite:getTag()
             *             -- Since we set a tag on the obstacle, we can check if we're colliding with that
             *             if collisionTag == TAGS.obstacle then
             *                 print("Collided with an obstacle!")
             *
             *                 -- We can use the collision normal to check which side we collided with
             *                 local collisionNormal = collision.normal
             *                 if collisionNormal.x == -1 then
             *                     print("Touched left side!")
             *                 elseif collisionNormal.x == 1 then
             *                     print("Touched right side!")
             *                 end
             *
             *                 if collisionNormal.y == -1 then
             *                     print("Touched top!")
             *                 elseif collisionNormal.y == 1 then
             *                     print("Touched bottom!")
             *                 end
             *             -- Handle some other collisions, like collecting a coin or a power up
             *             elseif collisionTag == TAGS.coin then
             *                 print("Coin collected!")
             *             elseif collisionTag == TAGS.powerUp then
             *                 print("Powered up!")
             *             end
             *         end
             *     end
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.moveWithCollisions)
             */
            moveWithCollisions(
                goalPoint: playdate.geometry.point
            ): LuaMultiReturn<[number, number, PlaydateCollision[], number]>;

            /**
             * Returns the same values as [`moveWithCollisions()`](https://sdk.play.date/2.5.0#m-graphics.sprite.moveWithCollisions) but does not actually move the sprite.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.checkCollisions)
             */
            checkCollisions(
                x: number,
                y: number
            ): LuaMultiReturn<[number, number, PlaydateCollision[], number]>;
            /**
             * Returns the same values as [`moveWithCollisions()`](https://sdk.play.date/2.5.0#m-graphics.sprite.moveWithCollisions) but does not actually move the sprite.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.sprite.checkCollisions)
             */
            checkCollisions(
                point: playdate.geometry.point
            ): LuaMultiReturn<[number, number, PlaydateCollision[], number]>;

            /**
             * A callback that can be defined on a sprite to control the type of collision response that should happen when a collision with _other_ occurs. This callback should return one of the following four values:
             *
             * *   _playdate.graphics.sprite.kCollisionTypeSlide_: Use for collisions that should slide over other objects, like Super Mario does over a platform or the ground.
             *
             * *   _playdate.graphics.sprite.kCollisionTypeFreeze_: Use for collisions where the sprite should stop moving as soon as it collides with _other_, such as an arrow hitting a wall.
             *
             * *   _playdate.graphics.sprite.kCollisionTypeOverlap_: Use for collisions in which you want to know about the collision but it should not impact the movement of the sprite, such as when collecting a coin.
             *
             * *   _playdate.graphics.sprite.kCollisionTypeBounce_: Use when the sprite should move away from _other_, like the ball in Pong or Arkanoid.
             *
             *
             * The strings "slide", "freeze", "overlap", and "bounce" can be used instead of the constants.
             *
             * Feel free to return different values based on the value of _other_. For example, if _other_ is a wall sprite, you may want to return "slide" or "bounce", but if it’s a coin you might return "overlap".
             *
             * If the callback is not present, or returns nil, _kCollisionTypeFreeze_ is used.
             *
             * Tip
             *
             * Instead of defining a callback, the collisionResponse property of a sprite can be set directly to one of the four collision response types. This will be faster, as the lua function will not need to be called, but does not allow for dynamic behavior.
             *
             * This method should not attempt to modify the sprites in any way. While it might be tempting to deal with collisions here, doing so will have unexpected and undesirable results. Instead, this function should return one of the collision response values as quickly as possible. If sprites need to be modified as the result of a collision, do so elsewhere, such as by inspecting the list of collisions returned by [`moveWithCollisions()`](https://sdk.play.date/2.5.0#m-graphics.sprite.moveWithCollisions).
             *
             * [Read more](https://sdk.play.date/2.5.0#c-graphics.sprite.collisionResponse)
             */
            collisionResponse(
                other: playdate.graphics.sprite
            ): PlaydateCollisionResponse;
        }

        namespace font {
            /**
             * Returns a [playdate.graphics.font](https://sdk.play.date/2.5.0#C-graphics.font) object from the data at _path_. If there is no file at _path_, the function returns nil.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.font.new)
             *
             * @noSelf
             */
            export function _new(path: string): playdate.graphics.font;

            export { _new as new };

            /**
             * Returns a font family table from the font files specified in _fontPaths_. _fontPaths_ should be a table with the following format:
             *
             * local fontPaths = {
             *  \[playdate.graphics.font.kVariantNormal\] = "path/to/normalFont",
             *     \[playdate.graphics.font.kVariantBold\] = "path/to/boldFont",
             *     \[playdate.graphics.font.kVariantItalic\] = "path/to/italicFont"
             * }
             *
             * The table returned is of the same format with font objects in place of the paths, and is appropriate to pass to the functions [setFontFamily()](https://sdk.play.date/2.5.0#f-graphics.setFontFamily) and [getTextSize()](https://sdk.play.date/2.5.0#f-graphics.getTextSize).
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.font.newFamily)
             *
             * @noSelf
             */
            export function newFamily(
                fontPaths: PlaydateFontFamilyPaths
            ): PlaydateFontFamily;
        }

        class font {
            /**
             * Draws a string at the specified x, y coordinate using this particular font instance. (Compare to [playdate.graphics.drawText(text, x, y)](https://sdk.play.date/2.5.0#f-graphics.drawText), which draws the string with whatever the "current font", as defined by [playdate.graphics.setFont(font)](https://sdk.play.date/2.5.0#f-graphics.setFont)).
             *
             * The optional _leadingAdjustment_ may be used to modify the spacing between lines of text. Pass nil to use the default leading for the font.
             *
             * Returns `_width_`, `_height_`, indicating the size in pixels of the drawn text.
             *
             * Note
             *
             * `font:drawText()` does not support inline styles like bold and italics. Instead use [playdate.graphics.drawText()](https://sdk.play.date/2.5.0#f-graphics.drawText).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.font.drawText)
             */
            drawText(
                text: string,
                x: number,
                y: number,
                leadingAdjustment?: number
            ): void;

            /**
             * Important
             *
             * You must import _CoreLibs/graphics_ to use this function.
             *
             * Draws the string _text_ aligned to the left, right, or centered on the _x_ coordinate. Pass one of _kTextAlignment.left_, _kTextAlignment.center_, _kTextAlignment.right_ for the _alignment_ parameter. (Compare to [playdate.graphics.drawTextAligned(text, x, y, alignment)](https://sdk.play.date/2.5.0#f-graphics.drawTextAligned), which draws the string with the "current font", as defined by [playdate.graphics.setFont(font)](https://sdk.play.date/2.5.0#f-graphics.setFont)).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.font.drawTextAligned)
             */
            drawTextAligned(
                text: string,
                x: number,
                y: number,
                alignment: PlaydateTextAlignment,
                leadingAdjustment?: number
            ): void;

            /**
             * Returns the pixel height of this font.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.font.getHeight)
             */
            getHeight(): number;

            /**
             * Returns the pixel width of the text when rendered with this font.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.font.getTextWidth)
             */
            getTextWidth(text: string): number;

            /**
             * Sets the tracking of this font (spacing between letters), in pixels.
             *
             * Equivalent to [`playdate->graphics->setTextTracking()`](./Inside%20Playdate%20with%20C.html#f-graphics.setTextTracking) in the C API.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.font.setTracking)
             */
            setTracking(pixels: number): void;

            /**
             * Returns the tracking of this font (spacing between letters), in pixels.
             *
             * Equivalent to [`playdate->graphics->getTextTracking()`](./Inside%20Playdate%20with%20C.html#f-graphics.getTextTracking) in the C API.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.font.getTracking)
             */
            getTracking(): number;

            /**
             * Sets the leading (spacing between lines) of this font, in pixels.
             *
             * Equivalent to [`playdate->graphics->setTextLeading()`](./Inside%20Playdate%20with%20C.html#f-graphics.setTextLeading) in the C API.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.font.setLeading)
             */
            setLeading(pixels: number): void;

            /**
             * Returns the leading (spacing between lines) of this font, in pixels.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.font.getLeading)
             */
            getLeading(): number;

            /**
             * Returns the [`playdate.graphics.image`](https://sdk.play.date/2.5.0#C-graphics.image) containing the requested glyph. _character_ can either be a string or a unicode codepoint number.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.font.getGlyph)
             */
            getGlyph(character: string): playdate.graphics.image;
        }

        namespace video {
            /**
             * Returns a [playdate.graphics.video](https://sdk.play.date/2.5.0#C-graphics.video) object from the pdv file at _path_. If the file at _path_ can’t be opened, the function returns nil.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-graphics.video.new)
             *
             * @noSelf
             */
            export function _new(path: string): playdate.graphics.video;

            export { _new as new };
        }

        class video {
            /**
             * Returns the width and height of the video as multiple vlaues (_width_, _height_).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.video.getSize)
             */
            getSize(): LuaMultiReturn<[number, number]>;

            /**
             * Returns the number of frames in the video.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.video.getFrameCount)
             */
            getFrameCount(): number;

            /**
             * Returns the number of frames per second of the video source. This number is simply for record-keeping, it is not used internally—​the game code is responsible for figuring out which frame to show when.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.video.getFrameRate)
             */
            getFrameRate(): number;

            /**
             * Sets the given image to the video render context. Future `video:renderFrame()` calls will draw into this image.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.video.setContext)
             */
            setContext(image: playdate.graphics.image): void;

            /**
             * Returns the image into which the video will be rendered, creating it if needed.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.video.getContext)
             */
            getContext(): playdate.graphics.image;

            /**
             * Sets the display framebuffer as the video’s render context.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.video.useScreenContext)
             */
            useScreenContext(): void;

            /**
             * Draws the given frame into the video’s render context.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-graphics.video.renderFrame)
             */
            renderFrame(number: number): void;
        }
    }

    namespace keyboard {
        /**
         * Opens the keyboard, taking over input focus.
         *
         * _text_, if provided, will be used to set the initial text value of the keyboard.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-keyboard.show)
         *
         * @noSelf
         */
        export function show(text?: string): void;

        /**
         * Hides the keyboard.
         *
         * [Read more](https://sdk.play.date/2.5.0#m-keyboard.hide)
         *
         * @noSelf
         */
        export function hide(): void;

        /**
         * _behavior_ should be one of the constants _playdate.keyboard.kCapitalizationNormal_, _playdate.keyboard.kCapitalizationWords_, or _playdate.keyboard.kCapitalizationSentences_.
         *
         * In the case of _playdate.keyboard.kCapitalizationWords_, the keyboard selection will automatically move to the upper case column after a space is entered. For _playdate.keyboard.kCapitalizationSentences_ the selection will automatically move to the upper case column after a period and a space have been entered.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-keyboard.setCapitalizationBehavior)
         *
         * @noSelf
         */
        export function setCapitalizationBehavior(
            behavior: PlaydateCapitalizationBehavior
        ): void;

        /**
         * Returns the current x location of the left edge of the keyboard.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-keyboard.left)
         *
         * @noSelf
         */
        export function left(): number;

        /**
         * Returns the pixel width of the keyboard.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-keyboard.width)
         *
         * @noSelf
         */
        export function width(): number;

        /**
         * Returns true if the keyboard is currently being shown.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-keyboard.isVisible)
         *
         * @noSelf
         */
        export function isVisible(): boolean;

        /**
         * If set, this function will be called when the keyboard is finished the opening animation.
         *
         * [Read more](https://sdk.play.date/2.5.0#c-keyboard.keyboardDidShowCallback)
         *
         * @noSelf
         */
        export function keyboardDidShowCallback(): void;

        /**
         * If set, this function will be called when the keyboard has finished the hide animation.
         *
         * [Read more](https://sdk.play.date/2.5.0#c-keyboard.keyboardDidHideCallback)
         *
         * @noSelf
         */
        export function keyboardDidHideCallback(): void;

        /**
         * If set, this function will be called when the keyboard starts to close. A Boolean argument will be passed to the callback, `true` if the user selected "OK" close the keyboard, `false` otherwise.
         *
         * [Read more](https://sdk.play.date/2.5.0#c-keyboard.keyboardWillHideCallback)
         *
         * @noSelf
         */
        export function keyboardWillHideCallback(answer: boolean): void;

        /**
         * If set, this function is called as the keyboard animates open or closed. Provided as a way to sync animations with the keyboard movement.
         *
         * [Read more](https://sdk.play.date/2.5.0#c-keyboard.keyboardAnimatingCallback)
         *
         * @noSelf
         */
        export function keyboardAnimatingCallback(): void;

        /**
         * If set, this function will be called every time a character is entered or deleted.
         *
         * [Read more](https://sdk.play.date/2.5.0#c-keyboard.textChangedCallback)
         *
         * @noSelf
         */
        export function textChangedCallback(): void;

        /**
         * Access or set the text value of the keyboard.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-keyboard.text)
         */
        let text: string;
    }

    namespace math {
        /**
         * Returns a number that is the linear interpolation between _min_ and _max_ based on _t_, where _t = 0.0_ will return _min_ and _t = 1.0_ will return _max_.
         *
         * Important
         *
         * You must import _CoreLibs/math_ to use this function.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-math.lerp)
         *
         * @noSelf
         */
        export function lerp(min: number, max: number, t: number): number;
    }

    namespace pathfinder {
        namespace graph {
            /**
             * Returns a new empty [playdate.pathfinder.graph](https://sdk.play.date/2.5.0#C-playdate.pathfinder.graph) object.
             *
             * If `nodeCount` is supplied, that number of nodes will be allocated and added to the graph. Their IDs will be set from 1 to `nodeCount`.
             *
             * `coordinates`, if supplied, should be a table containing tables of x, y values, indexed by node IDs. For example, `{{10, 10}, {50, 30}, {20, 100}, {100, 120}, {160, 130}}`.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-pathfinder.graph.new)
             *
             * @noSelf
             */
            export function _new(
                nodeCount?: number,
                coordinates?: [number, number][]
            ): playdate.pathfinder.graph;

            export { _new as new };

            /**
             * Convenience function that returns a new [playdate.pathfinder.graph](https://sdk.play.date/2.5.0#C-playdate.pathfinder.graph) object containing nodes for for each grid position, even if not connected to any other nodes. This allows for easier graph modification once the graph is generated. Weights for connections between nodes are set to 10 for horizontal and vertical connections and 14 for diagonal connections (if included), as this tends to produce nicer paths than using uniform weights. Nodes have their indexes set from 1 to _width_ \* _height_, and have their _x, y_ values set appropriately for the node’s position.
             *
             * *   _width_: The width of the grid to be created.
             *
             * *   _height_: The height of the grid to be created.
             *
             * *   _allowDiagonals_: If true, diagonal connections will also be created.
             *
             * *   _includedNodes_: A one-dimensional array of length _width_ \* _height_. Each entry should be a 1 or a 0 to indicate nodes that should be connected to their neighbors and nodes that should not have any connections added. If not provided, all nodes will be connected to their neighbors.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-pathfinder.graph.new2DGrid)
             *
             * @noSelf
             */
            export function new2DGrid(
                width: number,
                height: number,
                allowDiagonals?: boolean,
                includedNodes?: (1 | 0)[]
            ): playdate.pathfinder.graph;
        }

        class graph {
            /**
             * Creates a new [playdate.pathfinder.node](https://sdk.play.date/2.5.0#C-playdate.pathfinder.node) and adds it to the graph.
             *
             * *   _id_: id value for the new node.
             *
             * *   _x_: Optional x value for the node.
             *
             * *   _y_: Optional y value for the node.
             *
             * *   _connectedNodes_: Array of existing nodes to create connections to from the new node.
             *
             * *   _weights_: Array of weights for the new connections. Array must be the same length as _connectedNodes_. Weights affect the path the A\* algorithm will solve for. A longer, lighter-weighted path will be chosen over a shorter heavier path, if available.
             *
             * *   _addReciprocalConnections_: If true, connections will also be added in the reverse direction for each node.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.graph.addNewNode)
             */
            addNewNode(
                id: number,
                x?: number,
                y: number,
                connectedNodes?: playdate.pathfinder.node[],
                weights: number[],
                addReciprocalConnections?: boolean
            ): void;

            /**
             * Creates _count_ new nodes, adding them to the graph, and returns them in an array-style table. The new node’s _id\_s will be assigned values 1 through \_count_\-1.
             *
             * This method is useful to improve performance if many nodes need to be allocated at once rather than one at a time, for example when creating a new graph.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.graph.addNewNodes)
             */
            addNewNodes(count: number): playdate.pathfinder.node[];

            /**
             * Adds an already-existing node to the graph. The node must have originally belonged to the same graph.
             *
             * *   _node_: Node to be added to the graph.
             *
             * *   _connectedNodes_: Array of existing nodes to create connections to from the new node.
             *
             * *   _weights_: Array of weights for the new connections. Array must be the same length as _connectedNodes_. Weights affect the path the A\* algorithm will solve for. A longer, lighter-weighted path will be chosen over a shorter heavier path, if available.
             *
             * *   _addReciprocalConnections_: If true, connections will also be added in the reverse direction for each connection added.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.graph.addNode)
             */
            addNode(
                node: playdate.pathfinder.node,
                connectedNodes?: playdate.pathfinder.node[],
                weights: number[],
                addReciprocalConnections?: boolean
            ): void;

            /**
             * Adds an array of already-existing nodes to the graph.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.graph.addNodes)
             */
            addNodes(nodes: playdate.pathfinder.node[]): void;

            /**
             * Returns an array containing all nodes in the graph.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.graph.allNodes)
             */
            allNodes(): playdate.pathfinder.node[];

            /**
             * Removes node from the graph. Also removes all connections to and from the node.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.graph.removeNode)
             */
            removeNode(node: playdate.pathfinder.node): void;

            /**
             * Returns the first node found with coordinates matching _x, y_, after removing it from the graph and removing all connections to and from the node.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.graph.removeNodeWithXY)
             */
            removeNodeWithXY(x: number, y: number): void;

            /**
             * Returns the first node found with a matching _id_, after removing it from the graph and removing all connections to and from the node.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.graph.removeNodeWithID)
             */
            removeNodeWithID(id: number): void;

            /**
             * Returns the first node found in the graph with a matching _id_, or nil if no such node is found.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.graph.nodeWithID)
             */
            nodeWithID(id: number): playdate.pathfinder.node;

            /**
             * Returns the first node found in the graph with matching _x_ and _y_ values, or nil if no such node is found.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.graph.nodeWithXY)
             */
            nodeWithXY(x: number, y: number): playdate.pathfinder.node;

            /**
             * `connections` should be a table of array-style tables. The keys of the outer table should correspond to node IDs, while the inner array should be a series if connecting node ID and weight combinations that will be assigned to that node. For example, `{[1]={2, 10, 3, 12}, [2]={1, 20}, [3]={1, 20, 2, 10}}` will create a connection from node ID 1 to node ID 2 with a weight of 10, and a connection to node ID 3 with a weight of 12, and so on for the other entries.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.graph.addConnections)
             */
            addConnections(connections: Record<number, number[]>): void;

            /**
             * Adds a connection from the node with `id` `fromNodeID` to the node with `id` `toNodeID` with a weight value of `weight`. Weights affect the path the A\* algorithm will solve for. A longer, lighter-weighted path will be chosen over a shorter heavier path, if available. If `addReciprocalConnection` is true, the reverse connection will also be added.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.graph.addConnectionToNodeWithID)
             */
            addConnectionToNodeWithID(
                fromNodeID: number,
                toNodeID: number,
                weight: number,
                addReciprocalConnection: boolean
            ): void;

            /**
             * Removes all connections from all nodes in the graph.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.graph.removeAllConnections)
             */
            removeAllConnections(): void;

            /**
             * Removes all connections from the matching node.
             *
             * If `removeIncoming` is true, all connections from other nodes to the calling node are also removed. False by default. Please note: this can signficantly increase the time this function takes as it requires a full search of the graph - O(1) vs O(n)).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.graph.removeAllConnectionsFromNodeWithID)
             */
            removeAllConnectionsFromNodeWithID(
                id: number,
                removeIncoming?: boolean
            ): void;

            /**
             * Returns an array of nodes representing the path from _startNode_ to _goalNode_, or _nil_ if no path can be found.
             *
             * *   _heuristicFunction_: If provided, this function should be of the form _function(startNode, goalNode)_ and should return an integer value estimate or underestimate of the distance from _startNode_ to _goalNode_. If not provided, a manhattan distance function will be used to calculate the estimate. This requires that the _x, y_ values of the nodes in the graph have been set properly.
             *
             * *   _findPathToGoalAdjacentNodes_: If true, a path will be found to any node adjacent to the goal node, based on the _x, y_ values of those nodes and the goal node. This does not rely on connections between adjacent nodes and the goal node, which can be entirely disconnected from the rest of the graph.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.graph.findPath)
             */
            findPath(
                startNode: playdate.pathfinder.node,
                goalNode: playdate.pathfinder.node,
                heuristicFunction?: (
                    startNode: playdate.pathfinder.node,
                    goalNode: playdate.pathfinder.node
                ) => number,
                findPathToGoalAdjacentNodes?: boolean
            ): playdate.pathfinder.node[] | null;

            /**
             * Works the same as [findPath](https://sdk.play.date/2.5.0#m-pathfinder.graph.findPath), but looks up nodes to find a path between using startNodeID and goalNodeID and returns a list of nodeIDs rather than the nodes themselves.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.graph.findPathWithIDs)
             */
            findPathWithIDs(
                startNodeID: number,
                goalNodeID: number,
                heuristicFunction?: (
                    startNode: playdate.pathfinder.node,
                    goalNode: playdate.pathfinder.node
                ) => number,
                findPathToGoalAdjacentNodes?: boolean
            ): playdate.pathfinder.node[] | null;

            /**
             * Sets the matching node’s `x` and `y` values.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.graph.setXYForNodeWithID)
             */
            setXYForNodeWithID(id: number, x: number, y: number): void;
        }

        namespace node {}

        class node {
            /**
             * Adds a new connection between nodes.
             *
             * *   _node_: The node the new connection will point to.
             *
             * *   _weight_: Weight for the new connection. Weights affect the path the A\* algorithm will solve for. A longer, lighter-weighted path will be chosen over a shorter heavier path, if available.
             *
             * *   _addReciprocalConnection_: If true, a second connection will be created with the same weight in the opposite direction.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.node.addConnection)
             */
            addConnection(
                node: playdate.pathfinder.node,
                weight: number,
                addReciprocalConnection: boolean
            ): void;

            /**
             * Adds a new connection to each node in the nodes array.
             *
             * *   _nodes_: An array of nodes which the new connections will point to.
             *
             * *   _weights_: An array of weights for the new connections. Must be of the same length as the nodes array. Weights affect the path the A\* algorithm will solve for. A longer, lighter-weighted path will be chosen over a shorter heavier path, if available.
             *
             * *   _addReciprocalConnections_: If true, connections will also be added in the reverse direction for each node.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.node.addConnections)
             */
            addConnections(
                nodes: playdate.pathfinder.node[],
                weights: number[],
                addReciprocalConnections: boolean
            ): void;

            /**
             * Adds a connection to the first node found with matching _x_ and _y_ values, if it exists.
             *
             * *   _weight_: The weight for the new connection. Weights affect the path the A\* algorithm will solve for. A longer, lighter-weighted path will be chosen over a shorter heavier path, if available.
             *
             * *   _addReciprocalConnections_: If true, a connection will also be added in the reverse direction, from the node at x, y to the caller.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.node.addConnectionToNodeWithXY)
             */
            addConnectionToNodeWithXY(
                x: number,
                y: number,
                weight: number,
                addReciprocalConnection: boolean
            ): void;

            /**
             * Returns an array of nodes that have been added as connections to this node.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.node.connectedNodes)
             */
            connectedNodes(): playdate.pathfinder.node[];

            /**
             * Removes a connection to node, if it exists. If _removeReciprocal_ is true the reverse connection will also be removed, if it exists.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.node.removeConnection)
             */
            removeConnection(
                node: playdate.pathfinder.node,
                removeReciprocal?: boolean = false
            ): void;

            /**
             * Removes all connections from the calling node.
             *
             * If `removeIncoming` is true, all connections from other nodes to the calling node are also removed. False by default. Please note: this can signficantly increase the time this function takes as it requires a full search of the graph - O(1) vs O(n)).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.node.removeAllConnections)
             */
            removeAllConnections(removeIncoming?: boolean = false): void;

            /**
             * Sets the _x_ and _y_ values for the node.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-pathfinder.node.setXY)
             */
            setXY(x: number, y: number): void;
        }
    }

    namespace simulator {
        /**
         * Writes an image to a PNG file at the path specified. Only available on the Simulator.
         *
         * Note
         *
         * _path_ represents a path on your development computer, not the Playdate filesystem. It’s recommended you prefix your path with `~/` to ensure you are writing to a writeable directory, for example, `~/myImageFile.png`. Please include the `.png` file extension in your path name. Any directories in your path must already exist on your development computer in order for the file to be written.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-simulator.writeToFile)
         *
         * @noSelf
         */
        export function writeToFile(
            image: playdate.graphics.image,
            path: string
        ): void;

        /**
         * Quits the Playdate Simulator app.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-simulator.exit)
         *
         * @noSelf
         */
        export function exit(): void;

        /**
         * Returns the contents of the URL _url_ as a string.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-simulator.getURL)
         *
         * @noSelf
         */
        export function getURL(url: string): string;
    }

    namespace sound {
        /**
         * Returns the sample rate of the audio system (44100). The sample rate is determined by the hardware, and is not currently mutable.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-sound.getSampleRate)
         *
         * @noSelf
         */
        export function getSampleRate(): number;

        /**
         * Returns a list of all sources currently playing.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-sound.playingSources)
         *
         * @noSelf
         */
        export function playingSources(): PlaydateAudioSource[];

        /**
         * Adds the given [playdate.sound.effect](https://sdk.play.date/2.5.0#C-sound.effect) to the default sound channel.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-sound.addEffect)
         *
         * @noSelf
         */
        export function addEffect(effect: PlaydateSoundEffect): void;

        /**
         * Removes the given effect from the default sound channel.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-sound.removeEffect)
         *
         * @noSelf
         */
        export function removeEffect(effect: PlaydateSoundEffect): void;

        /**
         * Returns a pair of booleans (headphone, mic) indicating whether headphones are plugged in, and if so whether they have a microphone attached. If _changeCallback_ is a function, it will be called every time the headphone state changes, until it is cleared by calling `playdate.sound.getHeadphoneState(nil)`. If a change callback is set, the audio does **not** automatically switch from speaker to headphones when headphones are plugged in (and vice versa), so the callback should use `playdate.sound.setOutputsActive()` to change the output if needed. The callback is passed two booleans, matching the return values from `getHeadphoneState()`: the first `true` if headphones are connect, and the second `true` if the headphones have a microphone.
         *
         * Equivalent to [`playdate->sound->getHeadphoneState()`](./Inside%20Playdate%20with%20C.html#f-sound.getHeadphoneState) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-sound.getHeadphoneState)
         *
         * @noSelf
         */
        export function getHeadphoneState(
            changeCallback: ((headphone: boolean, mic: boolean) => void) | null
        ): LuaMultiReturn<[boolean, boolean]>;

        /**
         * Forces sound to be played on the headphones or on the speaker, regardless of whether headphones are plugged in or not. (With the caveat that it is not actually possible to play on the headphones if they’re not plugged in.) This function has no effect in the Simulator.
         *
         * Equivalent to [`playdate->sound->setOutputsActive()`](./Inside%20Playdate%20with%20C.html#f-sound.setOutputsActive) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-sound.setOutputsActive)
         *
         * @noSelf
         */
        export function setOutputsActive(
            headphones: boolean,
            speaker: boolean
        ): void;

        /**
         * Returns the current time, in seconds, as measured by the audio device. The audio device uses its own time base in order to provide accurate timing.
         *
         * Equivalent to [`playdate->sound->getCurrentTime()`](./Inside%20Playdate%20with%20C.html#f-sound.getCurrentTime) in the C API.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-sound.getCurrentTime)
         *
         * @noSelf
         */
        export function getCurrentTime(): number;

        /**
         * Resets the audio output device time counter.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-sound.resetTime)
         *
         * @noSelf
         */
        export function resetTime(): void;

        namespace sampleplayer {
            /**
             * Returns a new playdate.sound.sampleplayer object, with the sound data loaded in memory. If the sample can’t be loaded, the function returns nil and a second value containing the error.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.sampleplayer.new)
             *
             * @noSelf
             */
            export function _new(path: string): playdate.sound.sampleplayer;

            export { _new as new };

            /**
             * Returns a new playdate.sound.sampleplayer object for playing the given [sample](https://sdk.play.date/2.5.0#C-sound.sample).
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.sampleplayer.new-1)
             *
             * @noSelf
             */
            export function _new(
                sample: playdate.sound.sample
            ): playdate.sound.sampleplayer;

            export { _new as new };
        }

        class sampleplayer {
            /**
             * Returns a new playdate.sound.sampleplayer with the same sample, volume, and rate as the given sampleplayer.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sampleplayer.copy)
             */
            copy(): playdate.sound.sampleplayer;

            /**
             * Starts playing the sample. If _repeatCount_ is greater than one, it loops the given number of times. If zero, it loops endlessly until it is stopped with [playdate.sound.sampleplayer:stop()](https://sdk.play.date/2.5.0#m-sound.sampleplayer.stop). If _rate_ is set, the sample will be played at the given rate instead of the rate previous set with [playdate.sound.sampleplayer.setRate()](https://sdk.play.date/2.5.0#m-sound.sampleplayer.setRate).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sampleplayer.play)
             */
            play(repeatCount?: number, rate?: number): void;

            /**
             * Schedules the sound for playing at device time _when_. If _vol_ is specified, the sample will be played at level _vol_ (with optional separate right channel volume _rightvol_), otherwise it plays at the volume set by [playdate.sound.sampleplayer.setVolume()](https://sdk.play.date/2.5.0#m-sound.sampleplayer.setVolume). Note that the _when_ argument is an offset in the audio device’s time scale, as returned by [playdate.sound.getCurrentTime()](https://sdk.play.date/2.5.0#f-sound.getCurrentTime); it is **not** relative to the current time! If _when_ is less than the current audio time, the sample is played immediately. If _rate_ is set, the sample will be played at the given rate instead of the rate previously set with [playdate.sound.sampleplayer.setRate()](https://sdk.play.date/2.5.0#m-sound.sampleplayer.setRate).
             *
             * Only one event can be queued at a time. If `playAt()` is called while another event is queued, it will overwrite it with the new values.
             *
             * The function returns true if the sample was successfully added to the sound channel, otherwise false (i.e., if the channel is full).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sampleplayer.playAt)
             */
            playAt(
                when: number,
                vol?: number,
                rightvol?: number,
                rate?: number
            ): boolean;

            /**
             * Sets the playback volume (0.0 - 1.0) for left and right channels. If the optional _right_ argument is omitted, it is the same as _left_. If the sampleplayer is currently playing using the default volume (that is, it wasn’t triggered by `playAt()` with a volume given) it also changes the volume of the playing sample.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sampleplayer.setVolume)
             */
            setVolume(left: number, right?: number): void;

            /**
             * Returns the playback volume for the sampleplayer, a single value for mono sources or a pair of values (left, right) for stereo sources.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sampleplayer.getVolume)
             */
            getVolume():
                | LuaMultiReturn<[number, undefined]>
                | LuaMultiReturn<[number, number]>;

            /**
             * Sets a function to be called every time the sample loops. The sample object is passed to this function as the first argument, and the optional _arg_ argument is passed as the second.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sampleplayer.setLoopCallback)
             */
            setLoopCallback<TArgument>(
                callback: (
                    sample: playdate.sound.sample,
                    arg: TArgument
                ) => void,
                arg?: TArgument
            ): void;

            /**
             * Sets the range of the sample to play. _start_ and _end_ are frame offsets from the beginning of the sample.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sampleplayer.setPlayRange)
             */
            setPlayRange(start: number, end: number): void;

            /**
             * Pauses or resumes playback.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sampleplayer.setPaused)
             */
            setPaused(flag: boolean): void;

            /**
             * Returns a boolean indicating whether the sample is playing.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sampleplayer.isPlaying)
             */
            isPlaying(): boolean;

            /**
             * Stops playing the sample.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sampleplayer.stop)
             */
            stop(): void;

            /**
             * Sets a function to be called when playback has completed. The sample object is passed to this function as the first argument, and the optional _arg_ argument is passed as the second.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sampleplayer.setFinishCallback)
             */
            setFinishCallback<TArgument>(
                func: (sample: playdate.sound.sample, arg: TArgument) => void,
                arg?: TArgument
            ): void;

            /**
             * Sets the [sample](https://sdk.play.date/2.5.0#C-sound.sample) to be played.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sampleplayer.setSample)
             */
            setSample(sample: playdate.sound.sample): void;

            /**
             * Gets the [sample](https://sdk.play.date/2.5.0#C-sound.sample) to be played.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sampleplayer.getSample)
             */
            getSample(): playdate.sound.sample;

            /**
             * Returns the length of the sampleplayer’s sample, in seconds. Length is not scaled by playback rate.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sampleplayer.getLength)
             */
            getLength(): number;

            /**
             * Sets the playback rate for the sample. 1.0 is normal speed, 0.5 is down an octave, 2.0 is up an octave, etc. Sampleplayers can also play samples backwards, by setting a negative rate; note, however, this does not work with ADPCM-encoded files.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sampleplayer.setRate)
             */
            setRate(rate: number): void;

            /**
             * Returns the playback rate for the sample.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sampleplayer.getRate)
             */
            getRate(): number;

            /**
             * Sets the [signal](https://sdk.play.date/2.5.0#C-sound.signal) to use as a rate modulator, added to the rate set with [playdate.sound.sampleplayer:setRate()](https://sdk.play.date/2.5.0#m-sound.sampleplayer.setRate). Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sampleplayer.setRateMod)
             */
            setRateMod(signal: playdate.sound.signal | null): void;

            /**
             * Sets the current offset of the sampleplayer, in seconds. This value is not adjusted for rate.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sampleplayer.setOffset)
             */
            setOffset(seconds: number): void;

            /**
             * Returns the current offset of the sampleplayer, in seconds. This value is not adjusted for rate.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sampleplayer.getOffset)
             */
            getOffset(): number;
        }

        namespace fileplayer {
            /**
             * Returns a fileplayer object, which can stream samples from disk. The file to play is set with the [playdate.sound.fileplayer:load()](https://sdk.play.date/2.5.0#m-sound.fileplayer.load) function.
             *
             * If given, _buffersize_ specifies the size in seconds of the fileplayer’s data buffer. A shorter value reduces the latency of a [playdate.sound.fileplayer:setOffset()](https://sdk.play.date/2.5.0#m-sound.fileplayer.setOffset) call, but increases the chance of a buffer underrun.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.fileplayer.new-empty)
             *
             * @noSelf
             */
            export function _new(
                buffersize?: number
            ): playdate.sound.fileplayer;

            export { _new as new };

            /**
             * Returns a fileplayer object for streaming samples from the file at _path_. Note that the file isn’t loaded until [playdate.sound.fileplayer:play()](https://sdk.play.date/2.5.0#m-sound.fileplayer.play) or [playdate.sound.fileplayer:setBufferSize()](https://sdk.play.date/2.5.0#m-sound.fileplayer.setBufferSize) is called, in order to reduce initialization overhead.
             *
             * If given, _buffersize_ specifies the size in seconds of the fileplayer’s data buffer. A shorter value reduces the latency of a [playdate.sound.fileplayer:setOffset()](https://sdk.play.date/2.5.0#m-sound.fileplayer.setOffset) call, but increases the chance of a buffer underrun.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.fileplayer.new)
             *
             * @noSelf
             */
            export function _new(
                path: string,
                buffersize?: number
            ): playdate.sound.fileplayer;

            export { _new as new };
        }

        class fileplayer {
            /**
             * Instructs the fileplayer to load the file at _path_ when [play()](https://sdk.play.date/2.5.0#m-sound.fileplayer.play) is called on it. The fileplayer must not be playing when this function is called. The fileplayer’s play offset is reset to the beginning of the file, and its loop range is cleared.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.fileplayer.load)
             */
            load(path: string): void;

            /**
             * Opens and starts playing the file, first creating and filling a 1/4 second playback buffer if a buffer size hasn’t been set yet.
             *
             * If repeatCount is set, playback repeats when it reaches the end of the file or the end of the [loop range](https://sdk.play.date/2.5.0#m-sound.fileplayer.setLoopRange) if one is set. After the loop has run _repeatCount_ times, it continues playing to the end of the file. A _repeatCount_ of zero loops endlessly. If repeatCount is not set, the file plays once.
             *
             * The function returns true if the file was successfully opened and the fileplayer added to the sound channel, otherwise false and a string describing the error.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.fileplayer.play)
             */
            play(
                repeatCount?: number
            ):
                | LuaMultiReturn<[true, undefined]>
                | LuaMultiReturn<[false, string]>;

            /**
             * Stops playing the file, resets the playback offset to zero, and calls the finish callback.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.fileplayer.stop)
             */
            stop(): void;

            /**
             * Stops playing the file. A subsequent play() call resumes playback from where it was paused.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.fileplayer.pause)
             */
            pause(): void;

            /**
             * Returns a boolean indicating whether the fileplayer is playing.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.fileplayer.isPlaying)
             */
            isPlaying(): boolean;

            /**
             * Returns the length, in seconds, of the audio file.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.fileplayer.getLength)
             */
            getLength(): number;

            /**
             * Sets a function to be called when playback has completed. The fileplayer is passed as the first argument to _func_. The optional argument _arg_ is passed as the second.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.fileplayer.setFinishCallback)
             */
            setFinishCallback<TArgument>(
                func: (
                    fileplayer: playdate.sound.fileplayer,
                    arg: TArgument
                ) => void,
                arg?: TArgument
            ): void;

            /**
             * Returns the fileplayer’s underrun flag, indicating that the player ran out of data. This can be checked in the finish callback function to check for an underrun error.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.fileplayer.didUnderrun)
             */
            didUnderrun(): boolean;

            /**
             * By default, the fileplayer stops playback if it can’t provide data fast enough. Setting the flag to _false_ tells the fileplayer to restart playback (after an audible stutter) as soon as data is available.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.fileplayer.setStopOnUnderrun)
             */
            setStopOnUnderrun(flag: boolean): void;

            /**
             * Provides a way to loop a portion of an audio file. In the following code:
             *
             *     local fp = playdate.sound.fileplayer.new( "myaudiofile" )
             *     fp:setLoopRange( 10, 20 )
             *     fp:play( 3 )
             *
             * …the fileplayer will start playing from the beginning of the audio file, loop the 10-20 second range three times, and then stop playing.
             *
             * _start_ and _end_ are specified in seconds. If _end_ is omitted, the end of the file is used. If the function _loopCallback_ is provided, it is called every time the player loops, with the fileplayer as the first argument and the optional _arg_ argument as the second.
             *
             * Important
             *
             * The [fileplayer:play(\[repeatCount\])](https://sdk.play.date/2.5.0#m-sound.fileplayer.play) call needs to be invoked with a _repeatCount_ value of 0 (infinite looping), or 2 or greater in order for the looping action to happen.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.fileplayer.setLoopRange)
             */
            setLoopRange<TArgument>(
                start: number,
                end?: number,
                loopCallback?: (
                    fileplayer: playdate.sound.fileplayer,
                    arg: TArgument
                ) => void,
                arg?: TArgument
            ): void;

            /**
             * Sets a function to be called every time the fileplayer loops. The fileplayer object is passed to this function as the first argument, and _arg_ as the second.
             *
             * Important
             *
             * The [fileplayer:play(\[repeatCount\])](https://sdk.play.date/2.5.0#m-sound.fileplayer.play) call needs to be invoked with a _repeatCount_ value of 0 (infinite looping), or 2 or greater in order for the loop callback to be invoked.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.fileplayer.setLoopCallback)
             */
            setLoopCallback<TArgument>(
                callback: (
                    fileplayer: playdate.sound.fileplayer,
                    arg: TArgument
                ) => void,
                arg?: TArgument
            ): void;

            /**
             * Sets the buffer size for the fileplayer, in seconds. Larger buffers protect against buffer underruns, but consume more memory. Calling this function also fills the output buffer if a source file has been set. On success, the function returns _true_; otherwise it returns _false_ and a string describing the error.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.fileplayer.setBufferSize)
             */
            setBufferSize(
                seconds: number
            ):
                | LuaMultiReturn<[true, undefined]>
                | LuaMultiReturn<[false, string]>;

            /**
             * Sets the playback rate for the file. 1.0 is normal speed, 0.5 is down an octave, 2.0 is up an octave, etc. Unlike sampleplayers, fileplayers can’t play in reverse (i.e., rate < 0).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.fileplayer.setRate)
             */
            setRate(rate: number): void;

            /**
             * Returns the playback rate for the file. as set with `setRate()`.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.fileplayer.getRate)
             */
            getRate(): number;

            /**
             * Sets the [signal](https://sdk.play.date/2.5.0#C-sound.signal) to use as a rate modulator, added to the rate set with [playdate.sound.fileplayer:setRate()](https://sdk.play.date/2.5.0#m-sound.fileplayer.setRate). Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.fileplayer.setRateMod)
             */
            setRateMod(signal: playdate.sound.signal | null): void;

            /**
             * Sets the playback volume (0.0 - 1.0). If a single value is passed in, both left side and right side volume are set to the given value. If two values are given, volumes are set separately. The optional _fadeSeconds_ specifies the time it takes to fade from the current volume to the specified volume, in seconds. If the function _fadeCallback_ is given, it is called when the volume fade has completed. The fileplayer object is passed as the first argument to the callback, and the optional _arg_ argument is passed as the second.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.fileplayer.setVolume)
             */
            setVolume<TArgument>(
                left: number,
                right?: number,
                fadeSeconds?: number,
                fadeCallback?: (
                    fileplayer: playdate.sound.fileplayer,
                    arg: TArgument
                ) => void,
                arg?: TArgument
            ): void;

            /**
             * Returns the current volume for the fileplayer, a single value for mono sources or a pair of values (left, right) for stereo sources.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.fileplayer.getVolume)
             */
            getVolume():
                | LuaMultiReturn<[number, undefined]>
                | LuaMultiReturn<[number, number]>;

            /**
             * Sets the current offset of the fileplayer, in seconds. This value is not adjusted for rate.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.fileplayer.setOffset)
             */
            setOffset(seconds: number): void;

            /**
             * Returns the current offset of the fileplayer, in seconds. This value is not adjusted for rate.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.fileplayer.getOffset)
             */
            getOffset(): number;
        }

        namespace sample {
            /**
             * Returns a new playdate.sound.sample object, with the sound data loaded in memory. If the sample can’t be loaded, the function returns nil and a second value containing the error.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.sample.new-path)
             *
             * @noSelf
             */
            export function _new(path: string): playdate.sound.sample;

            export { _new as new };

            /**
             * Returns a new playdate.sound.sample object, with a buffer size of _seconds_ in the given format. If _format_ is not specified, it defaults to [playdate.sound.kFormat16bitStereo](https://sdk.play.date/2.5.0#m-sound.sample.getFormat). When used with playdate.sound.sample:load(), this allows you to swap in a different sample without re-allocating the buffer, which could lead to memory fragmentation.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.sample.new)
             *
             * @noSelf
             */
            export function _new(
                seconds: number,
                format?: PlaydateSoundFormat = PlaydateSoundFormat[
                    '16bitStereo'
                ]
            ): playdate.sound.sample;

            export { _new as new };
        }

        class sample {
            /**
             * Returns a new subsample containing a subrange of the given sample. Offset values are in frames, not bytes.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sample.getSubsample)
             */
            getSubsample(
                startOffset: number,
                endOffset: number
            ): playdate.sound.sample;

            /**
             * Loads the sound data from the file at _path_ into an existing sample buffer. If there is no file at _path_, the function returns nil.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sample.load)
             */
            load(path: string): void;

            /**
             * If the sample is ADPCM compressed, decompresses the sample data to 16-bit PCM data. This increases the sample’s memory footprint by 4x and does not affect the quality in any way, but it is necessary if you want to use the sample in a synth or play the file backwards. Returns `true` if successful, or `false` and an error message as a second return value if decompression failed.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sample.decompress)
             */
            decompress():
                | LuaMultiReturn<[true, undefined]>
                | LuaMultiReturn<[false, string]>;

            /**
             * Returns the sample rate as an integer, such as 44100 or 22050.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sample.getSampleRate)
             */
            getSampleRate(): number;

            /**
             * Returns the format of the sample, one of
             *
             * *   _playdate.sound.kFormat8bitMono_
             *
             * *   _playdate.sound.kFormat8bitStereo_
             *
             * *   _playdate.sound.kFormat16bitMono_
             *
             * *   _playdate.sound.kFormat16bitStereo_
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sample.getFormat)
             */
            getFormat(): PlaydateSoundFormat;

            /**
             * Returns two values, the length of the available sample data and the size of the allocated buffer. Both values are measured in seconds. For a sample loaded from disk, these will be the same; for a sample used for recording, the available data may be less than the allocated size.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sample.getLength)
             */
            getLength(): LuaMultiReturn<[number, number]>;

            /**
             * Convenience function: Creates a new sampleplayer for the sample and passes the function arguments to its [play](https://sdk.play.date/2.5.0#m-sound.sampleplayer.play) function.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sample.play)
             */
            play(
                repeatCount?: number,
                rate?: number
            ): playdate.sound.sampleplayer;

            /**
             * Convenience function: Creates a new sampleplayer for the sample and passes the function arguments to its [playAt](https://sdk.play.date/2.5.0#m-sound.sampleplayer.playAt) function.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sample.playAt)
             */
            playAt(
                when: number,
                vol?: number,
                rightvol?: number,
                rate?: number
            ): playdate.sound.sampleplayer;

            /**
             * Saves the sample to the given file. If `filename` has a `.wav` extension it will be saved in WAV format (and be unreadable by the Playdate sound functions), otherwise it will be saved in the Playdate pda format.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sample.save)
             */
            save(filename: string): void;
        }

        namespace channel {
            /**
             * Returns a new channel object and adds it to the global list.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.channel.new)
             *
             * @noSelf
             */
            export function _new(): playdate.sound.channel;

            export { _new as new };
        }

        class channel {
            /**
             * Removes the channel from the global list.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.channel.remove)
             */
            remove(): void;

            /**
             * Adds an [effect](https://sdk.play.date/2.5.0#C-sound.effect) to the channel.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.channel.addEffect)
             */
            addEffect(effect: PlaydateSoundEffect): void;

            /**
             * Removes an [effect](https://sdk.play.date/2.5.0#C-sound.effect) from the channel.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.channel.removeEffect)
             */
            removeEffect(effect: PlaydateSoundEffect): void;

            /**
             * Adds a [source](https://sdk.play.date/2.5.0#C-sound.source) to the channel. If a source is not assigned to a channel, it plays on the default global channel.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.channel.addSource)
             */
            addSource(source: PlaydateAudioSource): void;

            /**
             * Removes a [source](https://sdk.play.date/2.5.0#C-sound.source) from the channel.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.channel.removeSource)
             */
            removeSource(source: PlaydateAudioSource): void;

            /**
             * Sets the volume (0.0 - 1.0) for the channel.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.channel.setVolume)
             */
            setVolume(volume: number): void;

            /**
             * Gets the volume (0.0 - 1.0) for the channel.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.channel.getVolume)
             */
            getVolume(): number;

            /**
             * Sets the pan parameter for the channel. -1 is left, 0 is center, and 1 is right.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.channel.setPan)
             */
            setPan(pan: number): void;

            /**
             * Sets a [signal](https://sdk.play.date/2.5.0#C-sound.signal) to automate the pan parameter. Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.channel.setPanMod)
             */
            setPanMod(signal: playdate.sound.signal | null): void;

            /**
             * Sets a [signal](https://sdk.play.date/2.5.0#C-sound.signal) to automate the volume parameter. Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.channel.setVolumeMod)
             */
            setVolumeMod(signal: playdate.sound.signal | null): void;
        }

        namespace synth {
            /**
             * Returns a new synth object to play a waveform or wavetable. See [playdate.sound.synth:setWaveform](https://sdk.play.date/2.5.0#m-sound.synth.setWaveform) for `waveform` values.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.synth.new_w)
             *
             * @noSelf
             */
            export function _new(
                waveform?: PlaydateSoundWave
            ): playdate.sound.synth;

            export { _new as new };

            /**
             * Returns a new synth object to play a [Sample](https://sdk.play.date/2.5.0#C-sound.sample). An optional sustain region (measured in samples) defines a loop to play while the note is on. Sample data must be uncompressed PCM, not ADPCM.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.synth.new)
             *
             * @noSelf
             */
            export function _new(
                sample: playdate.sound.sample,
                sustainStart?: number,
                sustainEnd?: number
            ): playdate.sound.synth;

            export { _new as new };
        }

        class synth {
            /**
             * Returns a copy of the given synth.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.copy)
             */
            copy(): playdate.sound.synth;

            /**
             * Plays a note with the current waveform or sample.
             *
             * *   _pitch_: the pitch value is in Hertz. If a sample is playing, pitch=261.63 (C4) plays at normal speed
             *
             *     *   in either function, a string like `Db3` can be used instead of a number
             *
             *
             * *   _volume_: 0 to 1, defaults to 1
             *
             * *   _length_: in seconds. If omitted, note will play until you call noteOff()
             *
             * *   _when_: seconds since the sound engine started (see [playdate.sound.getCurrentTime](https://sdk.play.date/2.5.0#f-sound.getCurrentTime)). Defaults to the current time.
             *
             *
             * The function returns true if the synth was successfully added to the sound channel, otherwise false (i.e., if the channel is full).
             *
             * If _pitch_ is zero, this function calls `noteOff()` instead of potentially adding a non-zero sample, or DC offset, to the output.
             *
             * Note
             *
             * Synths currently only have a buffer of one note event. If you call _playNote()_ while another note is waiting to play, it will replace that note. To create a sequence of notes to play over a period of time, see [playdate.sound.sequence](https://sdk.play.date/2.5.0#C-sound.sequence).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.playNote)
             */
            playNote(
                pitch: number,
                volume?: number,
                length?: number,
                when?: number
            ): boolean;

            /**
             * Identical to [playNote](https://sdk.play.date/2.5.0#m-sound.synth.playNote) but uses a note name like "C4", or MIDI note number (60=C4, 61=C#4, etc.). In the latter case, fractional values are allowed.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.playMIDINote)
             */
            playMIDINote(
                note: string,
                volume?: number,
                length?: number,
                when?: number
            ): boolean;

            /**
             * Releases the note, if one is playing. The note will continue to be voiced through the release section of the synth’s envelope.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.noteOff)
             */
            noteOff(): void;

            /**
             * Stops the synth immediately, without playing the release part of the envelope.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.stop)
             */
            stop(): void;

            /**
             * Returns true if the synth is still playing, including the release phase of the envelope.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.isPlaying)
             */
            isPlaying(): boolean;

            /**
             * Sets the [signal](https://sdk.play.date/2.5.0#C-sound.signal) to use as the amplitude modulator. Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.setAmplitudeMod)
             */
            setAmplitudeMod(signal: playdate.sound.signal | null): void;

            /**
             * Sets the attack time, decay time, sustain level, and release time for the sound envelope, and optionally the [curvature](https://sdk.play.date/2.5.0#m-sound.synth.setEnvelopeCurvature).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.setADSR)
             */
            setADSR(
                attack: number,
                decay: number,
                sustain: number,
                release: number
            ): void;

            /**
             * Sets the attack time, in seconds.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.setAttack)
             */
            setAttack(time: number): void;

            /**
             * Sets the decay time, in seconds.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.setDecay)
             */
            setDecay(time: number): void;

            /**
             * Sets the sustain level, as a proportion of the total level (0.0 to 1.0).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.setSustain)
             */
            setSustain(level: number): void;

            /**
             * Sets the release time, in seconds.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.setRelease)
             */
            setRelease(time: number): void;

            /**
             * Smoothly changes the envelope’s shape from linear (amount=0) to exponential (amount=1).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.setEnvelopeCurvature)
             */
            setEnvelopeCurvature(amount: number): void;

            /**
             * Returns the synth’s envelope as a [playdate.sound.envelope](https://sdk.play.date/2.5.0#C-sound.envelope) object.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.getEnvelope)
             */
            getEnvelope(): playdate.sound.envelope;

            /**
             * Sets a function to be called when the synth stops playing.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.setFinishCallback)
             */
            setFinishCallback(func: () => void): void;

            /**
             * Sets the [signal](https://sdk.play.date/2.5.0#C-sound.signal) to use as the frequency modulator. Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.setFrequencyMod)
             */
            setFrequencyMod(signal: playdate.sound.signal | null): void;

            /**
             * Sets whether to use legato phrasing for the synth. If the legato flag is set and a new note starts while a previous note is still playing, the synth’s envelope remains in the sustain phase instead of starting a new attack.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.setLegato)
             */
            setLegato(flag: boolean): void;

            /**
             * Sets the synth volume. If a single value is passed in, sets both left side and right side volume to the given value. If two values are given, volumes are set separately.
             *
             * Volume values are between 0.0 and 1.0.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.setVolume)
             */
            setVolume(left: number, right?: number): void;

            /**
             * Returns the current volume for the synth, a single value for mono sources or a pair of values (left, right) for stereo sources.
             *
             * Volume values are between 0.0 and 1.0.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.getVolume)
             */
            getVolume():
                | LuaMultiReturn<[number, undefined]>
                | LuaMultiReturn<[number, number]>;

            /**
             * Sets the waveform or [Sample](https://sdk.play.date/2.5.0#C-sound.sample) the synth plays. If a sample is given, its data must be uncompressed PCM, not ADPCM. Otherwise _waveform_ should be one of the following constants:
             *
             * *   _playdate.sound.kWaveSine_
             *
             * *   _playdate.sound.kWaveSquare_
             *
             * *   _playdate.sound.kWaveSawtooth_
             *
             * *   _playdate.sound.kWaveTriangle_
             *
             * *   _playdate.sound.kWaveNoise_
             *
             * *   _playdate.sound.kWavePOPhase_
             *
             * *   _playdate.sound.kWavePODigital_
             *
             * *   _playdate.sound.kWavePOVosim_
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.setWaveform)
             */
            setWaveform(
                waveform: PlaydateSoundWave | playdate.sound.sample
            ): void;

            /**
             * Sets a wavetable for the synth to play. Sample data must be 16-bit mono uncompressed. `samplesize` is the number of samples in each waveform "cell" in the table and must be a power of 2. `xsize` is the number of cells across the wavetable. If the wavetable is two-dimensional, `ysize` gives the number of cells in the y direction.
             *
             * The synth’s "position" in the wavetable is set manually with [setParameter()](https://sdk.play.date/2.5.0#m-sound.synth.setParameter) or automated with [setParameterModulator()](https://sdk.play.date/2.5.0#m-sound.synth.setParameterModulator). In some cases it’s easier to use a parameter that matches the waveform position in the table, in others (notably when using envelopes and lfos) it’s more convenient to use a 0-1 scale, so there’s some redundancy here. Parameters are
             *
             * *   1: x position, values are from 0 to the table width
             *
             * *   2: x position, values are from 0 to 1, parameter is scaled up to table width
             *
             *
             * For 2-D tables (`rowwidth` > 0):
             *
             * *   3: y position, values are from 0 to the table height
             *
             * *   4: y position, values are from 0 to 1, parameter is scaled up to table height
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.setWavetable)
             */
            setWavetable(
                sample: playdate.sound.sample,
                samplesize: number,
                xsize: number,
                ysize?: number
            ): void;

            /**
             * Sets the parameter at (1-based) position _num_ to the given value. Unless otherwise specified, _value_ ranges from 0 to 1.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.setParameter)
             */
            setParameter(parameter: number, value: number): void;

            /**
             * Sets the [signal](https://sdk.play.date/2.5.0#C-sound.signal) to modulate the parameter. Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.synth.setParameterMod)
             */
            setParameterMod(
                parameter: number,
                signal: playdate.sound.signal | null
            ): void;
        }

        namespace signal {}

        class signal {
            /**
             * Adds a constant offset to the signal (lfo, envelope, etc.).
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.signal.setOffset)
             */
            setOffset(offset: number): void;

            /**
             * Multiplies the signal’s output by the given scale factor. The scale is applied before the offset.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.signal.setScale)
             */
            setScale(scale: number): void;
        }

        namespace lfo {
            /**
             * Returns a new LFO object, which can be used to modulate sounds. See [playdate.sound.lfo:setType()](https://sdk.play.date/2.5.0#m-sound.lfo.setType) for LFO types.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.lfo.new)
             *
             * @noSelf
             */
            export function _new(
                type?: PlaydateSoundLfoType
            ): playdate.sound.lfo;

            export { _new as new };
        }

        class lfo {
            /**
             * Sets the waveform of the LFO. Valid values are
             *
             * *   _playdate.sound.kLFOSquare_
             *
             * *   _playdate.sound.kLFOSawtoothUp_
             *
             * *   _playdate.sound.kLFOSawtoothDown_
             *
             * *   _playdate.sound.kLFOTriangle_
             *
             * *   _playdate.sound.kLFOSine_
             *
             * *   _playdate.sound.kLFOSampleAndHold_
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.lfo.setType)
             */
            setType(type: PlaydateSoundWave): void;

            /**
             * Sets the LFO type to arpeggio, where the given values are in half-steps from the center note. For example, the sequence (0, 4, 7, 12) plays the notes of a major chord.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.lfo.setArpeggio)
             */
            setArpeggio(...notes: number): void;

            /**
             * Sets the center value of the LFO.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.lfo.setCenter)
             */
            setCenter(center: number): void;

            /**
             * Sets the depth of the LFO’s modulation.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.lfo.setDepth)
             */
            setDepth(depth: number): void;

            /**
             * Sets the rate of the LFO, in cycles per second.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.lfo.setRate)
             */
            setRate(rate: number): void;

            /**
             * Sets the current phase of the LFO, from 0 to 1.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.lfo.setPhase)
             */
            setPhase(phase: number): void;

            /**
             * Sets the initial phase of the LFO, from 0 to 1.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.lfo.setStartPhase)
             */
            setStartPhase(phase: number): void;

            /**
             * If an LFO is marked global, it is continuously updated whether or not it’s attached to any source.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.lfo.setGlobal)
             */
            setGlobal(flag: boolean): void;

            /**
             * If retrigger is on, the LFO’s phase is reset to its initial phase (default 0) when a synth using the LFO starts playing a note.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.lfo.setRetrigger)
             */
            setRetrigger(flag: boolean): void;

            /**
             * Sets an initial holdoff time for the LFO where the LFO remains at its center value, and a ramp time where the value increases linearly to its maximum depth. Values are in seconds.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.lfo.setDelay)
             */
            setDelay(holdoff: number, ramp: number): void;
        }

        namespace envelope {
            /**
             * Creates a new envelope with the given (optional) parameters.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.envelope.new)
             *
             * @noSelf
             */
            export function _new(
                attack?: number,
                decay: number,
                sustain: number,
                release?: number
            ): playdate.sound.envelope;

            export { _new as new };
        }

        class envelope {
            /**
             * Sets the envelope attack time to _attack_, in seconds.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.envelope.setAttack)
             */
            setAttack(attack: number): void;

            /**
             * Sets the envelope decay time to _decay_, in seconds.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.envelope.setDecay)
             */
            setDecay(decay: number): void;

            /**
             * Sets the envelope sustain level to _sustain_, as a proportion of the maximum. For example, if the sustain level is 0.5, the signal value rises to its full value over the attack phase of the envelope, then drops to half its maximum over the decay phase, and remains there while the envelope is active.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.envelope.setSustain)
             */
            setSustain(sustain: number): void;

            /**
             * Sets the envelope release time to _release_, in seconds.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.envelope.setRelease)
             */
            setRelease(release: number): void;

            /**
             * Smoothly changes the envelope’s shape from linear (amount=0) to exponential (amount=1).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.envelope.setCurvature)
             */
            setCurvature(amount: number): void;

            /**
             * Changes the amount by which note velocity scales output level. At the default value of 1, output is proportional to velocity; at 0 velocity has no effect on output level.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.envelope.setVelocitySensitivity)
             */
            setVelocitySensitivity(amount: number): void;

            /**
             * Scales the envelope rate according to the played note. For notes below `start`, the envelope’s set rate is used; for notes above `end` envelope rates are scaled by the `scaling` parameter. Between the two notes the scaling factor is interpolated from 1.0 to `scaling`. `start` and `end` are either MIDI note numbers or names like "C4". If omitted, the default range is C1 (36) to C5 (84).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.envelope.setRateScaling)
             */
            setRateScaling(
                scaling: number,
                start?: number | string = 'C1',
                end?: number | string = 'C5'
            ): void;

            /**
             * Sets the scale value for the envelope. The transformed envelope has an initial value of _offset_ and a maximum (minimum if _scale_ is negative) of _offset_ + _scale_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.envelope.setScale)
             */
            setScale(scale: number): void;

            /**
             * Sets the offset value for the envelope. The transformed envelope has an initial value of _offset_ and a maximum (minimum if _scale_ is negative) of _offset_ + _scale_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.envelope.setOffset)
             */
            setOffset(offset: number): void;

            /**
             * Sets whether to use legato phrasing for the envelope. If the legato flag is set, when the envelope is re-triggered before it’s released, it remains in the sustain phase instead of jumping back to the attack phase.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.envelope.setLegato)
             */
            setLegato(flag: boolean): void;

            /**
             * If retrigger is on, the envelope always starts from 0 when a note starts playing, instead of the current value if it’s active.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.envelope.setRetrigger)
             */
            setRetrigger(flag: boolean): void;

            /**
             * Triggers the envelope at the given _velocity_. If a _length_ parameter is given, the envelope moves to the release phase after the given time. Otherwise, the envelope is held in the sustain phase until the trigger function is called again with _velocity_ equal to zero.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.envelope.trigger)
             */
            trigger(velocity: number, length?: number): void;

            /**
             * If an envelope is marked global, it is continuously updated whether or not it’s attached to any source.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.envelope.setGlobal)
             */
            setGlobal(flag: boolean): void;
        }

        namespace bitcrusher {
            /**
             * Creates a new bitcrusher filter.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.bitcrusher.new)
             *
             * @noSelf
             */
            export function _new(): playdate.sound.bitcrusher;

            export { _new as new };
        }

        class bitcrusher {
            /**
             * Sets the wet/dry mix for the effect. A level of 1 (full wet) replaces the input with the effect output; 0 leaves the effect out of the mix.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.bitcrusher.setMix)
             */
            setMix(level: number): void;

            /**
             * Sets a [signal](https://sdk.play.date/2.5.0#C-sound.signal) to modulate the mix level. Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.bitcrusher.setMixMod)
             */
            setMixMod(signal: playdate.sound.signal | null): void;

            /**
             * Sets the amount of crushing to _amt_. Valid values are 0 (no effect) to 1 (quantizing output to 1-bit).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.bitcrusher.setAmount)
             */
            setAmount(amt: number): void;

            /**
             * Sets a [signal](https://sdk.play.date/2.5.0#C-sound.signal) to modulate the filter level. Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.bitcrusher.setAmountMod)
             */
            setAmountMod(signal: playdate.sound.signal | null): void;

            /**
             * Sets the number of samples to repeat; 0 is no undersampling, 1 effectively halves the sample rate.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.bitcrusher.setUndersampling)
             */
            setUndersampling(amt: number): void;

            /**
             * Sets a [signal](https://sdk.play.date/2.5.0#C-sound.signal) to modulate the filter level. Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.bitcrusher.setUndersamplingMod)
             */
            setUndersamplingMod(signal: playdate.sound.signal | null): void;
        }

        namespace ringmod {
            /**
             * Creates a new ring modulator filter.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.ringmod.new)
             *
             * @noSelf
             */
            export function _new(): playdate.sound.ringmod;

            export { _new as new };
        }

        class ringmod {
            /**
             * Sets the wet/dry mix for the effect. A level of 1 (full wet) replaces the input with the effect output; 0 leaves the effect out of the mix.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.ringmod.setMix)
             */
            setMix(level: number): void;

            /**
             * Sets a [signal](https://sdk.play.date/2.5.0#C-sound.signal) to modulate the mix level. Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.ringmod.setMixMod)
             */
            setMixMod(signal: playdate.sound.signal | null): void;

            /**
             * Sets the ringmod frequency to _f_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.ringmod.setFrequency)
             */
            setFrequency(f: number): void;

            /**
             * Sets a [signal](https://sdk.play.date/2.5.0#C-sound.signal) to modulate the ringmod frequency. Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.ringmod.setFrequencyMod)
             */
            setFrequencyMod(signal: playdate.sound.signal | null): void;
        }

        namespace onepolefilter {
            /**
             * Returns a new one pole filter.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.onepolefilter.new)
             *
             * @noSelf
             */
            export function _new(): playdate.sound.onepolefilter;

            export { _new as new };
        }

        class onepolefilter {
            /**
             * Sets the wet/dry mix for the effect. A level of 1 (full wet) replaces the input with the effect output; 0 leaves the effect out of the mix.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.onepolefilter.setMix)
             */
            setMix(level: number): void;

            /**
             * Sets a [signal](https://sdk.play.date/2.5.0#C-sound.signal) to modulate the mix level. Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.onepolefilter.setMixMod)
             */
            setMixMod(signal: playdate.sound.signal | null): void;

            /**
             * Sets the filter’s single parameter (cutoff frequency) to _p_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.onepolefilter.setParameter)
             */
            setParameter(p: number): void;

            /**
             * Sets a modulator for the filter’s parameter. Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.onepolefilter.setParameterMod)
             */
            setParameterMod(m: playdate.sound.signal | null): void;
        }

        namespace twopolefilter {
            /**
             * Creates a new two pole IIR filter of the given _type_:
             *
             * *   _playdate.sound.kFilterLowPass_ (or the string "lowpass" or "lopass")
             *
             * *   _playdate.sound.kFilterHighPass_ (or "highpass" or "hipass")
             *
             * *   _playdate.sound.kFilterBandPass_ (or "bandpass")
             *
             * *   _playdate.sound.kFilterNotch_ (or "notch")
             *
             * *   _playdate.sound.kFilterPEQ_ (or "peq")
             *
             * *   _playdate.sound.kFilterLowShelf_ (or "lowshelf" or "loshelf")
             *
             * *   _playdate.sound.kFilterHighShelf_ (or "highshelf" or "hishelf")
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.twopolefilter.new)
             *
             * @noSelf
             */
            export function _new(
                type: PlaydateSoundTwoPoleFilterType
            ): playdate.sound.twopolefilter;

            export { _new as new };
        }

        class twopolefilter {
            /**
             * Sets the wet/dry mix for the effect. A level of 1 (full wet) replaces the input with the effect output; 0 leaves the effect out of the mix.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.twopolefilter.setMix)
             */
            setMix(level: number): void;

            /**
             * Sets a [signal](https://sdk.play.date/2.5.0#C-sound.signal) to modulate the mix level. Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.twopolefilter.setMixMod)
             */
            setMixMod(signal: playdate.sound.signal | null): void;

            /**
             * Sets the center frequency (in Hz) of the filter to _f_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.twopolefilter.setFrequency)
             */
            setFrequency(f: number): void;

            /**
             * Sets a [signal](https://sdk.play.date/2.5.0#C-sound.signal) to modulate the filter frequency. Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.twopolefilter.setFrequencyMod)
             */
            setFrequencyMod(signal: playdate.sound.signal | null): void;

            /**
             * Sets the resonance of the filter to _r_. Valid values are in the range 0-1. This parameter has no effect on shelf type filters.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.twopolefilter.setResonance)
             */
            setResonance(r: number): void;

            /**
             * Sets a [signal](https://sdk.play.date/2.5.0#C-sound.signal) to modulate the filter resonance. Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.twopolefilter.setResonanceMod)
             */
            setResonanceMod(signal: playdate.sound.signal | null): void;

            /**
             * Sets the gain of the filter to _g_. Gain is only used in PEQ and shelf type filters.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.twopolefilter.setGain)
             */
            setGain(g: number): void;

            /**
             * Sets the type of the filter to _type_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.twopolefilter.setType)
             */
            setType(type: PlaydateSoundTwoPoleFilterType): void;
        }

        namespace overdrive {
            /**
             * Creates a new overdrive effect.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.overdrive.new)
             *
             * @noSelf
             */
            export function _new(): playdate.sound.overdrive;

            export { _new as new };
        }

        class overdrive {
            /**
             * Sets the wet/dry mix for the effect. A level of 1 (full wet) replaces the input with the effect output; 0 leaves the effect out of the mix.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.overdrive.setMix)
             */
            setMix(level: number): void;

            /**
             * Sets a [signal](https://sdk.play.date/2.5.0#C-sound.signal) to modulate the mix level. Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.overdrive.setMixMod)
             */
            setMixMod(signal: playdate.sound.signal | null): void;

            /**
             * Sets the gain of the filter.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.overdrive.setGain)
             */
            setGain(level: number): void;

            /**
             * Sets the level where the amplified input clips.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.overdrive.setLimit)
             */
            setLimit(level: number): void;

            /**
             * Sets a [signal](https://sdk.play.date/2.5.0#C-sound.signal) to modulate the limit level. Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.overdrive.setLimitMod)
             */
            setLimitMod(signal: playdate.sound.signal | null): void;

            /**
             * Adds an offset to the upper and lower limits to create an asymmetric clipping.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.overdrive.setOffset)
             */
            setOffset(level: number): void;

            /**
             * Sets a [signal](https://sdk.play.date/2.5.0#C-sound.signal) to modulate the offset value. Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.overdrive.setOffsetMod)
             */
            setOffsetMod(signal: playdate.sound.signal | null): void;
        }

        namespace delayline {
            /**
             * Creates a new delay line effect, with the given length (in seconds).
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.delayline.new)
             *
             * @noSelf
             */
            export function _new(length: number): playdate.sound.delayline;

            export { _new as new };
        }

        class delayline {
            /**
             * Sets the wet/dry mix for the effect. A level of 1 (full wet) replaces the input with the effect output; 0 leaves the effect out of the mix, which is useful if you’re using taps for varying delays.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.delayline.setMix)
             */
            setMix(level: number): void;

            /**
             * Sets a [signal](https://sdk.play.date/2.5.0#C-sound.signal) to modulate the mix level. Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.delayline.setMixMod)
             */
            setMixMod(signal: playdate.sound.signal | null): void;

            /**
             * Returns a new [playdate.sound.delaylinetap](https://sdk.play.date/2.5.0#C-sound.delaylinetap) on the delay line, at the given delay (which must be less than or equal to the delay line’s length).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.delayline.addTap)
             */
            addTap(delay: number): void;

            /**
             * Sets the feedback level of the delay line.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.delayline.setFeedback)
             */
            setFeedback(level: number): void;
        }

        namespace delaylinetap {}

        class delaylinetap {
            /**
             * Sets the position of the tap on the delay line, up to the delay line’s length.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.delaylinetap.setDelay)
             */
            setDelay(time: number): void;

            /**
             * Sets a [signal](https://sdk.play.date/2.5.0#C-sound.signal) to modulate the tap delay. If the signal is continuous (e.g. an envelope or a triangle LFO, but not a square LFO) playback is sped up or slowed down to compress or expand time. Set to _nil_ to clear the modulator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.delaylinetap.setDelayMod)
             */
            setDelayMod(signal: playdate.sound.signal | null): void;

            /**
             * Sets the tap’s volume.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.delaylinetap.setVolume)
             */
            setVolume(level: number): void;

            /**
             * Returns the tap’s volume.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.delaylinetap.getVolume)
             */
            getVolume(): number;

            /**
             * If set and the delay line is stereo, the tap outputs the delay line’s left channel to its right output and vice versa.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.delaylinetap.setFlipChannels)
             */
            setFlipChannels(flag: boolean): void;
        }

        namespace sequence {
            /**
             * Creates a new sound sequence. If `midi_path` is given, it attempts to load data from the midi file into the sequence.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.sequence.new)
             *
             * @noSelf
             */
            export function _new(midi_path?: string): playdate.sound.sequence;

            export { _new as new };
        }

        class sequence {
            /**
             * Starts playing the sequence. `finishCallback` is an optional function to be called when the sequence finishes playing or is stopped. The sequence is passed to the callback as its single argument.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sequence.play)
             */
            play(
                finishCallback?: (sequence: playdate.sound.sequence) => void
            ): void;

            /**
             * Stops playing the sequence.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sequence.stop)
             */
            stop(): void;

            /**
             * Returns true if the sequence is currently playing.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sequence.isPlaying)
             */
            isPlaying(): boolean;

            /**
             * Returns the length of the longest track in the sequence, in steps. See also [playdate.sound.track.getLength()](https://sdk.play.date/2.5.0#m-sound.track.getLength).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sequence.getLength)
             */
            getLength(): number;

            /**
             * Moves the play position for the sequence to step number `step`. If `play` is set, triggers the notes at that step.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sequence.goToStep)
             */
            goToStep(step: number, play?: boolean): void;

            /**
             * Returns the step number the sequence is currently at.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sequence.getCurrentStep)
             */
            getCurrentStep(): number;

            /**
             * Sets the tempo of the sequence, in steps per second.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sequence.setTempo)
             */
            setTempo(stepsPerSecond: number): void;

            /**
             * Returns the tempo of the sequence, in steps per second.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sequence.getTempo)
             */
            getTempo(): number;

            /**
             * Sets the looping range of the sequence. If _loops_ is 0 or unset, the loop repeats endlessly.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sequence.setLoops)
             */
            setLoops(
                startStep: number,
                endStep: number,
                loopCount?: number
            ): void;
            /**
             * Same as above, with startStep set to 0 and endStep set to `sequence:getLength()`.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sequence.setLoops-2)
             */
            setLoops(loopCount: number): void;

            /**
             * Returns the number of tracks in the sequence.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sequence.getTrackCount)
             */
            getTrackCount(): number;

            /**
             * Adds the given [playdate.sound.track](https://sdk.play.date/2.5.0#C-sound.track) to the sequence. If `track` omitted, the function creates and returns a new track.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sequence.addTrack)
             */
            addTrack(): playdate.sound.track;
            /**
             * Adds the given [playdate.sound.track](https://sdk.play.date/2.5.0#C-sound.track) to the sequence. If `track` omitted, the function creates and returns a new track.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sequence.addTrack)
             */
            addTrack(track?: playdate.sound.track): void;

            /**
             * Sets the given [playdate.sound.track](https://sdk.play.date/2.5.0#C-sound.track) object at position `n` in the sequence.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sequence.setTrackAtIndex)
             */
            setTrackAtIndex(n: number, track: playdate.sound.track): void;

            /**
             * Returns the [playdate.sound.track](https://sdk.play.date/2.5.0#C-sound.track) object at position `n` in the sequence.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sequence.getTrackAtIndex)
             */
            getTrackAtIndex(n: number): playdate.sound.track;

            /**
             * Sends an [allNotesOff()](https://sdk.play.date/2.5.0#m-sound.instrument.allNotesOff) message to each track’s instrument.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.sequence.allNotesOff)
             */
            allNotesOff(): void;
        }

        namespace track {
            /**
             * Creates a new `playdate.sound.track` object.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.track.new)
             *
             * @noSelf
             */
            export function _new(): playdate.sound.track;

            export { _new as new };
        }

        class track {
            /**
             * Adds a single note event to the track, letting you specify `step`, `note`, `length`, and `velocity` directly. The second format allows you to pack them into a table, using the format returned by [getNotes()](https://sdk.play.date/2.5.0#m-sound.track.getNotes). The `note` argument can be a MIDI note number or a note name like "Db3". `length` is the length of the note in steps, not time—​that is, it follows the sequence’s tempo. The default velocity is 1.0.
             *
             * See [setNotes()](https://sdk.play.date/2.5.0#m-sound.track.setNotes) for the ability to add more than one note at a time.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.track.addNote2)
             */
            addNote(
                step: number,
                note: number | string,
                length: number,
                velocity?: number = 1
            ): void;
            /**
             * Adds a single note event to the track, letting you specify `step`, `note`, `length`, and `velocity` directly. The second format allows you to pack them into a table, using the format returned by [getNotes()](https://sdk.play.date/2.5.0#m-sound.track.getNotes). The `note` argument can be a MIDI note number or a note name like "Db3". `length` is the length of the note in steps, not time—​that is, it follows the sequence’s tempo. The default velocity is 1.0.
             *
             * See [setNotes()](https://sdk.play.date/2.5.0#m-sound.track.setNotes) for the ability to add more than one note at a time.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.track.addNote2)
             */
            addNote(table: {
                step: number;
                note: number | string;
                length: number;
                velocity: number;
            }): void;

            /**
             * Set multiple notes at once, each array element should be a table containing values for the keys The tables contain values for keys `step`, `note`, `length`, and `velocity`.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.track.setNotes)
             */
            setNotes(
                list: {
                    step: number;
                    note: number | string;
                    length: number;
                    velocity: number;
                }[]
            ): void;

            /**
             * Returns an array of tables representing the note events in the track.
             *
             * The tables contain values for keys `step`, `note`, `length`, and `velocity`. If `step` is given, the function returns only the notes at that step; if both `step` and `endstep` are set, it returns the notes between the two steps (including notes at endstep). n.b. The `note` field in the event tables is always a MIDI note number value, even if the note was added using the string notation.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.track.getNotes)
             */
            getNotes(
                step?: number,
                endstep?: number
            ): {
                step: number;
                note: number | string;
                length: number;
                velocity: number;
            }[];

            /**
             * Removes the note event at _step_ playing _note_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.track.removeNote)
             */
            removeNote(step: number, note: number): void;

            /**
             * Clears all notes from the track.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.track.clearNotes)
             */
            clearNotes(): void;

            /**
             * Returns the length, in steps, of the track—​that is, the step where the last note in the track ends.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.track.getLength)
             */
            getLength(): number;

            /**
             * Returns the current number of notes active in the track.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.track.getNotesActive)
             */
            getNotesActive(): number;

            /**
             * Returns the maximum number of notes simultaneously active in the track. (Known bug: this currently only works for midi files)
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.track.getPolyphony)
             */
            getPolyphony(): number;

            /**
             * Sets the [playdate.sound.instrument](https://sdk.play.date/2.5.0#C-sound.instrument) that this track plays. If `inst` is a [playdate.sound.synth](https://sdk.play.date/2.5.0#C-sound.synth), the function creates an instrument for the synth.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.track.setInstrument)
             */
            setInstrument(
                inst: playdate.sound.instrument | playdate.sound.synth
            ): void;

            /**
             * Gets the [playdate.sound.instrument](https://sdk.play.date/2.5.0#C-sound.instrument) that this track plays.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.track.getInstrument)
             */
            getInstrument(): playdate.sound.instrument;

            /**
             * Mutes or unmutes the track.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.track.setMuted)
             */
            setMuted(flag: boolean): void;

            /**
             * Adds a [playdate.sound.controlsignal](https://sdk.play.date/2.5.0#C-sound.controlsignal) object to the track. Note that the signal must be assigned to a modulation input for it to have any audible effect. The input can be anywhere in the sound engine—​it’s not required to belong to the track in any way.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.track.addControlSignal)
             */
            addControlSignal(s: playdate.sound.controlsignal): void;

            /**
             * Returns an array of [playdate.sound.controlsignal](https://sdk.play.date/2.5.0#C-sound.controlsignal) objects assigned to this track.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.track.getControlSignals)
             */
            getControlSignals(): playdate.sound.controlsignal[];
        }

        namespace instrument {
            /**
             * Creates a new `playdate.sound.instrument` object. If `synth` is given, adds it as a voice for the instrument.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.instrument.new)
             *
             * @noSelf
             */
            export function _new(
                synth?: playdate.sound.synth
            ): playdate.sound.instrument;

            export { _new as new };
        }

        class instrument {
            /**
             * Adds the given [playdate.sound.synth](https://sdk.play.date/2.5.0#C-sound.synth) to the instrument. If only the _note_ argument is given, the voice is only used for that note, and is transposed to play at normal speed (i.e. rate=1.0 for samples, or C4 for synths). If _rangeend_ is given, the voice is assigned to the range _note_ to _rangeend_, inclusive, with the first note in the range transposed to rate=1.0/C4. The `note` and `rangeend` arguments can be MIDI note numbers or note names like "Db3". The final transpose argument transposes the note played, in half-tone units.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.instrument.addVoice)
             */
            addVoice(
                v: playdate.sound.synth,
                note?: number | string,
                rangeend?: number | string,
                transpose?: number
            ): void;

            /**
             * Transposes all voices in the instrument. _halfsteps_ can be a fractional value.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.instrument.setTranspose)
             */
            setTranspose(halfsteps: number): void;

            /**
             * Plays the given note on the instrument. A string like `Db3` can be used instead of a pitch/note number. Fractional values are allowed. _vel_ defaults to 1.0, fully on. If _length_ isn’t specified, the note stays on until _instrument.noteOff(note)_ is called. _when_ is the number of seconds in the future to start playing the note, default is immediately.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.instrument.playNote)
             */
            playNote(
                frequency: number | string,
                vel?: number = 1.0,
                length?: number,
                when?: number
            ): void;

            /**
             * Identical to `instrument:playNote()` but _note_ is a MIDI note number: 60=C4, 61=C#4, etc. Fractional values are allowed.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.instrument.playMIDINote)
             */
            playMIDINote(
                note: number,
                vel?: number = 1.0,
                length?: number,
                when?: number
            ): void;

            /**
             * Stops the instrument voice playing note _note_. If _when_ is given, the note is stopped _when_ seconds in the future, otherwise it’s stopped immediately.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.instrument.noteOff)
             */
            noteOff(note: number, when?: number): void;

            /**
             * Sends a stop signal to all playing notes.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.instrument.allNotesOff)
             */
            allNotesOff(): void;

            /**
             * Sets the instrument volume. If a single value is passed in, sets both left side and right side volume to the given value. If two values are given, volumes are set separately.
             *
             * Volume values are between 0.0 and 1.0.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.instrument.setVolume)
             */
            setVolume(left: number, right?: number): void;

            /**
             * Returns the current volume for the synth, a single value for mono sources or a pair of values (left, right) for stereo sources.
             *
             * Volume values are between 0.0 and 1.0.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.instrument.getVolume)
             */
            getVolume():
                | LuaMultiReturn<[number, undefined]>
                | LuaMultiReturn<[number, number]>;
        }

        namespace controlsignal {
            /**
             * Creates a new control signal object, for automating effect parameters, channel pan and level, etc.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.controlsignal.new)
             *
             * @noSelf
             */
            export function _new(): playdate.sound.controlsignal;

            export { _new as new };
        }

        class controlsignal {
            /**
             * `addEvent` is a simpler way of adding events one at a time than setting the entire _events_ table. Arguments are either the values themselves in the given order, or a table containing values for `step`, `value`, and optionally `interpolate`.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.controlsignal.addEvent2)
             */
            addEvent(step: number, value: number, interpolate?: boolean): void;
            /**
             * `addEvent` is a simpler way of adding events one at a time than setting the entire _events_ table. Arguments are either the values themselves in the given order, or a table containing values for `step`, `value`, and optionally `interpolate`.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.controlsignal.addEvent2)
             */
            addEvent(event: {
                step: number;
                value: number;
                interpolate?: boolean;
            }): void;

            /**
             * Clears all events from the control signal.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.controlsignal.clearEvents)
             */
            clearEvents(): void;

            /**
             * Sets the midi controller number for the control signal, if that’s something you want to do. The value has no effect on playback.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.controlsignal.setControllerType)
             */
            setControllerType(number: number): void;

            /**
             * Control signals in midi files are assigned a controller number, which describes the intent of the control. This function returns the controller number.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-sound.controlsignal.getControllerType)
             */
            getControllerType(): number;

            /**
             * The signal’s event list is modified by getting and setting the `events` property of the object. This is an array of tables, each containing values for keys `step` and `value`, and optionally `interpolate`.
             *
             * [Read more](https://sdk.play.date/2.5.0#v-sound.controlsignal.events)
             */
            events: { step: number; value: number; interpolate?: boolean }[];
        }

        namespace micinput {
            /**
             * `buffer` should be a [Sample](https://sdk.play.date/2.5.0#C-sound.sample) created with the following code, with _secondsToRecord_ replaced by a number specifying the record duration:
             *
             *     local buffer = playdate.sound.sample.new(_secondsToRecord_, playdate.sound.kFormat16bitMono)
             *
             * `completionCallback` is a function called at the end of recording, when the buffer is full. It has one argument, the recorded sample. To override the device’s headset detection and force recording from either the internal mic or a headset mic or line in connected to a headset splitter, first call [playdate.sound.micinput.startListening()](https://sdk.play.date/2.5.0#f-sound.micinput.startListening) with the required source. `recordToSample()` returns `true` on success, `false` on error.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.micinput.recordToSample)
             *
             * @noSelf
             */
            export function recordToSample(
                buffer: playdate.sound.sample,
                completionCallback: (sample: playdate.sound.sample) => void
            ): boolean;

            /**
             * Stops a sample recording started with recordToSample, if it hasn’t already reached the end of the buffer. The recording’s completion callback is called immediately.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.micinput.stopRecording)
             *
             * @noSelf
             */
            export function stopRecording(): void;

            /**
             * Starts monitoring the microphone input level. The optional _source_ argument of "headset" or "device" causes the mic input to record from the given source. If no source is given, it uses the headset detection circuit to determine which source to use. The function returns the pair `true` and a string indicating which source it’s recording from on success, or `false` on error.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.micinput.startListening)
             *
             * @noSelf
             */
            export function startListening(
                source?: 'headset' | 'device'
            ):
                | LuaMultiReturn<[true, 'headset' | 'device']>
                | LuaMultiReturn<[false, string]>;

            /**
             * Stops monitoring the microphone input level.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.micinput.stopListening)
             *
             * @noSelf
             */
            export function stopListening(): void;

            /**
             * Returns the current microphone input level, a value from 0.0 (quietest) to 1.0 (loudest).
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.micinput.getLevel)
             *
             * @noSelf
             */
            export function getLevel(): number;

            /**
             * Returns the current microphone input source, either "headset" or "device".
             *
             * [Read more](https://sdk.play.date/2.5.0#f-sound.micinput.getSource)
             *
             * @noSelf
             */
            export function getSource(): 'headset' | 'device';
        }
    }

    namespace string {
        /**
         * Generates a random string of uppercase letters
         *
         * [Read more](https://sdk.play.date/2.5.0#f-string.UUID)
         *
         * @noSelf
         */
        export function UUID(length: number): string;

        /**
         * Returns a string with the whitespace removed from the beginning and ending of _string_.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-string.trimWhitespace)
         *
         * @noSelf
         */
        export function trimWhitespace(string: string): string;

        /**
         * Returns a string with the whitespace removed from the beginning of _string_.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-string.trimLeadingWhitespace)
         *
         * @noSelf
         */
        export function trimLeadingWhitespace(string: string): string;

        /**
         * Returns a string with the whitespace removed from the ending of _string_.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-string.trimTrailingWhitespace)
         *
         * @noSelf
         */
        export function trimTrailingWhitespace(string: string): string;
    }

    namespace timer {
        /**
         * This should be called from the main playdate.update() loop to drive the timers.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-timer.updateTimers)
         *
         * @noSelf
         */
        export function updateTimers(): void;

        /**
         * Returns a new playdate.timer that will run for _duration_ milliseconds. _callback_ is a function closure that will be called when the timer is complete.
         *
         * Accepts a variable number of arguments that will be passed to the callback function when it is called. If arguments are not provided, the timer itself will be passed to the callback instead.
         *
         * By default, timers start upon instantiation. To modify the behavior of a timer, see [common timer methods](https://sdk.play.date/2.5.0#C-commonTimerMethods) and [properties](https://sdk.play.date/2.5.0#C-commonTimerProperties).
         *
         * [Read more](https://sdk.play.date/2.5.0#f-timer.new)
         *
         * @noSelf
         */
        export function _new(
            duration: number,
            callback: (timer: playdate.timer) => void
        ): playdate.timer;
        /**
         * Returns a new playdate.timer that will run for _duration_ milliseconds. _callback_ is a function closure that will be called when the timer is complete.
         *
         * Accepts a variable number of arguments that will be passed to the callback function when it is called. If arguments are not provided, the timer itself will be passed to the callback instead.
         *
         * By default, timers start upon instantiation. To modify the behavior of a timer, see [common timer methods](https://sdk.play.date/2.5.0#C-commonTimerMethods) and [properties](https://sdk.play.date/2.5.0#C-commonTimerProperties).
         *
         * [Read more](https://sdk.play.date/2.5.0#f-timer.new)
         *
         * @noSelf
         */
        export function _new(
            duration: number,
            callback: (...args: unknown[]) => void,
            ...args: unknown[]
        ): playdate.timer;

        export { _new as new };

        /**
         * Performs the function _callback_ after _delay_ milliseconds. Accepts a variable number of arguments that will be passed to the callback function when it is called. If arguments are not provided, the timer itself will be passed to the callback instead.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-timer.performAfterDelay)
         *
         * @noSelf
         */
        export function performAfterDelay(
            delay: number,
            callback: (timer: playdate.timer) => void
        ): void;
        /**
         * Performs the function _callback_ after _delay_ milliseconds. Accepts a variable number of arguments that will be passed to the callback function when it is called. If arguments are not provided, the timer itself will be passed to the callback instead.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-timer.performAfterDelay)
         *
         * @noSelf
         */
        export function performAfterDelay(
            delay: number,
            callback: (...args: unknown[]) => void,
            ...args: unknown[]
        ): void;

        /**
         * Returns a new playdate.timer that will run for _duration_ milliseconds. If not specified, _startValue_ and _endValue_ will be 0, and a linear easing function will be used.
         *
         * By default, timers start upon instantiation. To modify the behavior of a timer, see [common timer methods](https://sdk.play.date/2.5.0#C-commonTimerMethods) and [properties](https://sdk.play.date/2.5.0#C-commonTimerProperties).
         *
         * [Read more](https://sdk.play.date/2.5.0#f-timer.new2)
         *
         * @noSelf
         */
        export function _new(
            duration: number,
            startValue?: number = 0,
            endValue: number = 0,
            easingFunction?: PlaydateEasingFunction
        ): playdate.timer;

        export { _new as new };

        /**
         * Calls `keyRepeatTimerWithDelay()` below with standard values of _delayAfterInitialFiring_ = 300 and _delayAfterSecondFiring_ = 100.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-timer.keyRepeatTimer)
         *
         * @noSelf
         */
        export function keyRepeatTimer(
            callback: (timer: playdate.timer) => void
        ): void;
        /**
         * Calls `keyRepeatTimerWithDelay()` below with standard values of _delayAfterInitialFiring_ = 300 and _delayAfterSecondFiring_ = 100.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-timer.keyRepeatTimer)
         *
         * @noSelf
         */
        export function keyRepeatTimer(
            callback: (...args: unknown[]) => void,
            ...args: unknown[]
        ): void;

        /**
         * returns a timer that fires at key-repeat intervals. The function _callback_ will be called immediately, then again after _delayAfterInitialFiring_ milliseconds, then repeatedly at _delayAfterSecondFiring_ millisecond intervals.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-timer.keyRepeatTimerWithDelay)
         *
         * @noSelf
         */
        export function keyRepeatTimerWithDelay(
            delayAfterInitialFiring: number,
            delayAfterSecondFiring: number,
            callback: (timer: playdate.timer) => void
        ): void;
        /**
         * returns a timer that fires at key-repeat intervals. The function _callback_ will be called immediately, then again after _delayAfterInitialFiring_ milliseconds, then repeatedly at _delayAfterSecondFiring_ millisecond intervals.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-timer.keyRepeatTimerWithDelay)
         *
         * @noSelf
         */
        export function keyRepeatTimerWithDelay(
            delayAfterInitialFiring: number,
            delayAfterSecondFiring: number,
            callback: (...args: unknown[]) => void,
            ...args: unknown[]
        ): void;

        /**
         * Returns an array listing all running timers.
         *
         * Note
         *
         * Note the "." syntax rather than ":". This is a class method, not an instance method.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-timer.allTimers)
         *
         * @noSelf
         */
        export function allTimers(): playdate.timer[];
    }

    class timer {
        /**
         * Pauses a timer. (There is no need to call :start() on a newly-instantiated timer: timers start automatically.)
         *
         * [Read more](https://sdk.play.date/2.5.0#m-timer.pause)
         */
        pause(): void;

        /**
         * Resumes a previously paused timer. There is no need to call :start() on a newly-instantiated timer: timers start automatically.
         *
         * [Read more](https://sdk.play.date/2.5.0#m-timer.start)
         */
        start(): void;

        /**
         * Removes this timer from the list of timers. This happens automatically when a non-repeating timer reaches its end, but you can use this method to dispose of timers manually.
         *
         * Note that timers do not actually get removed until the next invocation of [playdate.timer.updateTimers()](https://sdk.play.date/2.5.0#f-timer.updateTimers).
         *
         * [Read more](https://sdk.play.date/2.5.0#m-timer.remove)
         */
        remove(): void;

        /**
         * Resets a timer to its initial values.
         *
         * [Read more](https://sdk.play.date/2.5.0#m-timer.reset)
         */
        reset(): void;

        /**
         * A Function of the form _function(timer)_ or _function(...)_ where "..." corresponds to the values in the table assigned to _timerEndedArgs_. Called when the timer has completed.
         *
         * [Read more](https://sdk.play.date/2.5.0#c-timer.timerEndedCallback)
         *
         * @noSelf
         */
        timerEndedCallback(...args: unknown[]): void;
        /**
         * A Function of the form _function(timer)_ or _function(...)_ where "..." corresponds to the values in the table assigned to _timerEndedArgs_. Called when the timer has completed.
         *
         * [Read more](https://sdk.play.date/2.5.0#c-timer.timerEndedCallback)
         *
         * @noSelf
         */
        timerEndedCallback(timer: playdate.timer): void;

        /**
         * A callback function that will be called on every frame (every time _timer.updateAll()_ is called). If the timer was created with arguments, those will be passed as arguments to the function provided. Otherwise, the timer is passed as the single argument.
         *
         * [Read more](https://sdk.play.date/2.5.0#c-timer.updateCallback)
         *
         * @noSelf
         */
        updateCallback(...args: unknown[]): void;
        /**
         * A callback function that will be called on every frame (every time _timer.updateAll()_ is called). If the timer was created with arguments, those will be passed as arguments to the function provided. Otherwise, the timer is passed as the single argument.
         *
         * [Read more](https://sdk.play.date/2.5.0#c-timer.updateCallback)
         *
         * @noSelf
         */
        updateCallback(timer: playdate.timer): void;

        /**
         * Current value calculated from the start and end values, the time elapsed, and the easing function.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-timer.value)
         */
        value: number;
        /**
         * The function used to calculate _value_. The function should be of the form _function(t, b, c, d)_, where _t_ is elapsed time, _b_ is the beginning value, _c_ is the change (or end value - start value), and _d_ is the duration. Many such functions are available in [playdate.easingFunctions](https://sdk.play.date/2.5.0#M-easingFunctions).
         *
         * [Read more](https://sdk.play.date/2.5.0#v-timer.easingFunction)
         */
        easingFunction: (t: number, b: number, c: number, d: number) => number;
        /**
         * For [easing functions](https://sdk.play.date/2.5.0#M-easingFunctions) that take additional amplitude and period arguments (such as _inOutElastic_), set these to the desired values.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-timer.easingAmplitude)
         */
        easingAmplitude: number;
        /**
         * For [easing functions](https://sdk.play.date/2.5.0#M-easingFunctions) that take additional amplitude and period arguments (such as _inOutElastic_), set these to the desired values.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-timer.easingAmplitude)
         */
        easingPeriod: number;
        /**
         * Set to provide an easing function to be used for the reverse portion of the timer. The function should be of the form _function(t, b, c, d)_, where _t_ is elapsed time, _b_ is the beginning value, _c_ is the change (or end value - start value), and _d_ is the duration. Many such functions are available in [playdate.easingFunctions](https://sdk.play.date/2.5.0#M-easingFunctions).
         *
         * [Read more](https://sdk.play.date/2.5.0#v-timer.reverseEasingFunction)
         */
        reverseEasingFunction: (
            t: number,
            b: number,
            c: number,
            d: number
        ) => number;
        /**
         * Start value used when calculating _value_.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-timer.startValue)
         */
        startValue: number;
        /**
         * End value used when calculating _value_.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-timer.endValue)
         */
        endValue: number;
        /**
         * The number of milliseconds the timer has been running. Read-only.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-timer.currentTime)
         */
        readonly currentTime: number;
        /**
         * Number of milliseconds to wait before starting the timer.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-timer.delay)
         */
        delay: number;
        /**
         * If true, the timer is discarded once it is complete. Defaults to true.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-timer.discardOnCompletion)
         */
        discardOnCompletion: boolean;
        /**
         * The number of milliseconds for which the timer will run.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-timer.duration)
         */
        duration: number;
        /**
         * The number of milliseconds remaining in the timer. Read-only.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-timer.timeLeft)
         */
        readonly timeLeft: number;
        /**
         * If true, the timer will be paused. The update callback will not be called when the timer is paused. Can be set directly, or by using `playdate.timer:pause()` and `playdate.timer:start()`. Defaults to false.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-timer.paused)
         */
        paused: boolean;
        /**
         * If true, the timer starts over from the beginning when it completes. Defaults to false.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-timer.repeats)
         */
        repeats: boolean;
        /**
         * If true, the timer plays in reverse once it has completed. The time to complete both the forward and reverse will be _duration_ x 2. Defaults to false.
         *
         * Please note that _currentTime_ will restart at 0 and count up to _duration_ again when the reverse timer starts, but _value_ will be calculated in reverse, from _endValue_ to _startValue_. The same easing function (as opposed to the inverse of the easing function) will be used for the reverse timer unless an alternate is provided by setting _reverseEasingFunction_.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-timer.reverses)
         */
        reverses: boolean;
        /**
         * For repeating timers, this function will be called each time the timer completes, before it starts again.
         *
         * An array-style table of values that will be passed to the _timerEndedCallback_ function.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-timer.timerEndedArgs)
         */
        timerEndedArgs: unknown[];
    }

    namespace frameTimer {
        /**
         * This should be called from the main playdate.update() loop to drive the frame timers.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-frameTimer.updateTimers)
         *
         * @noSelf
         */
        export function updateTimers(): void;

        /**
         * Returns a new playdate.frameTimer that will run for _duration_ frames. _callback_ is a function closure that will be called when the timer is complete.
         *
         * Accepts a variable number of arguments that will be passed to the callback function when it is called. If arguments are not provided, the timer itself will be passed to the callback instead.
         *
         * By default, frame timers start upon instantiation. To modify the behavior of a frame timer, see [common frame timer methods](https://sdk.play.date/2.5.0#C-commonFrameTimerMethods) and [properties](https://sdk.play.date/2.5.0#C-commonFrameTimerProperties).
         *
         * [Read more](https://sdk.play.date/2.5.0#f-frameTimer.new)
         *
         * @noSelf
         */
        export function _new(
            duration: number,
            callback: (timer: playdate.frametimer) => void
        ): void;
        /**
         * Returns a new playdate.frameTimer that will run for _duration_ frames. _callback_ is a function closure that will be called when the timer is complete.
         *
         * Accepts a variable number of arguments that will be passed to the callback function when it is called. If arguments are not provided, the timer itself will be passed to the callback instead.
         *
         * By default, frame timers start upon instantiation. To modify the behavior of a frame timer, see [common frame timer methods](https://sdk.play.date/2.5.0#C-commonFrameTimerMethods) and [properties](https://sdk.play.date/2.5.0#C-commonFrameTimerProperties).
         *
         * [Read more](https://sdk.play.date/2.5.0#f-frameTimer.new)
         *
         * @noSelf
         */
        export function _new(
            duration: number,
            callback: (...args: unknown[]) => void,
            ...args: unknown[]
        ): void;

        export { _new as new };

        /**
         * Performs the function _callback_ after the _delay_ number of frames. Accepts a variable number of arguments that will be passed to the callback function when it is called. If arguments are not provided, the timer itself will be passed to the callback instead.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-frameTimer.performAfterDelay)
         *
         * @noSelf
         */
        export function performAfterDelay(
            delay: number,
            callback: (timer: playdate.timer) => void
        ): void;
        /**
         * Performs the function _callback_ after the _delay_ number of frames. Accepts a variable number of arguments that will be passed to the callback function when it is called. If arguments are not provided, the timer itself will be passed to the callback instead.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-frameTimer.performAfterDelay)
         *
         * @noSelf
         */
        export function performAfterDelay(
            delay: number,
            callback: (...args: unknown[]) => void,
            ...args: unknown[]
        ): void;

        /**
         * Returns a new playdate.frameTimer that will run for _duration_ number of frames. If not specified, _startValue_ and _endValue_ will be 0, and a linear easing function will be used.
         *
         * By default, frame timers start upon instantiation. To modify the behavior of a frame timer, see [common frame timer methods](https://sdk.play.date/2.5.0#C-commonFrameTimerMethods) and [properties](https://sdk.play.date/2.5.0#C-commonFrameTimerProperties).
         *
         * [Read more](https://sdk.play.date/2.5.0#f-frameTimer.new-value)
         *
         * @noSelf
         */
        export function _new(
            duration: number,
            startValue?: number = 0,
            endValue: number = 0,
            easingFunction?: PlaydateEasingFunction
        ): playdate.frametimer;

        export { _new as new };

        /**
         * Returns an array listing all running frameTimers.
         *
         * Note
         *
         * Note the "." syntax rather than ":". This is a class method, not an instance method.
         *
         * [Read more](https://sdk.play.date/2.5.0#f-frameTimer.allTimers)
         *
         * @noSelf
         */
        export function allTimers(): playdate.frametimer[];
    }

    class frameTimer {
        /**
         * Pauses a timer.
         *
         * [Read more](https://sdk.play.date/2.5.0#m-frameTimer.pause)
         */
        pause(): void;

        /**
         * Resumes a timer. There is no need to call :start() on a newly-instantiated frame timer: frame timers start automatically.
         *
         * [Read more](https://sdk.play.date/2.5.0#m-frameTimer.start)
         */
        start(): void;

        /**
         * Removes this timer from the list of timers. This happens automatically when a non-repeating timer reaches it’s end, but you can use this method to dispose of timers manually.
         *
         * [Read more](https://sdk.play.date/2.5.0#m-frameTimer.remove)
         */
        remove(): void;

        /**
         * Resets a timer to its initial values.
         *
         * [Read more](https://sdk.play.date/2.5.0#m-frameTimer.reset)
         */
        reset(): void;

        /**
         * A Function of the form _function(timer)_ or _function(...)_ where "..." corresponds to the values in the table assigned to _timerEndedArgs_. Called when the timer has completed.
         *
         * [Read more](https://sdk.play.date/2.5.0#c-frameTimer.timerEndedCallback)
         *
         * @noSelf
         */
        timerEndedCallback(...args: unknown[]): void;
        /**
         * A Function of the form _function(timer)_ or _function(...)_ where "..." corresponds to the values in the table assigned to _timerEndedArgs_. Called when the timer has completed.
         *
         * [Read more](https://sdk.play.date/2.5.0#c-frameTimer.timerEndedCallback)
         *
         * @noSelf
         */
        timerEndedCallback(timer: playdate.frametimer): void;

        /**
         * A function to be called on every frame update. If the frame timer was created with arguments, those will be passed as arguments to the function provided. Otherwise, the timer is passed as the single argument.
         *
         * [Read more](https://sdk.play.date/2.5.0#c-frameTimer.updateCallback)
         *
         * @noSelf
         */
        updateCallback(...args: unknown[]): void;
        /**
         * A function to be called on every frame update. If the frame timer was created with arguments, those will be passed as arguments to the function provided. Otherwise, the timer is passed as the single argument.
         *
         * [Read more](https://sdk.play.date/2.5.0#c-frameTimer.updateCallback)
         *
         * @noSelf
         */
        updateCallback(timer: playdate.frametimer): void;

        /**
         * Current value calculated from the start and end values, the current frame, and the easing function.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-frameTimer.value)
         */
        value: number;
        /**
         * Start value used when calculating _value_.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-frameTimer.startValue)
         */
        startValue: number;
        /**
         * End value used when calculating _value_.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-frameTimer.endValue)
         */
        endValue: number;
        /**
         * The function used to calculate _value_. The function should be of the form _function(t, b, c, d)_, where _t_ is elapsed time, _b_ is the beginning value, _c_ is the change (or _endValue - startValue_), and _d_ is the duration.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-frameTimer.easingFunction)
         */
        easingFunction: (t: number, b: number, c: number, d: number) => number;
        /**
         * For easing functions in _CoreLibs/easing_ that take additional amplitude and period arguments (such as _inOutElastic_), set these to desired values.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-frameTimer.easingAmplitude)
         */
        easingAmplitude: number;
        /**
         * For easing functions in _CoreLibs/easing_ that take additional amplitude and period arguments (such as _inOutElastic_), set these to desired values.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-frameTimer.easingAmplitude)
         */
        easingPeriod: number;
        /**
         * Set to provide an easing function to be used for the reverse portion of the timer. The function should be of the form _function(t, b, c, d)_, where _t_ is elapsed time, _b_ is the beginning value, _c_ is the change (or _endValue - startValue_), and _d_ is the duration.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-frameTimer.reverseEasingFunction)
         */
        reverseEasingFunction: (
            t: number,
            b: number,
            c: number,
            d: number
        ) => number;
        /**
         * Number of frames to wait before starting the timer.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-frameTimer.delay)
         */
        delay: number;
        /**
         * If true, the timer is discarded once it is complete. Defaults to true.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-frameTimer.discardOnCompletion)
         */
        discardOnCompletion: boolean;
        /**
         * The number of frames for which the timer will run.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-frameTimer.duration)
         */
        duration: number;
        /**
         * The current frame.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-frameTimer.frame)
         */
        frame: number;
        /**
         * If true, the timer starts over from the beginning when it completes. Defaults to false.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-frameTimer.repeats)
         */
        repeats: boolean;
        /**
         * If true, the timer plays in reverse once it has completed. The number of frames to complete both the forward and reverse will be _duration x 2_. Defaults to false.
         *
         * Please note that the frame counter will restart at 0 and count up to _duration_ again when the reverse timer starts, but _value_ will be calculated in reverse, from _endValue_ to _startValue_. The same easing function (as opposed to the inverse of the easing function) will be used for the reverse timer unless an alternate is provided by setting _reverseEasingFunction_.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-frameTimer.reverses)
         */
        reverses: boolean;
        /**
         * For repeating timers, this function will be called each time the timer completes, before it starts again.
         *
         * An array-style table of values that will be passed to the _timerEndedCallback_ function.
         *
         * [Read more](https://sdk.play.date/2.5.0#v-frameTimer.timerEndedArgs)
         */
        timerEndedArgs: unknown[];
    }

    namespace ui {
        namespace crankIndicator {}

        class crankIndicator {
            /**
             * Draws the next frame of the crank indicator animation, and is typically invoked in the [`playdate.update()`](https://sdk.play.date/2.5.0#c-update) callback. _xOffset_ and _yOffset_ can be used to alter the position of the indicator by a specified number of pixels if desired. To stop drawing the crank indicator, simply stop calling `:draw()` in `playdate.update()`.
             *
             * Note that if sprites are being used, this call should usually happen after [playdate.graphics.sprite.update()](https://sdk.play.date/2.5.0#f-graphics.sprite.update).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.crankIndicator.draw)
             */
            draw(xOffset?: number, yOffset?: number): void;

            /**
             * Resets the crank animation to the beginning of its sequence.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.crankIndicator.reset)
             */
            resetAnimation(): void;

            /**
             * Returns _x_, _y_, _width_, _height_ representing the bounds that the crank indicator draws within. If necessary, this rect could be passed into [playdate.graphics.sprite.addDirtyRect()](https://sdk.play.date/2.5.0#m-graphics.sprite.addDirtyRect), or used to manually draw over the indicator image drawn by [playdate.ui.crankIndicator:draw()](https://sdk.play.date/2.5.0#m-crankIndicator.draw) when you want to stop showing the crank indicator.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.crankIndicator.getBounds)
             */
            getBounds(): LuaMultiReturn<[number, number, number, number]>;

            /**
             * Boolean property specifying which direction to animate the crank. Defaults to true.
             *
             * [Read more](https://sdk.play.date/2.5.0#v-ui.crankIndicator.clockwise)
             */
            clockwise: boolean;
        }

        namespace gridview {
            /**
             * Returns a new [playdate.ui.gridview](https://sdk.play.date/2.5.0#C-ui.gridview) with cells sized _cellWidth_, _cellHeight_. (Sizes are in pixels.) If cells should span the entire width of the grid (as in a list view), pass zero (0) for _cellWidth_.
             *
             * [Read more](https://sdk.play.date/2.5.0#f-ui.gridview.new)
             *
             * @noSelf
             */
            export function _new(
                cellWidth: number,
                cellHeight: number
            ): playdate.ui.gridview;

            export { _new as new };

            /**
             * Returns the current height of the section headers.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.getSectionHeaderHeight)
             *
             * @noSelf
             */
            export function getSectionHeaderHeight(): number;
        }

        class gridview {
            /**
             * Override this method to draw the cells in the gridview. _selected_ is a boolean, true if the cell being drawn is the currently-selected cell.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.drawCell)
             */
            drawCell(
                section: number,
                row: number,
                column: number,
                selected: boolean,
                x: number,
                y: number,
                width: number,
                height: number
            ): void;

            /**
             * Override this method to draw section headers. This function will only be called if the header height has been set to a value greater than zero (0).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.drawSectionHeader)
             */
            drawSectionHeader(
                section: number,
                x: number,
                y: number,
                width: number,
                height: number
            ): void;

            /**
             * Override this method to customize the drawing of horizontal dividers. This function will only be called if the horizontal divider height is greater than zero (0) and at least one divider has been added.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.drawHorizontalDivider)
             */
            drawHorizontalDivider(
                x: number,
                y: number,
                width: number,
                height: number
            ): void;

            /**
             * Draws the gridview in the specified rect. Ideally this should be called on every [playdate.update()](https://sdk.play.date/2.5.0#c-update) to accommodate scrolling.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.drawInRect)
             */
            drawInRect(
                x: number,
                y: number,
                width: number,
                height: number
            ): void;

            /**
             * Sets the number of sections in the grid view. Each section contains at least one row, and row numbering starts at 1 in each section.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.setNumberOfSections)
             */
            setNumberOfSections(num: number): void;

            /**
             * Returns the number of sections in the grid view.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.getNumberOfSections)
             */
            getNumberOfSections(): number;

            /**
             * Sets the number of rows in _section_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.setNumberOfRowsInSection)
             */
            setNumberOfRowsInSection(section: number, num: number): void;

            /**
             * Returns the number of rows in _section_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.getNumberOfRowsInSection)
             */
            getNumberOfRowsInSection(section: number): number;

            /**
             * Sets the number of columns in the gridview. 1 by default.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.setNumberOfColumns)
             */
            setNumberOfColumns(num: number): void;

            /**
             * Returns the number of columns in the gridview. 1 by default.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.getNumberOfColumns)
             */
            getNumberOfColumns(): number;

            /**
             * Convenience method for list-style gridviews, or for setting the number of rows for multiple sections at a time. Pass in a list of numbers of rows for sections starting from section 1.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.setNumberOfRows)
             */
            setNumberOfRows(...numbers: number[]): void;

            /**
             * Sets the size of the cells in the gridview. If cells should span the entire width of the grid (as in a list view), pass zero (0) for _cellWidth_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.setCellSize)
             */
            setCellSize(cellWidth: number, cellHeight: number): void;

            /**
             * Sets the amount of padding around cells.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.setCellPadding)
             */
            setCellPadding(
                left: number,
                right: number,
                top: number,
                bottom: number
            ): void;

            /**
             * Sets the amount of space the content is inset from the edges of the gridview. Useful if a background image is being used as a border.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.setContentInset)
             */
            setContentInset(
                left: number,
                right: number,
                top: number,
                bottom: number
            ): void;

            /**
             * Returns multiple values (x, y, width, height) representing the bounds of the cell, not including padding, relative to the top-right corner of the grid view.
             *
             * If the grid view is configured with zero width cells (see [playdate.ui.gridview:new](https://sdk.play.date/2.5.0#f-gridview.new)), _gridWidth_ is required, and should be the same value you would pass to [playdate.ui.gridview:drawInRect](https://sdk.play.date/2.5.0#m-gridview.drawInRect).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.getCellBounds)
             */
            getCellBounds(
                section: number,
                row: number,
                column: number,
                gridWidth?: number
            ): LuaMultiReturn<[number, number, number, number]>;

            /**
             * Sets the height of the section headers. 0 by default, which causes section headers not to be drawn.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.setSectionHeaderHeight)
             */
            setSectionHeaderHeight(height: number = 0): void;

            /**
             * Sets the amount of padding around section headers.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.setSectionHeaderPadding)
             */
            setSectionHeaderPadding(
                left: number,
                right: number,
                top: number,
                bottom: number
            ): void;

            /**
             * Sets the height of the horizontal dividers. The default height is half the cell height specified when creating the grid view.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.setHorizontalDividerHeight)
             */
            setHorizontalDividerHeight(height: number): void;

            /**
             * Returns the height of the horizontal dividers.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.getHorizontalDividerHeight)
             */
            getHorizontalDividerHeight(): number;

            /**
             * Causes a horizontal divider to be drawn above the specified row. Drawing can be customized by overriding [playdate.ui.gridview:drawHorizontalDivider](https://sdk.play.date/2.5.0#m-gridview.drawHorizontalDivider).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.addHorizontalDividerAbove)
             */
            addHorizontalDividerAbove(section: number, row: number): void;

            /**
             * Removes all horizontal dividers from the grid view.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.removeHorizontalDividers)
             */
            removeHorizontalDividers(): void;

            /**
             * Controls the duration of scroll animations. 250ms by default.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.setScrollDuration)
             */
            setScrollDuration(ms: number): void;

            /**
             * 'set' scrolls to the coordinate _x_, _y_.
             *
             * If _animated_ is true (or not provided) the new scroll position is animated to using [playdate.ui.gridview.scrollEasingFunction](https://sdk.play.date/2.5.0#v-gridview.scrollEasingFunction) and the value set in [playdate.ui.gridview:setScrollDuration()](https://sdk.play.date/2.5.0#m-gridview.setScrollDuration).
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.setScrollPosition)
             */
            setScrollPosition(x: number, y: number, animated?: boolean): void;

            /**
             * Returns the current scroll location as a pair _x_, _y_.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.getScrollPosition)
             */
            getScrollPosition(): LuaMultiReturn<[number, number]>;

            /**
             * Scrolls to the specified cell, just enough so the cell is visible.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.scrollToCell)
             */
            scrollToCell(
                section: number,
                row: number,
                column: number,
                animated?: boolean
            ): void;

            /**
             * Scrolls to the specified cell, so the cell is centered in the gridview, if possible.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.scrollCellToCenter)
             */
            scrollCellToCenter(
                section: number,
                row: number,
                column: number,
                animated?: boolean
            ): void;

            /**
             * Convenience function for list-style gridviews. Scrolls to the specified row in the list.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.scrollToRow)
             */
            scrollToRow(row: number, animated?: boolean): void;

            /**
             * Scrolls to the top of the gridview.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.scrollToTop)
             */
            scrollToTop(animated?: boolean): void;

            /**
             * Selects the cell at the given position.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.setSelection)
             */
            setSelection(section: number, row: number, column: number): void;

            /**
             * Returns the currently-selected cell as _section_, _row_, _column_
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.getSelection)
             */
            getSelection(): LuaMultiReturn<[number, number, number]>;

            /**
             * Convenience method for list-style gridviews. Selects the cell at _row_ in section 1.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.setSelectedRow)
             */
            setSelectedRow(row: number): void;

            /**
             * Convenience method for list-style gridviews. Returns the selected cell at _row_ in section 1.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.getSelectedRow)
             */
            getSelectedRow(): number;

            /**
             * Selects the cell directly below the currently-selected cell.
             *
             * If _wrapSelection_ is true, the selection will wrap around to the opposite end of the grid. If _scrollToSelection_ is true (or not provided), the newly-selected cell will be scrolled to. If _animate_ is true (or not provided), the scroll will be animated.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.selectNextRow)
             */
            selectNextRow(
                wrapSelection: boolean,
                scrollToSelection?: boolean = true,
                animate?: boolean = true
            ): void;

            /**
             * Identical to `selectNextRow()` but goes the other direction.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.selectPreviousRow)
             */
            selectPreviousRow(
                wrapSelection: boolean,
                scrollToSelection?: boolean = true,
                animate?: boolean = true
            ): void;

            /**
             * Selects the cell directly to the right of the currently-selected cell.
             *
             * If the last column is currently selected and _wrapSelection_ is true, the selection will wrap around to the opposite side of the grid. If a wrap occurs and the gridview’s [`changeRowOnColumnWrap`](https://sdk.play.date/2.5.0#v-gridview.changeRowOnColumnWrap) is `true` the row will also be advanced or moved back.
             *
             * If _scrollToSelection_ is true (or not provided), the newly-selected cell will be scrolled to. If _animate_ is true (or not provided), the scroll will be animated.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.selectNextColumn)
             */
            selectNextColumn(
                wrapSelection: boolean,
                scrollToSelection?: boolean = true,
                animate?: boolean = true
            ): void;

            /**
             * Identical to `selectNextColumn()` but goes the other direction.
             *
             * [Read more](https://sdk.play.date/2.5.0#m-ui.gridview.selectPreviousColumn)
             */
            selectPreviousColumn(
                wrapSelection: boolean,
                scrollToSelection?: boolean = true,
                animate?: boolean = true
            ): void;

            /**
             * This read-only variable returns true if the gridview needs to be redrawn. This can be used to help optimize drawing in your app. Keep in mind that a gridview cannot know all reasons it may need to be redrawn, such as changes in your drawing callback functions, coordinate or size changes, or overlapping drawing, so you may need to additionally redraw at other times.
             *
             * [Read more](https://sdk.play.date/2.5.0#v-ui.gridview.needsDisplay)
             */
            readonly needsDisplay: boolean;
            /**
             * A background image that draws behind the gridview’s cells. This image can be either a [`playdate.graphics.image`](https://sdk.play.date/2.5.0#C-graphics.image) which will be tiled or a [`playdate.nineSlice`](https://sdk.play.date/2.5.0#C-graphics.nineSlice).
             *
             * [Read more](https://sdk.play.date/2.5.0#v-ui.gridview.backgroundImage)
             */
            backgroundImage:
                | playdate.graphics.image
                | playdate.graphics.nineSlice;
            /**
             * Read-only. True if the gridview is currently performing a scroll animation.
             *
             * [Read more](https://sdk.play.date/2.5.0#v-ui.gridview.isScrolling)
             */
            readonly isScrolling: boolean;
            /**
             * The easing function used when performing scroll animations. The function should be of the form function(t, b, c, d), where t is elapsed time, b is the beginning value, c is the change, or end value - start value, and d is the duration. Many such functions are available in [`playdate.easingFunctions`](https://sdk.play.date/2.5.0#M-easingFunctions). [`playdate.easingFunctions.outCubic`](https://sdk.play.date/2.5.0#f-easingFunctions.outCubic) is the default.
             *
             * [Read more](https://sdk.play.date/2.5.0#v-ui.gridview.scrollEasingFunction)
             */
            scrollEasingFunction: (
                t: number,
                b: number,
                c: number,
                d: number
            ) => number;
            /**
             * For [easing functions](https://sdk.play.date/2.5.0#M-easingFunctions) that take additional amplitude and period arguments (such as _inOutElastic_), set these to the desired values.
             *
             * [Read more](https://sdk.play.date/2.5.0#v-ui.gridview.easingAmplitude)
             */
            easingAmplitude: number;
            /**
             * For [easing functions](https://sdk.play.date/2.5.0#M-easingFunctions) that take additional amplitude and period arguments (such as _inOutElastic_), set these to the desired values.
             *
             * [Read more](https://sdk.play.date/2.5.0#v-ui.gridview.easingAmplitude)
             */
            easingPeriod: number;
            /**
             * Controls the behavior of [playdate.ui.gridview:selectPreviousColumn()](https://sdk.play.date/2.5.0#m-gridview.selectPreviousColumn) and [playdate.ui.gridview:selectNextColumn()](https://sdk.play.date/2.5.0#m-gridview.selectNextColumn) if the current selection is at the first or last column, respectively. If set to true, the selection switch to a new row to allow the selection to change. If false, the call will have no effect on the selection. True by default.
             *
             * [Read more](https://sdk.play.date/2.5.0#v-ui.gridview.changeRowOnColumnWrap)
             */
            changeRowOnColumnWrap: boolean;
            /**
             * If true, the gridview will attempt to center cells when scrolling. If false, the gridview will be scrolled just as much as necessary to make the cell visible.
             *
             * [Read more](https://sdk.play.date/2.5.0#v-ui.gridview.scrollCellsToCenter)
             */
            scrollCellsToCenter: boolean;
        }
    }
}

namespace json {
    /**
     * Takes the JSON encoded string and converts it to a Lua table.
     *
     * Equivalent to [`playdate->json->decode()`](./Inside%20Playdate%20with%20C.html#f-json.decode) in the C API.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-json.decode)
     *
     * @noSelf
     */
    export function decode(string: string): AnyTable;

    /**
     * Reads the given [playdate.file.file](https://sdk.play.date/2.5.0#M-file) object or the file at the given `path` and converts it to a Lua table.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-json.decodeFile)
     *
     * @noSelf
     */
    export function decodeFile(file: playdate.file.file): AnyTable;

    /**
     * Reads the given [playdate.file.file](https://sdk.play.date/2.5.0#M-file) object or the file at the given `path` and converts it to a Lua table.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-json.decodeFile)
     *
     * @noSelf
     */
    export function decodeFile(path: string): AnyTable;

    /**
     * Returns a string containing the JSON representation of the passed-in Lua table.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-json.encode)
     *
     * @noSelf
     */
    export function encode(table: AnyTable): string;

    /**
     * Returns a string containing the JSON representation of a Lua table, with human-readable formatting.
     *
     * [Read more](https://sdk.play.date/2.5.0#f-json.encodePretty)
     *
     * @noSelf
     */
    export function encodePretty(table: AnyTable): string;

    /**
     * Encodes the Lua table `table` to JSON and writes it to the given [playdate.file.file](https://sdk.play.date/2.5.0#M-file) object or the given `path`. If `pretty` is true, the output is formatted to make it human-readable. Otherwise, no additional whitespace is added.
     *
     * Tip
     *
     * For a very simple way to serialize a table to a file, see [playdate.datastore](https://sdk.play.date/2.5.0#M-datastore).
     *
     * [Read more](https://sdk.play.date/2.5.0#f-json.encodeToFile)
     *
     * @noSelf
     */
    export function encodeToFile(
        file: playdate.file.file,
        pretty?: boolean,
        table: AnyTable
    ): void;

    /**
     * Encodes the Lua table `table` to JSON and writes it to the given [playdate.file.file](https://sdk.play.date/2.5.0#M-file) object or the given `path`. If `pretty` is true, the output is formatted to make it human-readable. Otherwise, no additional whitespace is added.
     *
     * Tip
     *
     * For a very simple way to serialize a table to a file, see [playdate.datastore](https://sdk.play.date/2.5.0#M-datastore).
     *
     * [Read more](https://sdk.play.date/2.5.0#f-json.encodeToFile)
     *
     * @noSelf
     */
    export function encodeToFile(
        path: string,
        pretty?: boolean,
        table: AnyTable
    ): void;
}
